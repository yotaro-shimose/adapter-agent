pub mod numrs2
pub mod numrs2::algorithms
pub mod numrs2::algorithms::cache_aware
pub enum numrs2::algorithms::cache_aware::MemoryOperation<T>
pub numrs2::algorithms::cache_aware::MemoryOperation::Convolution
pub numrs2::algorithms::cache_aware::MemoryOperation::Convolution::_phantom: core::marker::PhantomData<T>
pub numrs2::algorithms::cache_aware::MemoryOperation::Convolution::input_size: usize
pub numrs2::algorithms::cache_aware::MemoryOperation::Convolution::kernel_size: usize
pub numrs2::algorithms::cache_aware::MemoryOperation::Convolution::output_size: usize
pub numrs2::algorithms::cache_aware::MemoryOperation::MatrixMultiply
pub numrs2::algorithms::cache_aware::MemoryOperation::MatrixMultiply::_phantom: core::marker::PhantomData<T>
pub numrs2::algorithms::cache_aware::MemoryOperation::MatrixMultiply::k: usize
pub numrs2::algorithms::cache_aware::MemoryOperation::MatrixMultiply::m: usize
pub numrs2::algorithms::cache_aware::MemoryOperation::MatrixMultiply::n: usize
pub numrs2::algorithms::cache_aware::MemoryOperation::VectorOperation
pub numrs2::algorithms::cache_aware::MemoryOperation::VectorOperation::_phantom: core::marker::PhantomData<T>
pub numrs2::algorithms::cache_aware::MemoryOperation::VectorOperation::length: usize
pub struct numrs2::algorithms::cache_aware::BandwidthEstimate
pub numrs2::algorithms::cache_aware::BandwidthEstimate::cache_friendly: bool
pub numrs2::algorithms::cache_aware::BandwidthEstimate::estimated_time_ns: u64
pub numrs2::algorithms::cache_aware::BandwidthEstimate::recommended_blocking: bool
pub numrs2::algorithms::cache_aware::BandwidthEstimate::total_bytes: usize
pub struct numrs2::algorithms::cache_aware::BandwidthOptimizer
impl numrs2::algorithms::cache_aware::BandwidthOptimizer
pub fn numrs2::algorithms::cache_aware::BandwidthOptimizer::estimate_bandwidth<T>(&self, operation: numrs2::algorithms::cache_aware::MemoryOperation<T>) -> numrs2::algorithms::cache_aware::BandwidthEstimate
pub fn numrs2::algorithms::cache_aware::BandwidthOptimizer::new(cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub struct numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>
impl<T: numrs2::traits::NumericElement> numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::matvec_blocked(&self, matrix: &[T], vector: &[T], result: &mut [T], rows: usize, cols: usize) -> numrs2::Result<()> where T: core::marker::Copy + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::merge_sort_cache_oblivious(&self, data: &mut [T]) -> numrs2::Result<()> where T: core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::new(cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::optimal_tile_size(&self, element_size: usize) -> (usize, usize)
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::optimize_stride_access<F>(&self, data: &mut [T], rows: usize, cols: usize, operation: F) -> numrs2::Result<()> where F: core::ops::function::FnMut(&mut T, usize, usize), T: core::marker::Copy
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::sum_blocked(&self, data: &[T]) -> T where T: core::marker::Copy + core::ops::arith::Add<Output = T>
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::transpose_blocked(&self, src: &[T], dst: &mut [T], rows: usize, cols: usize) -> numrs2::Result<()> where T: core::marker::Copy
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::with_default_config() -> Self
impl<T: numrs2::traits::NumericElement> core::default::Default for numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::default() -> Self
pub struct numrs2::algorithms::cache_aware::CacheAwareConvolution<T>
impl<T: numrs2::traits::NumericElement + core::marker::Copy> numrs2::algorithms::cache_aware::CacheAwareConvolution<T>
pub fn numrs2::algorithms::cache_aware::CacheAwareConvolution<T>::conv2d_blocked(&self, input: &[T], kernel: &[T], output: &mut [T], input_height: usize, input_width: usize, kernel_height: usize, kernel_width: usize) -> numrs2::Result<()> where T: core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::algorithms::cache_aware::CacheAwareConvolution<T>::new(cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub fn numrs2::algorithms::cache_aware::CacheAwareConvolution<T>::separable_conv2d(&self, input: &[T], h_kernel: &[T], v_kernel: &[T], output: &mut [T], height: usize, width: usize) -> numrs2::Result<()> where T: core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub struct numrs2::algorithms::cache_aware::CacheAwareFFT<T>
impl<T: numrs2::traits::FloatingPoint> numrs2::algorithms::cache_aware::CacheAwareFFT<T>
pub fn numrs2::algorithms::cache_aware::CacheAwareFFT<T>::fft_cache_oblivious(&self, data: &mut [num_complex::Complex<T>]) -> numrs2::Result<()>
pub fn numrs2::algorithms::cache_aware::CacheAwareFFT<T>::ifft_cache_oblivious(&self, data: &mut [num_complex::Complex<T>]) -> numrs2::Result<()>
pub fn numrs2::algorithms::cache_aware::CacheAwareFFT<T>::new(cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub enum numrs2::algorithms::MemoryOperation<T>
pub numrs2::algorithms::MemoryOperation::Convolution
pub numrs2::algorithms::MemoryOperation::Convolution::_phantom: core::marker::PhantomData<T>
pub numrs2::algorithms::MemoryOperation::Convolution::input_size: usize
pub numrs2::algorithms::MemoryOperation::Convolution::kernel_size: usize
pub numrs2::algorithms::MemoryOperation::Convolution::output_size: usize
pub numrs2::algorithms::MemoryOperation::MatrixMultiply
pub numrs2::algorithms::MemoryOperation::MatrixMultiply::_phantom: core::marker::PhantomData<T>
pub numrs2::algorithms::MemoryOperation::MatrixMultiply::k: usize
pub numrs2::algorithms::MemoryOperation::MatrixMultiply::m: usize
pub numrs2::algorithms::MemoryOperation::MatrixMultiply::n: usize
pub numrs2::algorithms::MemoryOperation::VectorOperation
pub numrs2::algorithms::MemoryOperation::VectorOperation::_phantom: core::marker::PhantomData<T>
pub numrs2::algorithms::MemoryOperation::VectorOperation::length: usize
pub struct numrs2::algorithms::BandwidthEstimate
pub numrs2::algorithms::BandwidthEstimate::cache_friendly: bool
pub numrs2::algorithms::BandwidthEstimate::estimated_time_ns: u64
pub numrs2::algorithms::BandwidthEstimate::recommended_blocking: bool
pub numrs2::algorithms::BandwidthEstimate::total_bytes: usize
pub struct numrs2::algorithms::BandwidthOptimizer
impl numrs2::algorithms::cache_aware::BandwidthOptimizer
pub fn numrs2::algorithms::cache_aware::BandwidthOptimizer::estimate_bandwidth<T>(&self, operation: numrs2::algorithms::cache_aware::MemoryOperation<T>) -> numrs2::algorithms::cache_aware::BandwidthEstimate
pub fn numrs2::algorithms::cache_aware::BandwidthOptimizer::new(cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub struct numrs2::algorithms::CacheAwareArrayOps<T>
impl<T: numrs2::traits::NumericElement> numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::matvec_blocked(&self, matrix: &[T], vector: &[T], result: &mut [T], rows: usize, cols: usize) -> numrs2::Result<()> where T: core::marker::Copy + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::merge_sort_cache_oblivious(&self, data: &mut [T]) -> numrs2::Result<()> where T: core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::new(cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::optimal_tile_size(&self, element_size: usize) -> (usize, usize)
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::optimize_stride_access<F>(&self, data: &mut [T], rows: usize, cols: usize, operation: F) -> numrs2::Result<()> where F: core::ops::function::FnMut(&mut T, usize, usize), T: core::marker::Copy
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::sum_blocked(&self, data: &[T]) -> T where T: core::marker::Copy + core::ops::arith::Add<Output = T>
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::transpose_blocked(&self, src: &[T], dst: &mut [T], rows: usize, cols: usize) -> numrs2::Result<()> where T: core::marker::Copy
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::with_default_config() -> Self
impl<T: numrs2::traits::NumericElement> core::default::Default for numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::default() -> Self
pub struct numrs2::algorithms::CacheAwareConvolution<T>
impl<T: numrs2::traits::NumericElement + core::marker::Copy> numrs2::algorithms::cache_aware::CacheAwareConvolution<T>
pub fn numrs2::algorithms::cache_aware::CacheAwareConvolution<T>::conv2d_blocked(&self, input: &[T], kernel: &[T], output: &mut [T], input_height: usize, input_width: usize, kernel_height: usize, kernel_width: usize) -> numrs2::Result<()> where T: core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::algorithms::cache_aware::CacheAwareConvolution<T>::new(cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub fn numrs2::algorithms::cache_aware::CacheAwareConvolution<T>::separable_conv2d(&self, input: &[T], h_kernel: &[T], v_kernel: &[T], output: &mut [T], height: usize, width: usize) -> numrs2::Result<()> where T: core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub struct numrs2::algorithms::CacheAwareFFT<T>
impl<T: numrs2::traits::FloatingPoint> numrs2::algorithms::cache_aware::CacheAwareFFT<T>
pub fn numrs2::algorithms::cache_aware::CacheAwareFFT<T>::fft_cache_oblivious(&self, data: &mut [num_complex::Complex<T>]) -> numrs2::Result<()>
pub fn numrs2::algorithms::cache_aware::CacheAwareFFT<T>::ifft_cache_oblivious(&self, data: &mut [num_complex::Complex<T>]) -> numrs2::Result<()>
pub fn numrs2::algorithms::cache_aware::CacheAwareFFT<T>::new(cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub mod numrs2::array
pub struct numrs2::array::Array<T>
impl numrs2::array::Array<bool>
pub fn numrs2::array::Array<bool>::logical_and(&self, other: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array::Array<bool>::logical_not(&self) -> numrs2::array::Array<bool>
pub fn numrs2::array::Array<bool>::logical_or(&self, other: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array::Array<bool>::logical_xor(&self, other: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
impl numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::dot_simd(&self, other: &Self) -> numrs2::Result<f64>
pub fn numrs2::array::Array<f64>::norm_l1_simd(&self) -> f64
pub fn numrs2::array::Array<f64>::norm_l2_simd(&self) -> f64
impl<T: core::clone::Clone + core::ops::arith::Add<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::add(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::add_broadcast(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: core::clone::Clone + core::ops::arith::Add<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::add_scalar(&self, scalar: T) -> Self
impl<T: core::clone::Clone + core::ops::arith::Div<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::divide(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::divide_broadcast(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: core::clone::Clone + core::ops::arith::Div<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::divide_scalar(&self, scalar: T) -> Self
impl<T: core::clone::Clone + core::ops::arith::Mul<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::multiply(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::multiply_broadcast(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: core::clone::Clone + core::ops::arith::Mul<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::multiply_scalar(&self, scalar: T) -> Self
impl<T: core::clone::Clone + core::ops::arith::Sub<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::subtract(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::subtract_broadcast(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: core::clone::Clone + core::ops::arith::Sub<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::subtract_scalar(&self, scalar: T) -> Self
impl<T: core::clone::Clone + for<'a> serde_core::de::Deserialize<'a> + core::str::traits::FromStr> numrs2::array::Array<T> where <T as core::str::traits::FromStr>::Err: core::fmt::Debug
pub fn numrs2::array::Array<T>::from_file<P: core::convert::AsRef<std::path::Path>>(path: P, format: numrs2::io::SerializeFormat) -> numrs2::Result<Self>
pub fn numrs2::array::Array<T>::from_string(s: &str, format: numrs2::io::SerializeFormat) -> numrs2::Result<Self>
impl<T: core::clone::Clone + num_traits::identities::Zero> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::choose(&self, choices: &[&Self], mode: core::option::Option<&str>) -> numrs2::Result<Self> where T: core::clone::Clone + alloc::string::ToString
pub fn numrs2::array::Array<T>::compress<U>(&self, condition: &numrs2::array::Array<U>, axis: core::option::Option<usize>) -> numrs2::Result<Self> where T: core::clone::Clone + alloc::string::ToString, U: core::clone::Clone + alloc::string::ToString
pub fn numrs2::array::Array<T>::diag(&self) -> numrs2::Result<Self> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::diagonal(&self, offset: isize, axis1: core::option::Option<usize>, axis2: core::option::Option<usize>) -> numrs2::Result<Self> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::get(&self, indices: &[usize]) -> numrs2::Result<T>
pub fn numrs2::array::Array<T>::index(&self, index_specs: &[numrs2::indexing::IndexSpec]) -> numrs2::Result<Self> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::set_mask(&mut self, mask: &numrs2::array::Array<bool>, values: &numrs2::array::Array<T>) -> numrs2::Result<()> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::take(&self, indices: &Self, axis: core::option::Option<usize>) -> numrs2::Result<Self> where T: core::clone::Clone + alloc::string::ToString
impl<T: core::clone::Clone + serde_core::ser::Serialize> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::to_file<P: core::convert::AsRef<std::path::Path>>(&self, path: P, format: numrs2::io::SerializeFormat) -> numrs2::Result<()>
pub fn numrs2::array::Array<T>::to_row_vectors(&self) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<T>>>
pub fn numrs2::array::Array<T>::to_string(&self, format: numrs2::io::SerializeFormat) -> numrs2::Result<alloc::string::String>
impl<T: core::clone::Clone> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::array(&self) -> &ndarray::Array<T, ndarray::aliases::IxDyn>
pub fn numrs2::array::Array<T>::array_mut(&mut self) -> &mut ndarray::Array<T, ndarray::aliases::IxDyn>
pub fn numrs2::array::Array<T>::base(&self) -> core::option::Option<&numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::broadcast_op<F, U, V>(&self, other: &numrs2::array::Array<U>, op: F) -> numrs2::Result<numrs2::array::Array<V>> where T: core::clone::Clone, U: core::clone::Clone, V: core::clone::Clone, F: core::ops::function::Fn(&numrs2::array::Array<T>, &numrs2::array::Array<U>) -> numrs2::array::Array<V>
pub fn numrs2::array::Array<T>::broadcast_shape(a_shape: &[usize], b_shape: &[usize]) -> numrs2::Result<alloc::vec::Vec<usize>>
pub fn numrs2::array::Array<T>::broadcast_to(&self, shape: &[usize]) -> numrs2::Result<Self> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::byte_strides(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::array::Array<T>::create_diagonal_matrix(v: &numrs2::array::Array<T>, k: isize) -> Self where T: num_traits::identities::Zero + core::clone::Clone
pub fn numrs2::array::Array<T>::create_diagonal_matrix_helper(v: &numrs2::array::Array<T>, k: isize) -> Self where T: num_traits::identities::Zero + core::clone::Clone
pub fn numrs2::array::Array<T>::diagflat(v: &numrs2::array::Array<T>, k: isize) -> Self where T: num_traits::identities::Zero + core::clone::Clone
pub fn numrs2::array::Array<T>::empty(shape: &[usize]) -> Self where T: core::default::Default + core::clone::Clone
pub fn numrs2::array::Array<T>::empty_like<U>(other: &numrs2::array::Array<U>) -> Self where T: core::default::Default + core::clone::Clone, U: core::clone::Clone
pub fn numrs2::array::Array<T>::empty_like_with<U>(other: &numrs2::array::Array<U>, shape: core::option::Option<&[usize]>) -> Self where T: core::default::Default + core::clone::Clone, U: core::clone::Clone
pub fn numrs2::array::Array<T>::eye(n_rows: usize, n_cols: usize, k: isize) -> Self where T: num_traits::identities::Zero + num_traits::identities::One + core::clone::Clone
pub fn numrs2::array::Array<T>::eye_square(n: usize) -> Self where T: num_traits::identities::Zero + num_traits::identities::One + core::clone::Clone
pub fn numrs2::array::Array<T>::flags(&self) -> numrs2::array::ArrayFlags
pub fn numrs2::array::Array<T>::flatten(&self, order: core::option::Option<&str>) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::from_ndarray(array: ndarray::Array<T, ndarray::aliases::IxDyn>) -> Self
pub fn numrs2::array::Array<T>::from_vec(vec: alloc::vec::Vec<T>) -> Self
pub fn numrs2::array::Array<T>::full(shape: &[usize], value: T) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::identity(n: usize) -> Self where T: num_traits::identities::Zero + num_traits::identities::One + core::clone::Clone
pub fn numrs2::array::Array<T>::itemsize(&self) -> usize
pub fn numrs2::array::Array<T>::map<F, U>(&self, f: F) -> numrs2::array::Array<U> where U: core::clone::Clone, F: core::ops::function::Fn(T) -> U, T: core::clone::Clone
pub fn numrs2::array::Array<T>::nbytes(&self) -> usize
pub fn numrs2::array::Array<T>::ndarray_view(&self) -> ndarray::ArrayView<'_, T, ndarray::aliases::IxDyn>
pub fn numrs2::array::Array<T>::ndarray_view_mut(&mut self) -> &mut Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::ndim(&self) -> usize
pub fn numrs2::array::Array<T>::ones(shape: &[usize]) -> Self where T: num_traits::identities::One + core::clone::Clone
pub fn numrs2::array::Array<T>::ones_like<U>(other: &numrs2::array::Array<U>) -> Self where T: num_traits::identities::One + core::clone::Clone, U: core::clone::Clone
pub fn numrs2::array::Array<T>::ones_like_with<U>(other: &numrs2::array::Array<U>, shape: core::option::Option<&[usize]>) -> Self where T: num_traits::identities::One + core::clone::Clone, U: core::clone::Clone
pub fn numrs2::array::Array<T>::owns_data(&self) -> bool
pub fn numrs2::array::Array<T>::par_map<F, U>(&self, f: F) -> numrs2::array::Array<U> where T: core::marker::Send + core::marker::Sync + core::clone::Clone, U: core::marker::Send + core::clone::Clone, F: core::ops::function::Fn(T) -> U + core::marker::Send + core::marker::Sync
pub fn numrs2::array::Array<T>::reshape(&self, shape: &[usize]) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::reshape_with(&self, shape: &[usize], copy: bool) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::reshape_with_option(&self, shape: &[usize], copy: bool) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::scalar_div(&self, scalar: T) -> Self where T: core::clone::Clone + core::ops::arith::Div<Output = T>
pub fn numrs2::array::Array<T>::scalar_mul(&self, scalar: T) -> Self where T: core::clone::Clone + core::ops::arith::Mul<Output = T>
pub fn numrs2::array::Array<T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::array::Array<T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::array::Array<T>::size(&self) -> usize
pub fn numrs2::array::Array<T>::slice(&self, axis: usize, index: usize) -> numrs2::Result<Self> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::strides(&self) -> alloc::vec::Vec<isize>
pub fn numrs2::array::Array<T>::sum_all(&self) -> T where T: core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero
pub fn numrs2::array::Array<T>::sum_axis(&self, axis: usize) -> numrs2::Result<Self> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero
pub fn numrs2::array::Array<T>::to_vec(&self) -> alloc::vec::Vec<T> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::transpose(&self) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::transpose_axis(&self, axis1: usize, axis2: usize) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::tri(n: usize, m: core::option::Option<usize>, k: isize, value: core::option::Option<T>) -> Self where T: num_traits::identities::Zero + num_traits::identities::One + core::clone::Clone
pub fn numrs2::array::Array<T>::tril(&self, k: isize) -> Self where T: num_traits::identities::Zero + core::clone::Clone
pub fn numrs2::array::Array<T>::triu(&self, k: isize) -> Self where T: num_traits::identities::Zero + core::clone::Clone
pub fn numrs2::array::Array<T>::view_2d(&self) -> numrs2::Result<ndarray::aliases::ArrayView2<'_, T>> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::zeros(shape: &[usize]) -> Self where T: num_traits::identities::Zero + core::clone::Clone
pub fn numrs2::array::Array<T>::zeros_like<U>(other: &numrs2::array::Array<U>) -> Self where T: num_traits::identities::Zero + core::clone::Clone, U: core::clone::Clone
pub fn numrs2::array::Array<T>::zeros_like_with<U>(other: &numrs2::array::Array<U>, shape: core::option::Option<&[usize]>) -> Self where T: num_traits::identities::Zero + core::clone::Clone, U: core::clone::Clone
pub fn numrs2::array::Array<T>::zip_with<F, U, V>(&self, other: &numrs2::array::Array<U>, f: F) -> numrs2::Result<numrs2::array::Array<V>> where T: core::clone::Clone, U: core::clone::Clone, V: core::clone::Clone, F: core::ops::function::Fn(T, U) -> V
impl<T: core::clone::Clone> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::broadcast_view(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::create_strided_view(&self, shape: alloc::vec::Vec<usize>, strides: alloc::vec::Vec<isize>) -> numrs2::views::StridedArrayView<'_, T>
pub fn numrs2::array::Array<T>::diagonal_view(&self, offset: isize) -> numrs2::Result<numrs2::views::DiagonalView<'_, T>>
pub fn numrs2::array::Array<T>::sliced_view(&self, slices: &[numrs2::views::SliceOrIndex]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::strided_array_view(&self, strides: &[isize]) -> numrs2::Result<numrs2::views::StridedArrayView<'_, T>>
pub fn numrs2::array::Array<T>::strided_view(&self, strides: &[isize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::transposed_view(&self) -> numrs2::views::ArrayView<'_, T>
pub fn numrs2::array::Array<T>::view(&self) -> numrs2::views::ArrayView<'_, T>
pub fn numrs2::array::Array<T>::view_mut(&mut self) -> numrs2::views::ArrayViewMut<'_, T>
pub fn numrs2::array::Array<T>::window_view(&self, window_shape: &[usize], step: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::views::WindowView<'_, T>>
impl<T: core::clone::Clone> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::is_c_contiguous(&self) -> bool
pub fn numrs2::array::Array<T>::is_contiguous(&self) -> bool
pub fn numrs2::array::Array<T>::is_empty(&self) -> bool
pub fn numrs2::array::Array<T>::is_f_contiguous(&self) -> bool
pub fn numrs2::array::Array<T>::len(&self) -> usize
pub fn numrs2::array::Array<T>::to_c_layout(&self) -> Self
pub fn numrs2::array::Array<T>::to_f_layout(&self) -> Self
impl<T: core::clone::Clone> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::slice_view(&self, axis: usize, index: usize) -> numrs2::Result<numrs2::views::ArrayView<'_, T>>
impl<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::ops::arith::AddAssign + core::ops::arith::MulAssign + core::ops::arith::DivAssign + core::ops::arith::SubAssign + core::fmt::Display> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cond(&self) -> core::option::Option<T>
pub fn numrs2::array::Array<T>::is_well_conditioned(&self) -> bool
pub fn numrs2::array::Array<T>::rcond(&self) -> core::option::Option<T>
impl<T> numrs2::array::Array<T> where T: core::clone::Clone + core::cmp::PartialEq
pub fn numrs2::array::Array<T>::equal(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array::Array<T>::not_equal(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
impl<T> numrs2::array::Array<T> where T: core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::array::Array<T>::greater_equal(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array::Array<T>::greater_than(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array::Array<T>::less_equal(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array::Array<T>::less_than(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
impl<T> numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + num_traits::identities::Zero
pub fn numrs2::array::Array<T>::dot(&self, other: &Self) -> numrs2::Result<T>
pub fn numrs2::array::Array<T>::matmul(&self, other: &Self) -> numrs2::Result<Self>
impl<T> numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero + core::ops::arith::Mul<Output = T> + num_traits::identities::One + 'static
pub fn numrs2::array::Array<T>::product(&self) -> T
pub fn numrs2::array::Array<T>::sum(&self) -> T
impl<T> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::cast::NumCast
pub fn numrs2::array::Array<T>::add_mixed<V, U>(&self, other: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<V>> where T: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, U: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, V: core::clone::Clone + num_traits::cast::NumCast + core::ops::arith::Add<Output = V> + core::fmt::Debug
pub fn numrs2::array::Array<T>::divide_mixed<V, U>(&self, other: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<V>> where T: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, U: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, V: core::clone::Clone + num_traits::cast::NumCast + core::ops::arith::Div<Output = V> + core::fmt::Debug
pub fn numrs2::array::Array<T>::multiply_mixed<V, U>(&self, other: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<V>> where T: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, U: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, V: core::clone::Clone + num_traits::cast::NumCast + core::ops::arith::Mul<Output = V> + core::fmt::Debug
pub fn numrs2::array::Array<T>::subtract_mixed<V, U>(&self, other: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<V>> where T: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, U: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, V: core::clone::Clone + num_traits::cast::NumCast + core::ops::arith::Sub<Output = V> + core::fmt::Debug
impl<T> numrs2::array::Array<T> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::array::Array<T>::apply_window(&self, window_type: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::fft(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<T>::fft2(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<T>::fftshift_real(&self) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::ifftshift_real(&self) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::power_spectrum(&self) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::rfft(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<T>::rfft2(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
impl<T> numrs2::array::Array<T> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::array::Array<T>::apply_window_enhanced(&self, window_type: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::fft_any_size(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<T>::real_fft_optimized(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<T>::stockwell_transform(&self, min_freq: core::option::Option<usize>, max_freq: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
impl<T> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::astype<U>(&self) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + numrs2::conversions::ConvertibleTo<U> + core::fmt::Debug, U: core::clone::Clone
pub fn numrs2::array::Array<T>::downcast<U>(&self) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, U: core::clone::Clone + num_traits::cast::NumCast + core::cmp::PartialOrd + core::fmt::Debug
pub fn numrs2::array::Array<T>::to_complex<U>(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<U>>> where T: core::clone::Clone + num_traits::cast::NumCast, U: core::clone::Clone + num_traits::cast::NumCast + num_traits::identities::Zero
pub fn numrs2::array::Array<T>::upcast<U>(&self) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + num_traits::cast::AsPrimitive<U>, U: core::clone::Clone + 'static + core::marker::Copy
impl<T> numrs2::array::Array<num_complex::Complex<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::array::Array<num_complex::Complex<T>>::fftshift_complex(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::ifft(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::ifft2(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::ifftshift_complex(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::irfft(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::irfft2(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
impl numrs2::simd::SimdOps<f32> for numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_add(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_add_scalar(&self, scalar: f32) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_div(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_div_scalar(&self, scalar: f32) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_dot(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<f32>
pub fn numrs2::array::Array<f32>::simd_fma(&self, mul: &numrs2::array::Array<f32>, add: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_mean(&self) -> f32
pub fn numrs2::array::Array<f32>::simd_mul(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_mul_scalar(&self, scalar: f32) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_sub(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_sub_scalar(&self, scalar: f32) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_sum(&self) -> f32
impl numrs2::simd::SimdOps<f64> for numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::simd_add(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_add_scalar(&self, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::simd_div(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_div_scalar(&self, scalar: f64) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_dot(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<f64>
pub fn numrs2::array::Array<f64>::simd_fma(&self, mul: &numrs2::array::Array<f64>, add: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_mean(&self) -> f64
pub fn numrs2::array::Array<f64>::simd_mul(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_mul_scalar(&self, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::simd_sub(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_sub_scalar(&self, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::simd_sum(&self) -> f64
impl numrs2::simd_optimize::simd_traits::SimdArrayOps for numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_add(&self, other: &Self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_copy(&self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_dot(&self, other: &Self) -> numrs2::Result<f32>
pub fn numrs2::array::Array<f32>::simd_exp(&self) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_log(&self) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_matmul(&self, other: &Self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_mul(&self, other: &Self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_sin_cos(&self) -> (numrs2::array::Array<f32>, numrs2::array::Array<f32>)
pub fn numrs2::array::Array<f32>::simd_sum(&self) -> f32
impl<'b, T> core::ops::arith::Add<&'b numrs2::array::Array<T>> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::add(self, other: &'b numrs2::array::Array<T>) -> Self::Output
impl<'b, T> core::ops::arith::Div<&'b numrs2::array::Array<T>> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::div(self, other: &'b numrs2::array::Array<T>) -> Self::Output
impl<'b, T> core::ops::arith::Mul<&'b numrs2::array::Array<T>> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::mul(self, other: &'b numrs2::array::Array<T>) -> Self::Output
impl<'b, T> core::ops::arith::Rem<&'b numrs2::array::Array<T>> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Rem<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::rem(self, other: &'b numrs2::array::Array<T>) -> Self::Output
impl<'b, T> core::ops::arith::Sub<&'b numrs2::array::Array<T>> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::sub(self, other: &'b numrs2::array::Array<T>) -> Self::Output
impl<T: core::clone::Clone> core::convert::From<numrs2::array::Array<T>> for numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::from(arr: numrs2::array::Array<T>) -> Self
impl<T: core::clone::Clone> core::convert::From<numrs2::shared_array::SharedArray<T>> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::from(shared: numrs2::shared_array::SharedArray<T>) -> Self
impl<T: core::clone::Clone> numrs2::expr::LazyEval<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::lazy(&self) -> numrs2::expr::ArrayExpr<'_, T>
impl<T: core::fmt::Debug + core::clone::Clone> core::fmt::Debug for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::fmt::Display> core::fmt::Display for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: num_traits::float::Float + core::clone::Clone + 'static> numrs2::math::ElementWiseMath<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::abs(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::acos(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::acosh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::asin(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::asinh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::atan(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::atan2(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::atanh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cbrt(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::ceil(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::clip(&self, min: T, max: T) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cos(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cosh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::degrees(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::exp(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::expm1(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::floor(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::hypot(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log10(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log1p(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log2(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::logaddexp(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::logaddexp2(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::pow(&self, n: T) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::radians(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::round(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::safe_atan2(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::safe_hypot(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::safe_logaddexp(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::safe_logaddexp2(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::sign(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sin(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sinh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sqrt(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::tan(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::tanh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::trunc(&self) -> numrs2::array::Array<T>
impl<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + 'static> numrs2::linalg::vector_ops::RealVectorDotProduct<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::vdot(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<T>
impl<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug> numrs2::linalg::vector_ops::ComplexVectorDotProduct<T> for numrs2::array::Array<num_complex::Complex<T>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::vdot(&self, other: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<num_complex::Complex<T>>
impl<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync + 'static> numrs2::stats::Statistics<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::max(&self) -> T
pub fn numrs2::array::Array<T>::mean(&self) -> T
pub fn numrs2::array::Array<T>::min(&self) -> T
pub fn numrs2::array::Array<T>::percentile(&self, q: T) -> T
pub fn numrs2::array::Array<T>::std(&self) -> T
pub fn numrs2::array::Array<T>::var(&self) -> T
impl<T> core::convert::TryFrom<numrs2::array::Array<T>> for numrs2::matrix::Matrix<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub type numrs2::matrix::Matrix<T>::Error = numrs2::NumRs2Error
pub fn numrs2::matrix::Matrix<T>::try_from(array: numrs2::array::Array<T>) -> numrs2::Result<Self>
impl<T> core::ops::arith::Add for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::add(self, other: numrs2::array::Array<T>) -> Self::Output
impl<T> core::ops::arith::Add<T> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::add(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Add<T> for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::add(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Div for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::div(self, other: numrs2::array::Array<T>) -> Self::Output
impl<T> core::ops::arith::Div<T> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::div(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Div<T> for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::div(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Mul for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::mul(self, other: numrs2::array::Array<T>) -> Self::Output
impl<T> core::ops::arith::Mul<T> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::mul(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Mul<T> for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::mul(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Neg for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Neg<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::neg(self) -> Self::Output
impl<T> core::ops::arith::Neg for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Neg<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::neg(self) -> Self::Output
impl<T> core::ops::arith::Rem for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Rem<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::rem(self, other: numrs2::array::Array<T>) -> Self::Output
impl<T> core::ops::arith::Sub for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sub(self, other: numrs2::array::Array<T>) -> Self::Output
impl<T> core::ops::arith::Sub<T> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::sub(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Sub<T> for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sub(self, scalar: T) -> Self::Output
impl<T> numrs2::axis_ops::AxisOps<T> for numrs2::array::Array<T> where T: core::clone::Clone + core::cmp::PartialOrd + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::cast::NumCast + core::fmt::Debug
pub fn numrs2::array::Array<T>::argmax_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array::Array<T>::argmin_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array::Array<T>::cumprod_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::array::Array<T>::cumsum_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::max_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::mean_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::min_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::prod_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::array::Array<T>::std_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float
pub fn numrs2::array::Array<T>::sum_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::var_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float
pub struct numrs2::array::ArrayFlags
pub numrs2::array::ArrayFlags::aligned: bool
pub numrs2::array::ArrayFlags::c_contiguous: bool
pub numrs2::array::ArrayFlags::f_contiguous: bool
pub numrs2::array::ArrayFlags::owndata: bool
pub numrs2::array::ArrayFlags::writeable: bool
pub mod numrs2::array_ops
pub mod numrs2::array_ops::advanced_indexing
pub fn numrs2::array_ops::advanced_indexing::apply_along_axis<T, U, F>(func: F, array: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + num_traits::identities::Zero, U: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> U
pub fn numrs2::array_ops::advanced_indexing::apply_over_axes<T, F>(func: F, array: &numrs2::array::Array<T>, axes: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::advanced_indexing::boolean_index<T: core::clone::Clone>(array: &numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::advanced_indexing::compress<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::advanced_indexing::extract<T: core::clone::Clone>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::advanced_indexing::fancy_index<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &[numrs2::array::Array<usize>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::advanced_indexing::place<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>, values: &[T]) -> numrs2::Result<()>
pub fn numrs2::array_ops::advanced_indexing::put<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, indices: &numrs2::array::Array<usize>, values: &[T]) -> numrs2::Result<()>
pub fn numrs2::array_ops::advanced_indexing::putmask<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>, values: &numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::array_ops::advanced_indexing::select<T: core::clone::Clone>(conditions: &[numrs2::array::Array<bool>], choices: &[numrs2::array::Array<T>], default: T) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::advanced_indexing::take<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &numrs2::array::Array<usize>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::advanced_indexing::take_along_axis<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &numrs2::array::Array<usize>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::array_ops::array_requirements
pub struct numrs2::array_ops::array_requirements::ArrayRequirements(_)
impl numrs2::array_ops::ArrayRequirements
pub const numrs2::array_ops::ArrayRequirements::CONTIGUOUS: Self
pub const numrs2::array_ops::ArrayRequirements::C_LAYOUT: Self
pub const numrs2::array_ops::ArrayRequirements::F_LAYOUT: Self
pub const numrs2::array_ops::ArrayRequirements::OWNDATA: Self
pub const numrs2::array_ops::ArrayRequirements::WRITEABLE: Self
pub fn numrs2::array_ops::ArrayRequirements::contains(&self, other: Self) -> bool
pub fn numrs2::array_ops::ArrayRequirements::empty() -> Self
pub fn numrs2::array_ops::ArrayRequirements::is_empty(&self) -> bool
impl core::ops::bit::BitAnd for numrs2::array_ops::ArrayRequirements
pub type numrs2::array_ops::ArrayRequirements::Output = numrs2::array_ops::ArrayRequirements
pub fn numrs2::array_ops::ArrayRequirements::bitand(self, rhs: Self) -> Self
impl core::ops::bit::BitOr for numrs2::array_ops::ArrayRequirements
pub type numrs2::array_ops::ArrayRequirements::Output = numrs2::array_ops::ArrayRequirements
pub fn numrs2::array_ops::ArrayRequirements::bitor(self, rhs: Self) -> Self
pub fn numrs2::array_ops::array_requirements::require<T: core::clone::Clone>(array: &numrs2::array::Array<T>, requirements: core::option::Option<numrs2::array_ops::ArrayRequirements>) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::array_ops::atleast
pub fn numrs2::array_ops::atleast::atleast_1d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::atleast::atleast_2d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::atleast::atleast_3d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub mod numrs2::array_ops::axis_ops
pub fn numrs2::array_ops::axis_ops::moveaxis<T: core::clone::Clone>(array: &numrs2::array::Array<T>, source: &[usize], destination: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::axis_ops::rollaxis<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, axis: usize, start: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::axis_ops::swapaxes<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis1: usize, axis2: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::array_ops::broadcasting
pub fn numrs2::array_ops::broadcasting::broadcast_arrays<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::broadcasting::broadcast_to<T: core::clone::Clone>(array: &numrs2::array::Array<T>, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::array_ops::chartype
pub fn numrs2::array_ops::chartype::isalnum(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::chartype::isalpha(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::chartype::isdigit(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::chartype::islower(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::chartype::isspace(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::chartype::istitle(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::chartype::isupper(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub mod numrs2::array_ops::compare
pub fn numrs2::array_ops::compare::equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::compare::greater(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::compare::greater_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::compare::less(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::compare::less_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::compare::not_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub mod numrs2::array_ops::conditional
pub fn numrs2::array_ops::conditional::choose<T: core::clone::Clone + num_traits::identities::Zero>(a: &numrs2::array::Array<usize>, choices: &[&numrs2::array::Array<T>], mode: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::conditional::interp<T>(x: &numrs2::array::Array<T>, xp: &numrs2::array::Array<T>, fp: &numrs2::array::Array<T>, left: core::option::Option<T>, right: core::option::Option<T>, period: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::float::Float
pub fn numrs2::array_ops::conditional::piecewise<T, F>(x: &numrs2::array::Array<T>, condlist: &[&numrs2::array::Array<bool>], funclist: &[&F], fill_value: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array_ops::conditional::select<T: core::clone::Clone + num_traits::identities::Zero>(condlist: &[&numrs2::array::Array<bool>], choicelist: &[&numrs2::array::Array<T>], default: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::conditional::where_cond<T: core::clone::Clone + core::fmt::Display + core::marker::Send + core::marker::Sync>(condition: &numrs2::array::Array<bool>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::array_ops::creation
pub enum numrs2::array_ops::creation::SliceSpec
pub numrs2::array_ops::creation::SliceSpec::Ellipsis
pub numrs2::array_ops::creation::SliceSpec::Index(isize)
pub numrs2::array_ops::creation::SliceSpec::NewAxis
pub numrs2::array_ops::creation::SliceSpec::Range
pub numrs2::array_ops::creation::SliceSpec::Range::start: core::option::Option<isize>
pub numrs2::array_ops::creation::SliceSpec::Range::step: core::option::Option<isize>
pub numrs2::array_ops::creation::SliceSpec::Range::stop: core::option::Option<isize>
impl numrs2::array_ops::SliceSpec
pub fn numrs2::array_ops::SliceSpec::from(start: isize) -> Self
pub fn numrs2::array_ops::SliceSpec::from_to(start: isize, stop: isize) -> Self
pub fn numrs2::array_ops::SliceSpec::full() -> Self
pub fn numrs2::array_ops::SliceSpec::range(start: core::option::Option<isize>, stop: core::option::Option<isize>, step: core::option::Option<isize>) -> Self
pub fn numrs2::array_ops::SliceSpec::step(step: isize) -> Self
pub fn numrs2::array_ops::SliceSpec::to(stop: isize) -> Self
pub const numrs2::array_ops::creation::NEWAXIS: numrs2::array_ops::SliceSpec
pub fn numrs2::array_ops::creation::asanyarray<T>(a: &impl core::convert::AsRef<[T]>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::array_ops::creation::ascontiguousarray<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::array_ops::creation::asfortranarray<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::array_ops::creation::c_concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::creation::diagflat<T>(v: &numrs2::array::Array<T>, k: i32) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::array_ops::creation::frombuffer<T: core::clone::Clone + core::default::Default>(buffer: &[u8], dtype_size: usize, count: isize, offset: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::creation::fromfunction<T, F>(function: F, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&[usize]) -> T
pub fn numrs2::array_ops::creation::fromiter<T: core::clone::Clone, I: core::iter::traits::iterator::Iterator<Item = T>>(iter: I, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::creation::frommemmap<T: core::marker::Copy + core::clone::Clone + core::default::Default>(path: &std::path::Path, mode: &str, offset: core::option::Option<usize>, shape: core::option::Option<&[usize]>, order: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::creation::fromstring<T>(string: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: core::str::traits::FromStr + core::clone::Clone + num_traits::identities::Zero, <T as core::str::traits::FromStr>::Err: core::fmt::Display
pub fn numrs2::array_ops::creation::geomspace<T>(start: T, stop: T, num: usize, endpoint: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::array_ops::creation::iscontiguous<T>(_a: &numrs2::array::Array<T>) -> bool
pub fn numrs2::array_ops::creation::isfortran<T>(a: &numrs2::array::Array<T>) -> bool where T: core::clone::Clone
pub fn numrs2::array_ops::creation::ix_<T: core::clone::Clone>(sequences: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::creation::logspace<T>(start: T, stop: T, num: usize, endpoint: bool, base: T) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::array_ops::creation::may_share_memory<T>(_a: &numrs2::array::Array<T>, _b: &numrs2::array::Array<T>) -> bool
pub fn numrs2::array_ops::creation::meshgrid<T>(xi: &[&numrs2::array::Array<T>], indexing: &str, sparse: bool) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::array_ops::creation::mgrid<T>(slices: &[(T, T, T)]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd + num_traits::cast::FromPrimitive + 'static
pub fn numrs2::array_ops::creation::ogrid<T>(slices: &[(T, T, T)]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd + num_traits::cast::FromPrimitive + 'static
pub fn numrs2::array_ops::creation::r_concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::creation::s_(specs: &[numrs2::array_ops::SliceSpec]) -> alloc::vec::Vec<numrs2::array_ops::SliceSpec>
pub fn numrs2::array_ops::creation::shares_memory<T>(_a: &numrs2::array::Array<T>, _b: &numrs2::array::Array<T>) -> bool
pub fn numrs2::array_ops::creation::tri<T>(n: usize, m: core::option::Option<usize>, k: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::array_ops::creation::vander<T>(x: &numrs2::array::Array<T>, n: core::option::Option<usize>, increasing: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Mul<Output = T>
pub mod numrs2::array_ops::diagonal
pub fn numrs2::array_ops::diagonal::diag<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: impl core::convert::Into<core::option::Option<isize>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::diagonal::diagonal<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, offset: impl core::convert::Into<core::option::Option<isize>>, axis1: impl core::convert::Into<core::option::Option<usize>>, axis2: impl core::convert::Into<core::option::Option<usize>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::diagonal::fill_diagonal<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, val: T, wrap: bool) -> numrs2::Result<()>
pub mod numrs2::array_ops::joining
pub enum numrs2::array_ops::joining::AxisArg
pub numrs2::array_ops::joining::AxisArg::Multiple(alloc::vec::Vec<usize>)
pub numrs2::array_ops::joining::AxisArg::Single(usize)
impl core::convert::From<&[usize]> for numrs2::array_ops::joining::AxisArg
pub fn numrs2::array_ops::joining::AxisArg::from(axes: &[usize]) -> Self
impl core::convert::From<alloc::vec::Vec<usize>> for numrs2::array_ops::joining::AxisArg
pub fn numrs2::array_ops::joining::AxisArg::from(axes: alloc::vec::Vec<usize>) -> Self
impl core::convert::From<usize> for numrs2::array_ops::joining::AxisArg
pub fn numrs2::array_ops::joining::AxisArg::from(axis: usize) -> Self
pub fn numrs2::array_ops::joining::block<T: core::clone::Clone>(blocks: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::joining::bmat<T: core::clone::Clone>(obj: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::joining::bmat_from_arrays<T: core::clone::Clone>(obj: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::joining::bmat_from_string<T: core::clone::Clone>(_description: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::joining::c_<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::joining::column_stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::joining::concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>], axis: impl core::convert::Into<numrs2::array_ops::joining::AxisArg>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::joining::dstack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::joining::hstack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::joining::r_<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::joining::row_stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::joining::stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>], axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::joining::vstack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::array_ops::manipulation
pub fn numrs2::array_ops::manipulation::append<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, values: &[T], axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::compress<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::delete<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &[usize], axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::expand_dims<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::extract<T: core::clone::Clone>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::flatten<T: core::clone::Clone>(array: &numrs2::array::Array<T>, order: core::option::Option<char>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::flip<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::fliplr<T: core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::flipud<T: core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::insert<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &[usize], values: &[T], axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::packbits(array: &numrs2::array::Array<u8>, axis: core::option::Option<isize>, bitorder: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<u8>>
pub fn numrs2::array_ops::manipulation::pad<T>(array: &numrs2::array::Array<T>, pad_width: &[(usize, usize)], mode: &str, constant_values: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::array_ops::manipulation::place<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>, values: &[T]) -> numrs2::Result<()>
pub fn numrs2::array_ops::manipulation::put<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, indices: &[usize], values: &[T]) -> numrs2::Result<()>
pub fn numrs2::array_ops::manipulation::ravel<T: core::clone::Clone>(array: &numrs2::array::Array<T>, order: core::option::Option<char>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::ravel_multi_index(multi_index: &[&numrs2::array::Array<usize>], dims: &[usize], mode: core::option::Option<&str>, order: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array_ops::manipulation::roll<T: core::clone::Clone + core::marker::Send + core::marker::Sync>(array: &numrs2::array::Array<T>, shift: isize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::rot90<T: core::clone::Clone>(array: &numrs2::array::Array<T>, k: impl core::convert::Into<core::option::Option<i32>>, axes: impl core::convert::Into<core::option::Option<(usize, usize)>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::squeeze<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::tril<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: isize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::trim_zeros<T>(array: &numrs2::array::Array<T>, trim: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::array_ops::manipulation::triu<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: isize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::manipulation::unpackbits(packed: &numrs2::array::Array<u8>, axis: core::option::Option<isize>, count: core::option::Option<usize>, bitorder: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<u8>>
pub fn numrs2::array_ops::manipulation::unravel_index(indices: &numrs2::array::Array<usize>, shape: &[usize], order: core::option::Option<&str>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>>
pub mod numrs2::array_ops::sorting
pub fn numrs2::array_ops::sorting::bincount<T, W>(x: &numrs2::array::Array<T>, weights: core::option::Option<&numrs2::array::Array<W>>, minlength: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<W>> where T: core::clone::Clone + num_traits::cast::ToPrimitive + core::cmp::PartialOrd + num_traits::identities::Zero, W: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::AddAssign + num_traits::cast::NumCast
pub fn numrs2::array_ops::sorting::digitize<T>(x: &numrs2::array::Array<T>, bins: &numrs2::array::Array<T>, right: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::array_ops::sorting::lexsort<T: core::clone::Clone + core::cmp::PartialOrd + num_traits::identities::Zero>(keys: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array_ops::sorting::msort<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::sorting::partition<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>, kth: usize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::sorting::searchsorted<T: core::clone::Clone + core::cmp::PartialOrd>(a: &numrs2::array::Array<T>, v: &numrs2::array::Array<T>, side: core::option::Option<&str>, sorter: core::option::Option<&numrs2::array::Array<usize>>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array_ops::sorting::sort<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>, kind: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::sorting::sort_complex<T>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: core::clone::Clone + core::cmp::PartialOrd + num_traits::float::Float
pub mod numrs2::array_ops::splitting
pub enum numrs2::array_ops::splitting::SplitArg
pub numrs2::array_ops::splitting::SplitArg::Indices(alloc::vec::Vec<usize>)
pub numrs2::array_ops::splitting::SplitArg::Sections(usize)
impl core::convert::From<&[usize]> for numrs2::array_ops::SplitArg
pub fn numrs2::array_ops::SplitArg::from(indices: &[usize]) -> Self
impl core::convert::From<alloc::vec::Vec<usize>> for numrs2::array_ops::SplitArg
pub fn numrs2::array_ops::SplitArg::from(indices: alloc::vec::Vec<usize>) -> Self
impl core::convert::From<usize> for numrs2::array_ops::SplitArg
pub fn numrs2::array_ops::SplitArg::from(sections: usize) -> Self
pub fn numrs2::array_ops::splitting::array_split<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>, axis: usize) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::splitting::dsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::splitting::hsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::splitting::split<T: core::clone::Clone>(array: &numrs2::array::Array<T>, indices: &[usize], axis: usize) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::splitting::vsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub mod numrs2::array_ops::string_ops
pub mod numrs2::array_ops::string_ops::chartype
pub fn numrs2::array_ops::string_ops::chartype::isalnum(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::chartype::isalpha(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::chartype::isdigit(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::chartype::islower(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::chartype::isspace(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::chartype::istitle(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::chartype::isupper(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub mod numrs2::array_ops::string_ops::compare
pub fn numrs2::array_ops::string_ops::compare::equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::compare::greater(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::compare::greater_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::compare::less(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::compare::less_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::compare::not_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub enum numrs2::array_ops::string_ops::StringElement
pub numrs2::array_ops::string_ops::StringElement::Fixed
pub numrs2::array_ops::string_ops::StringElement::Fixed::data: alloc::vec::Vec<u8>
pub numrs2::array_ops::string_ops::StringElement::Fixed::max_len: usize
pub numrs2::array_ops::string_ops::StringElement::Unicode(alloc::string::String)
impl numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::as_str(&self) -> numrs2::Result<&str>
pub fn numrs2::array_ops::string_ops::StringElement::capacity(&self) -> usize
pub fn numrs2::array_ops::string_ops::StringElement::fixed(s: &str, max_len: usize) -> Self
pub fn numrs2::array_ops::string_ops::StringElement::is_empty(&self) -> numrs2::Result<bool>
pub fn numrs2::array_ops::string_ops::StringElement::len(&self) -> numrs2::Result<usize>
pub fn numrs2::array_ops::string_ops::StringElement::to_string(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::array_ops::string_ops::StringElement::unicode<S: core::convert::Into<alloc::string::String>>(s: S) -> Self
impl core::cmp::Ord for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::cmp(&self, other: &Self) -> core::cmp::Ordering
impl core::cmp::PartialOrd for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering>
impl core::default::Default for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::default() -> Self
impl core::fmt::Display for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add for numrs2::array_ops::string_ops::StringElement
pub type numrs2::array_ops::string_ops::StringElement::Output = numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::add(self, other: Self) -> Self
impl num_traits::identities::Zero for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::is_zero(&self) -> bool
pub fn numrs2::array_ops::string_ops::StringElement::zero() -> Self
pub fn numrs2::array_ops::string_ops::add(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::array_from_strings<S: core::convert::AsRef<str>>(strings: &[S], dtype: &str, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::capitalize(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::center(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::count(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::array_ops::string_ops::endswith(arr: &numrs2::array_ops::string_ops::StringArray, suffix: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::find(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::array_ops::string_ops::join(sep: &str, arr: &[alloc::vec::Vec<alloc::string::String>]) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::ljust(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::lower(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::lstrip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::mod_format(arr: &numrs2::array_ops::string_ops::StringArray, values: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::multiply(arr: &numrs2::array_ops::string_ops::StringArray, times: &numrs2::array::Array<i32>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::replace(arr: &numrs2::array_ops::string_ops::StringArray, old: &str, new: &str, count: core::option::Option<usize>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::rfind(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::array_ops::string_ops::rjust(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::rstrip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::split(arr: &numrs2::array_ops::string_ops::StringArray, sep: core::option::Option<&str>, maxsplit: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::array_ops::string_ops::startswith(arr: &numrs2::array_ops::string_ops::StringArray, prefix: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_ops::strip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::title(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_ops::upper(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub type numrs2::array_ops::string_ops::StringArray = numrs2::array::Array<numrs2::array_ops::string_ops::StringElement>
pub mod numrs2::array_ops::tiling
pub fn numrs2::array_ops::tiling::repeat<T: core::clone::Clone>(array: &numrs2::array::Array<T>, repeats: usize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::tiling::tile<T: core::clone::Clone>(array: &numrs2::array::Array<T>, reps: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub enum numrs2::array_ops::SliceSpec
pub numrs2::array_ops::SliceSpec::Ellipsis
pub numrs2::array_ops::SliceSpec::Index(isize)
pub numrs2::array_ops::SliceSpec::NewAxis
pub numrs2::array_ops::SliceSpec::Range
pub numrs2::array_ops::SliceSpec::Range::start: core::option::Option<isize>
pub numrs2::array_ops::SliceSpec::Range::step: core::option::Option<isize>
pub numrs2::array_ops::SliceSpec::Range::stop: core::option::Option<isize>
impl numrs2::array_ops::SliceSpec
pub fn numrs2::array_ops::SliceSpec::from(start: isize) -> Self
pub fn numrs2::array_ops::SliceSpec::from_to(start: isize, stop: isize) -> Self
pub fn numrs2::array_ops::SliceSpec::full() -> Self
pub fn numrs2::array_ops::SliceSpec::range(start: core::option::Option<isize>, stop: core::option::Option<isize>, step: core::option::Option<isize>) -> Self
pub fn numrs2::array_ops::SliceSpec::step(step: isize) -> Self
pub fn numrs2::array_ops::SliceSpec::to(stop: isize) -> Self
pub enum numrs2::array_ops::SplitArg
pub numrs2::array_ops::SplitArg::Indices(alloc::vec::Vec<usize>)
pub numrs2::array_ops::SplitArg::Sections(usize)
impl core::convert::From<&[usize]> for numrs2::array_ops::SplitArg
pub fn numrs2::array_ops::SplitArg::from(indices: &[usize]) -> Self
impl core::convert::From<alloc::vec::Vec<usize>> for numrs2::array_ops::SplitArg
pub fn numrs2::array_ops::SplitArg::from(indices: alloc::vec::Vec<usize>) -> Self
impl core::convert::From<usize> for numrs2::array_ops::SplitArg
pub fn numrs2::array_ops::SplitArg::from(sections: usize) -> Self
pub enum numrs2::array_ops::StringElement
pub numrs2::array_ops::StringElement::Fixed
pub numrs2::array_ops::StringElement::Fixed::data: alloc::vec::Vec<u8>
pub numrs2::array_ops::StringElement::Fixed::max_len: usize
pub numrs2::array_ops::StringElement::Unicode(alloc::string::String)
impl numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::as_str(&self) -> numrs2::Result<&str>
pub fn numrs2::array_ops::string_ops::StringElement::capacity(&self) -> usize
pub fn numrs2::array_ops::string_ops::StringElement::fixed(s: &str, max_len: usize) -> Self
pub fn numrs2::array_ops::string_ops::StringElement::is_empty(&self) -> numrs2::Result<bool>
pub fn numrs2::array_ops::string_ops::StringElement::len(&self) -> numrs2::Result<usize>
pub fn numrs2::array_ops::string_ops::StringElement::to_string(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::array_ops::string_ops::StringElement::unicode<S: core::convert::Into<alloc::string::String>>(s: S) -> Self
impl core::cmp::Ord for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::cmp(&self, other: &Self) -> core::cmp::Ordering
impl core::cmp::PartialOrd for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering>
impl core::default::Default for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::default() -> Self
impl core::fmt::Display for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add for numrs2::array_ops::string_ops::StringElement
pub type numrs2::array_ops::string_ops::StringElement::Output = numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::add(self, other: Self) -> Self
impl num_traits::identities::Zero for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::is_zero(&self) -> bool
pub fn numrs2::array_ops::string_ops::StringElement::zero() -> Self
pub struct numrs2::array_ops::ArrayRequirements(_)
impl numrs2::array_ops::ArrayRequirements
pub const numrs2::array_ops::ArrayRequirements::CONTIGUOUS: Self
pub const numrs2::array_ops::ArrayRequirements::C_LAYOUT: Self
pub const numrs2::array_ops::ArrayRequirements::F_LAYOUT: Self
pub const numrs2::array_ops::ArrayRequirements::OWNDATA: Self
pub const numrs2::array_ops::ArrayRequirements::WRITEABLE: Self
pub fn numrs2::array_ops::ArrayRequirements::contains(&self, other: Self) -> bool
pub fn numrs2::array_ops::ArrayRequirements::empty() -> Self
pub fn numrs2::array_ops::ArrayRequirements::is_empty(&self) -> bool
impl core::ops::bit::BitAnd for numrs2::array_ops::ArrayRequirements
pub type numrs2::array_ops::ArrayRequirements::Output = numrs2::array_ops::ArrayRequirements
pub fn numrs2::array_ops::ArrayRequirements::bitand(self, rhs: Self) -> Self
impl core::ops::bit::BitOr for numrs2::array_ops::ArrayRequirements
pub type numrs2::array_ops::ArrayRequirements::Output = numrs2::array_ops::ArrayRequirements
pub fn numrs2::array_ops::ArrayRequirements::bitor(self, rhs: Self) -> Self
pub const numrs2::array_ops::NEWAXIS: numrs2::array_ops::SliceSpec
pub fn numrs2::array_ops::adv_compress<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::adv_extract<T: core::clone::Clone>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::adv_place<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>, values: &[T]) -> numrs2::Result<()>
pub fn numrs2::array_ops::adv_put<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, indices: &numrs2::array::Array<usize>, values: &[T]) -> numrs2::Result<()>
pub fn numrs2::array_ops::append<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, values: &[T], axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::apply_along_axis<T, U, F>(func: F, array: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + num_traits::identities::Zero, U: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> U
pub fn numrs2::array_ops::apply_over_axes<T, F>(func: F, array: &numrs2::array::Array<T>, axes: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::array_from_strings<S: core::convert::AsRef<str>>(strings: &[S], dtype: &str, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::array_split<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>, axis: usize) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::asanyarray<T>(a: &impl core::convert::AsRef<[T]>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::array_ops::ascontiguousarray<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::array_ops::asfortranarray<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::array_ops::atleast_1d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::atleast_2d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::atleast_3d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::bincount<T, W>(x: &numrs2::array::Array<T>, weights: core::option::Option<&numrs2::array::Array<W>>, minlength: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<W>> where T: core::clone::Clone + num_traits::cast::ToPrimitive + core::cmp::PartialOrd + num_traits::identities::Zero, W: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::AddAssign + num_traits::cast::NumCast
pub fn numrs2::array_ops::block<T: core::clone::Clone>(blocks: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::bmat<T: core::clone::Clone>(obj: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::bmat_from_arrays<T: core::clone::Clone>(obj: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::bmat_from_string<T: core::clone::Clone>(_description: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::broadcast_arrays<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::broadcast_to<T: core::clone::Clone>(array: &numrs2::array::Array<T>, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::c_<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::c_concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::capitalize(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::center(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::choose<T: core::clone::Clone + num_traits::identities::Zero>(a: &numrs2::array::Array<usize>, choices: &[&numrs2::array::Array<T>], mode: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::column_stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::compress<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>], axis: impl core::convert::Into<numrs2::array_ops::joining::AxisArg>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::delete<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &[usize], axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::diag<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: impl core::convert::Into<core::option::Option<isize>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::diagflat<T>(v: &numrs2::array::Array<T>, k: i32) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::array_ops::diagonal<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, offset: impl core::convert::Into<core::option::Option<isize>>, axis1: impl core::convert::Into<core::option::Option<usize>>, axis2: impl core::convert::Into<core::option::Option<usize>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::digitize<T>(x: &numrs2::array::Array<T>, bins: &numrs2::array::Array<T>, right: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::array_ops::dsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::dstack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::endswith(arr: &numrs2::array_ops::string_ops::StringArray, suffix: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::expand_dims<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::extract<T: core::clone::Clone>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::fill_diagonal<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, val: T, wrap: bool) -> numrs2::Result<()>
pub fn numrs2::array_ops::flatten<T: core::clone::Clone>(array: &numrs2::array::Array<T>, order: core::option::Option<char>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::flip<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::fliplr<T: core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::flipud<T: core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::frombuffer<T: core::clone::Clone + core::default::Default>(buffer: &[u8], dtype_size: usize, count: isize, offset: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::fromfunction<T, F>(function: F, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&[usize]) -> T
pub fn numrs2::array_ops::fromiter<T: core::clone::Clone, I: core::iter::traits::iterator::Iterator<Item = T>>(iter: I, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::frommemmap<T: core::marker::Copy + core::clone::Clone + core::default::Default>(path: &std::path::Path, mode: &str, offset: core::option::Option<usize>, shape: core::option::Option<&[usize]>, order: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::fromstring<T>(string: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: core::str::traits::FromStr + core::clone::Clone + num_traits::identities::Zero, <T as core::str::traits::FromStr>::Err: core::fmt::Display
pub fn numrs2::array_ops::geomspace<T>(start: T, stop: T, num: usize, endpoint: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::array_ops::hsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::hstack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::insert<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &[usize], values: &[T], axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::interp<T>(x: &numrs2::array::Array<T>, xp: &numrs2::array::Array<T>, fp: &numrs2::array::Array<T>, left: core::option::Option<T>, right: core::option::Option<T>, period: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::float::Float
pub fn numrs2::array_ops::iscontiguous<T>(_a: &numrs2::array::Array<T>) -> bool
pub fn numrs2::array_ops::isfortran<T>(a: &numrs2::array::Array<T>) -> bool where T: core::clone::Clone
pub fn numrs2::array_ops::ix_<T: core::clone::Clone>(sequences: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::lexsort<T: core::clone::Clone + core::cmp::PartialOrd + num_traits::identities::Zero>(keys: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array_ops::ljust(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::logspace<T>(start: T, stop: T, num: usize, endpoint: bool, base: T) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::array_ops::lower(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::lstrip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::may_share_memory<T>(_a: &numrs2::array::Array<T>, _b: &numrs2::array::Array<T>) -> bool
pub fn numrs2::array_ops::meshgrid<T>(xi: &[&numrs2::array::Array<T>], indexing: &str, sparse: bool) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::array_ops::mgrid<T>(slices: &[(T, T, T)]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd + num_traits::cast::FromPrimitive + 'static
pub fn numrs2::array_ops::mod_format(arr: &numrs2::array_ops::string_ops::StringArray, values: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::moveaxis<T: core::clone::Clone>(array: &numrs2::array::Array<T>, source: &[usize], destination: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::msort<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::ogrid<T>(slices: &[(T, T, T)]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd + num_traits::cast::FromPrimitive + 'static
pub fn numrs2::array_ops::packbits(array: &numrs2::array::Array<u8>, axis: core::option::Option<isize>, bitorder: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<u8>>
pub fn numrs2::array_ops::pad<T>(array: &numrs2::array::Array<T>, pad_width: &[(usize, usize)], mode: &str, constant_values: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::array_ops::partition<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>, kth: usize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::piecewise<T, F>(x: &numrs2::array::Array<T>, condlist: &[&numrs2::array::Array<bool>], funclist: &[&F], fill_value: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array_ops::place<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>, values: &[T]) -> numrs2::Result<()>
pub fn numrs2::array_ops::put<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, indices: &[usize], values: &[T]) -> numrs2::Result<()>
pub fn numrs2::array_ops::putmask<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>, values: &numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::array_ops::r_<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::r_concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::ravel<T: core::clone::Clone>(array: &numrs2::array::Array<T>, order: core::option::Option<char>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::ravel_multi_index(multi_index: &[&numrs2::array::Array<usize>], dims: &[usize], mode: core::option::Option<&str>, order: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array_ops::repeat<T: core::clone::Clone>(array: &numrs2::array::Array<T>, repeats: usize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::replace(arr: &numrs2::array_ops::string_ops::StringArray, old: &str, new: &str, count: core::option::Option<usize>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::require<T: core::clone::Clone>(array: &numrs2::array::Array<T>, requirements: core::option::Option<numrs2::array_ops::ArrayRequirements>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::rjust(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::roll<T: core::clone::Clone + core::marker::Send + core::marker::Sync>(array: &numrs2::array::Array<T>, shift: isize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::rollaxis<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, axis: usize, start: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::rot90<T: core::clone::Clone>(array: &numrs2::array::Array<T>, k: impl core::convert::Into<core::option::Option<i32>>, axes: impl core::convert::Into<core::option::Option<(usize, usize)>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::row_stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::rstrip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::s_(specs: &[numrs2::array_ops::SliceSpec]) -> alloc::vec::Vec<numrs2::array_ops::SliceSpec>
pub fn numrs2::array_ops::searchsorted<T: core::clone::Clone + core::cmp::PartialOrd>(a: &numrs2::array::Array<T>, v: &numrs2::array::Array<T>, side: core::option::Option<&str>, sorter: core::option::Option<&numrs2::array::Array<usize>>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array_ops::select<T: core::clone::Clone + num_traits::identities::Zero>(condlist: &[&numrs2::array::Array<bool>], choicelist: &[&numrs2::array::Array<T>], default: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::shares_memory<T>(_a: &numrs2::array::Array<T>, _b: &numrs2::array::Array<T>) -> bool
pub fn numrs2::array_ops::sort<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>, kind: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::sort_complex<T>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: core::clone::Clone + core::cmp::PartialOrd + num_traits::float::Float
pub fn numrs2::array_ops::split<T: core::clone::Clone>(array: &numrs2::array::Array<T>, indices: &[usize], axis: usize) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::squeeze<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>], axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::startswith(arr: &numrs2::array_ops::string_ops::StringArray, prefix: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array_ops::string_add(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_count(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::array_ops::string_find(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::array_ops::string_join(sep: &str, arr: &[alloc::vec::Vec<alloc::string::String>]) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_multiply(arr: &numrs2::array_ops::string_ops::StringArray, times: &numrs2::array::Array<i32>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::string_rfind(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::array_ops::string_split(arr: &numrs2::array_ops::string_ops::StringArray, sep: core::option::Option<&str>, maxsplit: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::array_ops::strip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::swapaxes<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis1: usize, axis2: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::take_along_axis<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &numrs2::array::Array<usize>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::tile<T: core::clone::Clone>(array: &numrs2::array::Array<T>, reps: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::title(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::tri<T>(n: usize, m: core::option::Option<usize>, k: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::array_ops::tril<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: isize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::trim_zeros<T>(array: &numrs2::array::Array<T>, trim: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::array_ops::triu<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: isize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::unpackbits(packed: &numrs2::array::Array<u8>, axis: core::option::Option<isize>, count: core::option::Option<usize>, bitorder: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<u8>>
pub fn numrs2::array_ops::unravel_index(indices: &numrs2::array::Array<usize>, shape: &[usize], order: core::option::Option<&str>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>>
pub fn numrs2::array_ops::upper(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::array_ops::vander<T>(x: &numrs2::array::Array<T>, n: core::option::Option<usize>, increasing: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Mul<Output = T>
pub fn numrs2::array_ops::vsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops::vstack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops::where_cond<T: core::clone::Clone + core::fmt::Display + core::marker::Send + core::marker::Sync>(condition: &numrs2::array::Array<bool>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub type numrs2::array_ops::StringArray = numrs2::array::Array<numrs2::array_ops::string_ops::StringElement>
pub mod numrs2::array_ops_legacy
pub enum numrs2::array_ops_legacy::AxisArg
pub numrs2::array_ops_legacy::AxisArg::Multiple(alloc::vec::Vec<usize>)
pub numrs2::array_ops_legacy::AxisArg::Single(usize)
impl core::convert::From<&[usize]> for numrs2::array_ops_legacy::AxisArg
pub fn numrs2::array_ops_legacy::AxisArg::from(axes: &[usize]) -> Self
impl core::convert::From<alloc::vec::Vec<usize>> for numrs2::array_ops_legacy::AxisArg
pub fn numrs2::array_ops_legacy::AxisArg::from(axes: alloc::vec::Vec<usize>) -> Self
impl core::convert::From<usize> for numrs2::array_ops_legacy::AxisArg
pub fn numrs2::array_ops_legacy::AxisArg::from(axis: usize) -> Self
pub enum numrs2::array_ops_legacy::SplitArg
pub numrs2::array_ops_legacy::SplitArg::Indices(alloc::vec::Vec<usize>)
pub numrs2::array_ops_legacy::SplitArg::Sections(usize)
impl core::convert::From<&[usize]> for numrs2::array_ops_legacy::SplitArg
pub fn numrs2::array_ops_legacy::SplitArg::from(indices: &[usize]) -> Self
impl core::convert::From<alloc::vec::Vec<usize>> for numrs2::array_ops_legacy::SplitArg
pub fn numrs2::array_ops_legacy::SplitArg::from(indices: alloc::vec::Vec<usize>) -> Self
impl core::convert::From<usize> for numrs2::array_ops_legacy::SplitArg
pub fn numrs2::array_ops_legacy::SplitArg::from(sections: usize) -> Self
pub struct numrs2::array_ops_legacy::ArrayRequirements(_)
impl numrs2::array_ops_legacy::ArrayRequirements
pub const numrs2::array_ops_legacy::ArrayRequirements::CONTIGUOUS: Self
pub const numrs2::array_ops_legacy::ArrayRequirements::C_LAYOUT: Self
pub const numrs2::array_ops_legacy::ArrayRequirements::F_LAYOUT: Self
pub const numrs2::array_ops_legacy::ArrayRequirements::OWNDATA: Self
pub const numrs2::array_ops_legacy::ArrayRequirements::WRITEABLE: Self
pub fn numrs2::array_ops_legacy::ArrayRequirements::contains(&self, other: Self) -> bool
pub fn numrs2::array_ops_legacy::ArrayRequirements::empty() -> Self
pub fn numrs2::array_ops_legacy::ArrayRequirements::is_empty(&self) -> bool
impl core::ops::bit::BitAnd for numrs2::array_ops_legacy::ArrayRequirements
pub type numrs2::array_ops_legacy::ArrayRequirements::Output = numrs2::array_ops_legacy::ArrayRequirements
pub fn numrs2::array_ops_legacy::ArrayRequirements::bitand(self, rhs: Self) -> Self
impl core::ops::bit::BitOr for numrs2::array_ops_legacy::ArrayRequirements
pub type numrs2::array_ops_legacy::ArrayRequirements::Output = numrs2::array_ops_legacy::ArrayRequirements
pub fn numrs2::array_ops_legacy::ArrayRequirements::bitor(self, rhs: Self) -> Self
pub fn numrs2::array_ops_legacy::atleast_1d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops_legacy::atleast_2d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops_legacy::atleast_3d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops_legacy::block<T: core::clone::Clone>(blocks: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::broadcast_arrays<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops_legacy::broadcast_to<T: core::clone::Clone>(array: &numrs2::array::Array<T>, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::c_<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>], axis: impl core::convert::Into<numrs2::array_ops_legacy::AxisArg>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::diag<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: impl core::convert::Into<core::option::Option<isize>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::diagonal<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, offset: impl core::convert::Into<core::option::Option<isize>>, axis1: impl core::convert::Into<core::option::Option<usize>>, axis2: impl core::convert::Into<core::option::Option<usize>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::dsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops_legacy::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops_legacy::frombuffer<T: core::clone::Clone + core::default::Default>(buffer: &[u8], dtype_size: usize, count: isize, offset: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::fromfunction<T, F>(function: F, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&[usize]) -> T
pub fn numrs2::array_ops_legacy::fromiter<T: core::clone::Clone, I: core::iter::traits::iterator::Iterator<Item = T>>(iter: I, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::hsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops_legacy::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops_legacy::interp<T>(x: &numrs2::array::Array<T>, xp: &numrs2::array::Array<T>, fp: &numrs2::array::Array<T>, left: core::option::Option<T>, right: core::option::Option<T>, period: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::float::Float
pub fn numrs2::array_ops_legacy::moveaxis<T: core::clone::Clone>(array: &numrs2::array::Array<T>, source: &[usize], destination: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::partition<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>, kth: usize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::r_<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::repeat<T: core::clone::Clone>(array: &numrs2::array::Array<T>, repeats: usize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::require<T: core::clone::Clone>(array: &numrs2::array::Array<T>, requirements: core::option::Option<numrs2::array_ops_legacy::ArrayRequirements>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::rollaxis<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, axis: usize, start: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::searchsorted<T: core::clone::Clone + core::cmp::PartialOrd>(a: &numrs2::array::Array<T>, v: &numrs2::array::Array<T>, side: core::option::Option<&str>, sorter: core::option::Option<&numrs2::array::Array<usize>>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array_ops_legacy::select<T: core::clone::Clone + num_traits::identities::Zero>(condlist: &[&numrs2::array::Array<bool>], choicelist: &[&numrs2::array::Array<T>], default: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::split<T: core::clone::Clone>(array: &numrs2::array::Array<T>, indices: &[usize], axis: usize) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops_legacy::stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>], axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::swapaxes<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis1: usize, axis2: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::tile<T: core::clone::Clone>(array: &numrs2::array::Array<T>, reps: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array_ops_legacy::vsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops_legacy::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::array_ops_legacy::where_cond<T: core::clone::Clone + core::fmt::Display>(condition: &numrs2::array::Array<bool>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::arrays
pub mod numrs2::arrays::advanced_ops
pub enum numrs2::arrays::advanced_ops::IndexSpec
pub numrs2::arrays::advanced_ops::IndexSpec::All
pub numrs2::arrays::advanced_ops::IndexSpec::Array(alloc::vec::Vec<usize>)
pub numrs2::arrays::advanced_ops::IndexSpec::BoolMask(alloc::vec::Vec<bool>)
pub numrs2::arrays::advanced_ops::IndexSpec::Ellipsis
pub numrs2::arrays::advanced_ops::IndexSpec::Index(isize)
pub numrs2::arrays::advanced_ops::IndexSpec::Indices(alloc::vec::Vec<usize>)
pub numrs2::arrays::advanced_ops::IndexSpec::Int(isize)
pub numrs2::arrays::advanced_ops::IndexSpec::Mask(alloc::vec::Vec<bool>)
pub numrs2::arrays::advanced_ops::IndexSpec::NewAxis
pub numrs2::arrays::advanced_ops::IndexSpec::Slice(core::option::Option<isize>, core::option::Option<isize>, core::option::Option<isize>)
impl numrs2::arrays::IndexSpec
pub fn numrs2::arrays::IndexSpec::from_range<R>(range: R, _axis_size: usize) -> Self where R: core::convert::Into<numrs2::arrays::SliceInfo>
pub fn numrs2::arrays::IndexSpec::resolve(&self, axis_size: usize) -> numrs2::Result<numrs2::arrays::ResolvedIndex>
pub enum numrs2::arrays::advanced_ops::ResolvedIndex
pub numrs2::arrays::advanced_ops::ResolvedIndex::Multiple(alloc::vec::Vec<usize>)
pub numrs2::arrays::advanced_ops::ResolvedIndex::Single(usize)
pub struct numrs2::arrays::advanced_ops::ArrayView<'a, T>
impl<'a, T> numrs2::arrays::ArrayView<'a, T>
pub fn numrs2::arrays::ArrayView<'a, T>::from_data(data: &'a [T], shape: numrs2::arrays::Shape) -> numrs2::Result<Self>
pub fn numrs2::arrays::ArrayView<'a, T>::get(&self, indices: &[usize]) -> numrs2::Result<&T>
pub fn numrs2::arrays::ArrayView<'a, T>::is_c_contiguous(&self) -> bool
pub fn numrs2::arrays::ArrayView<'a, T>::is_f_contiguous(&self) -> bool
pub fn numrs2::arrays::ArrayView<'a, T>::new(data: &'a [T], shape: numrs2::arrays::Shape, strides: alloc::vec::Vec<usize>, offset: usize) -> numrs2::Result<Self>
pub fn numrs2::arrays::ArrayView<'a, T>::reshape(&self, new_shape: numrs2::arrays::Shape) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>>
pub fn numrs2::arrays::ArrayView<'a, T>::shape(&self) -> &numrs2::arrays::Shape
pub fn numrs2::arrays::ArrayView<'a, T>::slice(&self, indices: &[numrs2::arrays::IndexSpec]) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>>
pub fn numrs2::arrays::ArrayView<'a, T>::strides(&self) -> &[usize]
pub fn numrs2::arrays::ArrayView<'a, T>::transpose(&self, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>>
impl<T: core::clone::Clone> numrs2::arrays::ArrayView<'_, T>
pub fn numrs2::arrays::ArrayView<'_, T>::to_vec(&self) -> alloc::vec::Vec<T>
pub struct numrs2::arrays::advanced_ops::ArrayViewIterator<T>
impl<T> core::iter::traits::iterator::Iterator for numrs2::arrays::ArrayViewIterator<T>
pub type numrs2::arrays::ArrayViewIterator<T>::Item = *const T
pub fn numrs2::arrays::ArrayViewIterator<T>::next(&mut self) -> core::option::Option<Self::Item>
pub struct numrs2::arrays::advanced_ops::BroadcastOp
impl numrs2::arrays::BroadcastOp
pub fn numrs2::arrays::BroadcastOp::binary_op<T, F>(a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>, output: &mut [T], op: F) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::arrays::BroadcastOp::unary_op<T, F>(input: &numrs2::arrays::ArrayView<'_, T>, output: &mut [T], target_shape: &numrs2::arrays::Shape, op: F) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T) -> T
pub struct numrs2::arrays::advanced_ops::Shape
pub numrs2::arrays::advanced_ops::Shape::dims: alloc::vec::Vec<usize>
impl numrs2::arrays::Shape
pub fn numrs2::arrays::Shape::broadcast_with(&self, other: &numrs2::arrays::Shape) -> numrs2::Result<numrs2::arrays::Shape>
pub fn numrs2::arrays::Shape::c_strides(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::arrays::Shape::f_strides(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::arrays::Shape::from_1d(size: usize) -> Self
pub fn numrs2::arrays::Shape::from_2d(rows: usize, cols: usize) -> Self
pub fn numrs2::arrays::Shape::is_broadcastable_with(&self, other: &numrs2::arrays::Shape) -> bool
pub fn numrs2::arrays::Shape::ndim(&self) -> usize
pub fn numrs2::arrays::Shape::new(dims: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::arrays::Shape::reshape(&self, new_dims: alloc::vec::Vec<usize>) -> numrs2::Result<numrs2::arrays::Shape>
pub fn numrs2::arrays::Shape::size(&self) -> usize
pub fn numrs2::arrays::Shape::transpose(&self, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<numrs2::arrays::Shape>
pub struct numrs2::arrays::advanced_ops::SliceInfo
pub numrs2::arrays::advanced_ops::SliceInfo::start: core::option::Option<isize>
pub numrs2::arrays::advanced_ops::SliceInfo::step: core::option::Option<isize>
pub numrs2::arrays::advanced_ops::SliceInfo::stop: core::option::Option<isize>
impl core::convert::From<core::ops::range::Range<usize>> for numrs2::arrays::SliceInfo
pub fn numrs2::arrays::SliceInfo::from(range: core::ops::range::Range<usize>) -> Self
impl core::convert::From<core::ops::range::RangeFrom<usize>> for numrs2::arrays::SliceInfo
pub fn numrs2::arrays::SliceInfo::from(range: core::ops::range::RangeFrom<usize>) -> Self
impl core::convert::From<core::ops::range::RangeFull> for numrs2::arrays::SliceInfo
pub fn numrs2::arrays::SliceInfo::from(_: core::ops::range::RangeFull) -> Self
impl core::convert::From<core::ops::range::RangeInclusive<usize>> for numrs2::arrays::SliceInfo
pub fn numrs2::arrays::SliceInfo::from(range: core::ops::range::RangeInclusive<usize>) -> Self
impl core::convert::From<core::ops::range::RangeTo<usize>> for numrs2::arrays::SliceInfo
pub fn numrs2::arrays::SliceInfo::from(range: core::ops::range::RangeTo<usize>) -> Self
impl core::convert::From<core::ops::range::RangeToInclusive<usize>> for numrs2::arrays::SliceInfo
pub fn numrs2::arrays::SliceInfo::from(range: core::ops::range::RangeToInclusive<usize>) -> Self
pub mod numrs2::arrays::broadcasting
pub enum numrs2::arrays::broadcasting::MemoryOptimization
pub numrs2::arrays::broadcasting::MemoryOptimization::Balanced
pub numrs2::arrays::broadcasting::MemoryOptimization::Memory
pub numrs2::arrays::broadcasting::MemoryOptimization::Performance
pub struct numrs2::arrays::broadcasting::BroadcastConfig
pub numrs2::arrays::broadcasting::BroadcastConfig::enable_parallel: bool
pub numrs2::arrays::broadcasting::BroadcastConfig::enable_vectorization: bool
pub numrs2::arrays::broadcasting::BroadcastConfig::memory_optimization: numrs2::arrays::MemoryOptimization
pub numrs2::arrays::broadcasting::BroadcastConfig::parallel_threshold: usize
impl core::default::Default for numrs2::arrays::BroadcastConfig
pub fn numrs2::arrays::BroadcastConfig::default() -> Self
pub struct numrs2::arrays::broadcasting::BroadcastEngine
impl numrs2::arrays::BroadcastEngine
pub fn numrs2::arrays::BroadcastEngine::add<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Add<Output = T>
pub fn numrs2::arrays::BroadcastEngine::add_scalar<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, scalar: T) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Add<Output = T>
pub fn numrs2::arrays::BroadcastEngine::binary_op<T, F>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>, op: F) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T + core::marker::Send + core::marker::Sync
pub fn numrs2::arrays::BroadcastEngine::broadcast_shape(&self, shape1: &numrs2::arrays::Shape, shape2: &numrs2::arrays::Shape) -> numrs2::Result<numrs2::arrays::Shape>
pub fn numrs2::arrays::BroadcastEngine::can_broadcast(&self, shape1: &numrs2::arrays::Shape, shape2: &numrs2::arrays::Shape) -> bool
pub fn numrs2::arrays::BroadcastEngine::divide<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::FloatingPoint + core::marker::Copy + core::ops::arith::Div<Output = T>
pub fn numrs2::arrays::BroadcastEngine::equal<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<bool>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialEq
pub fn numrs2::arrays::BroadcastEngine::greater<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<bool>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastEngine::less<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<bool>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastEngine::logical_and(&self, a: &numrs2::arrays::ArrayView<'_, bool>, b: &numrs2::arrays::ArrayView<'_, bool>) -> numrs2::Result<alloc::vec::Vec<bool>>
pub fn numrs2::arrays::BroadcastEngine::logical_or(&self, a: &numrs2::arrays::ArrayView<'_, bool>, b: &numrs2::arrays::ArrayView<'_, bool>) -> numrs2::Result<alloc::vec::Vec<bool>>
pub fn numrs2::arrays::BroadcastEngine::maximum<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastEngine::minimum<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastEngine::multiply<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Mul<Output = T>
pub fn numrs2::arrays::BroadcastEngine::multiply_scalar<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, scalar: T) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Mul<Output = T>
pub fn numrs2::arrays::BroadcastEngine::new(config: numrs2::arrays::BroadcastConfig) -> Self
pub fn numrs2::arrays::BroadcastEngine::power<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::FloatingPoint + core::marker::Copy
pub fn numrs2::arrays::BroadcastEngine::scalar_op<T, F>(&self, array: &numrs2::arrays::ArrayView<'_, T>, scalar: T, op: F) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::arrays::BroadcastEngine::subtract<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Sub<Output = T>
impl core::default::Default for numrs2::arrays::BroadcastEngine
pub fn numrs2::arrays::BroadcastEngine::default() -> Self
pub struct numrs2::arrays::broadcasting::BroadcastReduction
impl numrs2::arrays::BroadcastReduction
pub fn numrs2::arrays::BroadcastReduction::max<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastReduction::mean<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::FloatingPoint + core::marker::Copy + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T>
pub fn numrs2::arrays::BroadcastReduction::min<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastReduction::new(config: numrs2::arrays::BroadcastConfig) -> Self
pub fn numrs2::arrays::BroadcastReduction::sum<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Add<Output = T>
pub mod numrs2::arrays::enhanced_indexing
pub enum numrs2::arrays::enhanced_indexing::SliceSpec
pub numrs2::arrays::enhanced_indexing::SliceSpec::All
pub numrs2::arrays::enhanced_indexing::SliceSpec::Array(alloc::vec::Vec<usize>)
pub numrs2::arrays::enhanced_indexing::SliceSpec::Ellipsis
pub numrs2::arrays::enhanced_indexing::SliceSpec::Index(usize)
pub numrs2::arrays::enhanced_indexing::SliceSpec::Mask(alloc::vec::Vec<bool>)
pub numrs2::arrays::enhanced_indexing::SliceSpec::NewAxis
pub numrs2::arrays::enhanced_indexing::SliceSpec::Range(numrs2::arrays::RangeSpec)
pub struct numrs2::arrays::enhanced_indexing::BlockSpec
pub numrs2::arrays::enhanced_indexing::BlockSpec::size: alloc::vec::Vec<usize>
pub numrs2::arrays::enhanced_indexing::BlockSpec::start: alloc::vec::Vec<usize>
impl numrs2::arrays::BlockSpec
pub fn numrs2::arrays::BlockSpec::new(start: alloc::vec::Vec<usize>, size: alloc::vec::Vec<usize>) -> Self
pub struct numrs2::arrays::enhanced_indexing::IndexBuilder
impl numrs2::arrays::IndexBuilder
pub fn numrs2::arrays::IndexBuilder::all(self) -> Self
pub fn numrs2::arrays::IndexBuilder::array(self, indices: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::arrays::IndexBuilder::build(self) -> alloc::vec::Vec<numrs2::arrays::SliceSpec>
pub fn numrs2::arrays::IndexBuilder::ellipsis(self) -> Self
pub fn numrs2::arrays::IndexBuilder::index(self, idx: usize) -> Self
pub fn numrs2::arrays::IndexBuilder::mask(self, mask: alloc::vec::Vec<bool>) -> Self
pub fn numrs2::arrays::IndexBuilder::new() -> Self
pub fn numrs2::arrays::IndexBuilder::new_axis(self) -> Self
pub fn numrs2::arrays::IndexBuilder::range(self, start: usize, stop: usize, step: usize) -> Self
pub fn numrs2::arrays::IndexBuilder::slice<R: core::convert::Into<numrs2::arrays::RangeSpec>>(self, range: R) -> Self
impl core::default::Default for numrs2::arrays::IndexBuilder
pub fn numrs2::arrays::IndexBuilder::default() -> Self
pub struct numrs2::arrays::enhanced_indexing::IndexingEngine
impl numrs2::arrays::IndexingEngine
pub fn numrs2::arrays::IndexingEngine::advanced_index<T>(&mut self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[numrs2::arrays::IndexSpec]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::block_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, block_spec: &numrs2::arrays::BlockSpec) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::circular_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[isize]) -> numrs2::Result<T> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::clear_cache(&mut self)
pub fn numrs2::arrays::IndexingEngine::conditional_index<T, F>(&self, array: &numrs2::arrays::ArrayView<'_, T>, predicate: F) -> numrs2::Result<alloc::vec::Vec<(alloc::vec::Vec<usize>, T)>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T) -> bool
pub fn numrs2::arrays::IndexingEngine::coordinate_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, coordinates: &[alloc::vec::Vec<usize>]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::diagonal_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, offset: isize, axis1: core::option::Option<usize>, axis2: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::enhanced_slice<'a, T>(&mut self, array: &numrs2::arrays::ArrayView<'a, T>, slices: &[numrs2::arrays::SliceSpec]) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::IndexingEngine::get_stats(&self) -> &numrs2::arrays::IndexingStats
pub fn numrs2::arrays::IndexingEngine::masked_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, mask: &[bool]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::multidim_slice<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, ranges: &[numrs2::arrays::RangeSpec]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::new() -> Self
impl core::default::Default for numrs2::arrays::IndexingEngine
pub fn numrs2::arrays::IndexingEngine::default() -> Self
pub struct numrs2::arrays::enhanced_indexing::IndexingStats
pub struct numrs2::arrays::enhanced_indexing::RangeSpec
pub numrs2::arrays::enhanced_indexing::RangeSpec::start: usize
pub numrs2::arrays::enhanced_indexing::RangeSpec::step: usize
pub numrs2::arrays::enhanced_indexing::RangeSpec::stop: usize
impl numrs2::arrays::RangeSpec
pub fn numrs2::arrays::RangeSpec::new(start: usize, stop: usize, step: usize) -> Self
impl core::convert::From<core::ops::range::Range<usize>> for numrs2::arrays::RangeSpec
pub fn numrs2::arrays::RangeSpec::from(range: core::ops::range::Range<usize>) -> Self
impl core::convert::From<core::ops::range::RangeFrom<usize>> for numrs2::arrays::RangeSpec
pub fn numrs2::arrays::RangeSpec::from(range: core::ops::range::RangeFrom<usize>) -> Self
impl core::convert::From<core::ops::range::RangeFull> for numrs2::arrays::RangeSpec
pub fn numrs2::arrays::RangeSpec::from(_: core::ops::range::RangeFull) -> Self
impl core::convert::From<core::ops::range::RangeTo<usize>> for numrs2::arrays::RangeSpec
pub fn numrs2::arrays::RangeSpec::from(range: core::ops::range::RangeTo<usize>) -> Self
pub mod numrs2::arrays::fancy_indexing
pub enum numrs2::arrays::fancy_indexing::BooleanCombineOp
pub numrs2::arrays::fancy_indexing::BooleanCombineOp::And
pub numrs2::arrays::fancy_indexing::BooleanCombineOp::Or
pub numrs2::arrays::fancy_indexing::BooleanCombineOp::Xor
pub struct numrs2::arrays::fancy_indexing::FancyIndexConfig
pub numrs2::arrays::fancy_indexing::FancyIndexConfig::enable_bounds_checking: bool
pub numrs2::arrays::fancy_indexing::FancyIndexConfig::enable_index_validation: bool
pub numrs2::arrays::fancy_indexing::FancyIndexConfig::enable_parallel: bool
pub numrs2::arrays::fancy_indexing::FancyIndexConfig::max_temp_memory: usize
impl core::default::Default for numrs2::arrays::FancyIndexConfig
pub fn numrs2::arrays::FancyIndexConfig::default() -> Self
pub struct numrs2::arrays::fancy_indexing::FancyIndexEngine
impl numrs2::arrays::FancyIndexEngine
pub fn numrs2::arrays::FancyIndexEngine::advanced_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[numrs2::arrays::IndexSpec]) -> numrs2::Result<numrs2::arrays::FancyIndexResult<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::choose<T>(&self, choices: &[&numrs2::arrays::ArrayView<'_, T>], index_array: &[usize]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::index_with_arrays<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[alloc::vec::Vec<usize>]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::index_with_boolean<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, mask: &[bool]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::new(config: numrs2::arrays::FancyIndexConfig) -> Self
pub fn numrs2::arrays::FancyIndexEngine::nonzero<T, F>(&self, array: &numrs2::arrays::ArrayView<'_, T>, condition: F) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<usize>>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T) -> bool
pub fn numrs2::arrays::FancyIndexEngine::set_with_arrays<T>(&self, array: &mut [T], array_shape: &numrs2::arrays::Shape, indices: &[alloc::vec::Vec<usize>], values: &[T]) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::set_with_boolean<T>(&self, array: &mut [T], _array_shape: &numrs2::arrays::Shape, mask: &[bool], value: T) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::take<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[usize], axis: usize) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::where_condition<T, F>(&self, array: &numrs2::arrays::ArrayView<'_, T>, condition: F) -> numrs2::Result<alloc::vec::Vec<bool>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T) -> bool
impl core::default::Default for numrs2::arrays::FancyIndexEngine
pub fn numrs2::arrays::FancyIndexEngine::default() -> Self
pub struct numrs2::arrays::fancy_indexing::FancyIndexResult<T>
pub numrs2::arrays::fancy_indexing::FancyIndexResult::data: alloc::vec::Vec<T>
pub numrs2::arrays::fancy_indexing::FancyIndexResult::new_axes: alloc::vec::Vec<usize>
pub numrs2::arrays::fancy_indexing::FancyIndexResult::shape: numrs2::arrays::Shape
impl<T> numrs2::arrays::FancyIndexResult<T>
pub fn numrs2::arrays::FancyIndexResult<T>::to_view(&self) -> numrs2::Result<numrs2::arrays::ArrayView<'_, T>>
pub struct numrs2::arrays::fancy_indexing::SpecializedIndexing
impl numrs2::arrays::SpecializedIndexing
pub fn numrs2::arrays::SpecializedIndexing::index_with_coordinates<T>(array: &numrs2::arrays::ArrayView<'_, T>, coordinates: &[alloc::vec::Vec<usize>]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::SpecializedIndexing::meshgrid_index<T>(array: &numrs2::arrays::ArrayView<'_, T>, grid_indices: &[alloc::vec::Vec<usize>]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::SpecializedIndexing::multi_boolean_index<T>(array: &numrs2::arrays::ArrayView<'_, T>, conditions: &[alloc::vec::Vec<bool>], combine_op: numrs2::arrays::BooleanCombineOp) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub mod numrs2::arrays::shape_manipulation
pub enum numrs2::arrays::shape_manipulation::LayoutPattern
pub numrs2::arrays::shape_manipulation::LayoutPattern::CContiguous
pub numrs2::arrays::shape_manipulation::LayoutPattern::FortranContiguous
pub numrs2::arrays::shape_manipulation::LayoutPattern::Irregular
pub numrs2::arrays::shape_manipulation::LayoutPattern::Regular
pub numrs2::arrays::shape_manipulation::LayoutPattern::UnitStride
pub enum numrs2::arrays::shape_manipulation::MemoryLayout
pub numrs2::arrays::shape_manipulation::MemoryLayout::C
pub numrs2::arrays::shape_manipulation::MemoryLayout::Custom
pub numrs2::arrays::shape_manipulation::MemoryLayout::Fortran
pub numrs2::arrays::shape_manipulation::MemoryLayout::Strided
pub enum numrs2::arrays::shape_manipulation::ViewChainOperation
pub numrs2::arrays::shape_manipulation::ViewChainOperation::ExpandDims(alloc::vec::Vec<usize>)
pub numrs2::arrays::shape_manipulation::ViewChainOperation::MoveAxis(usize, usize)
pub numrs2::arrays::shape_manipulation::ViewChainOperation::Reshape(alloc::vec::Vec<usize>)
pub numrs2::arrays::shape_manipulation::ViewChainOperation::Squeeze(core::option::Option<alloc::vec::Vec<usize>>)
pub numrs2::arrays::shape_manipulation::ViewChainOperation::SwapAxes(usize, usize)
pub numrs2::arrays::shape_manipulation::ViewChainOperation::Transpose(core::option::Option<alloc::vec::Vec<usize>>)
pub enum numrs2::arrays::shape_manipulation::ViewOperation
pub numrs2::arrays::shape_manipulation::ViewOperation::Broadcasting
pub numrs2::arrays::shape_manipulation::ViewOperation::ColumnAccess
pub numrs2::arrays::shape_manipulation::ViewOperation::MatrixMultiply
pub numrs2::arrays::shape_manipulation::ViewOperation::RandomAccess
pub numrs2::arrays::shape_manipulation::ViewOperation::Reduction
pub numrs2::arrays::shape_manipulation::ViewOperation::RowAccess
pub numrs2::arrays::shape_manipulation::ViewOperation::SequentialScan
pub numrs2::arrays::shape_manipulation::ViewOperation::Transpose
pub struct numrs2::arrays::shape_manipulation::LayoutAnalysis
pub numrs2::arrays::shape_manipulation::LayoutAnalysis::efficiency: f64
pub numrs2::arrays::shape_manipulation::LayoutAnalysis::is_c_contiguous: bool
pub numrs2::arrays::shape_manipulation::LayoutAnalysis::is_contiguous: bool
pub numrs2::arrays::shape_manipulation::LayoutAnalysis::is_f_contiguous: bool
pub numrs2::arrays::shape_manipulation::LayoutAnalysis::layout_pattern: numrs2::arrays::LayoutPattern
pub numrs2::arrays::shape_manipulation::LayoutAnalysis::memory_span: usize
pub numrs2::arrays::shape_manipulation::LayoutAnalysis::recommended_layout: numrs2::arrays::MemoryLayout
pub struct numrs2::arrays::shape_manipulation::ShapeEngine
impl numrs2::arrays::ShapeEngine
pub fn numrs2::arrays::ShapeEngine::analyze_layout_efficiency(&self, shape: &[usize], strides: &[usize]) -> numrs2::arrays::LayoutAnalysis
pub fn numrs2::arrays::ShapeEngine::can_reshape(&self, current_shape: &[usize], new_shape: &[usize]) -> bool
pub fn numrs2::arrays::ShapeEngine::compute_strides(&mut self, shape: &[usize], layout: numrs2::arrays::MemoryLayout) -> alloc::vec::Vec<usize>
pub fn numrs2::arrays::ShapeEngine::expand_dims_view<'a, T>(&self, view: &numrs2::arrays::ArrayView<'a, T>, axes: alloc::vec::Vec<usize>) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::ShapeEngine::flip_view<T>(&self, view: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::ShapeEngine::is_broadcastable(&self, source_shape: &[usize], target_shape: &[usize]) -> bool
pub fn numrs2::arrays::ShapeEngine::moveaxis_view<'a, T>(&self, view: &numrs2::arrays::ArrayView<'a, T>, source: usize, destination: usize) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::ShapeEngine::new() -> Self
pub fn numrs2::arrays::ShapeEngine::reshape_view<'a, T>(&self, view: &numrs2::arrays::ArrayView<'a, T>, new_shape: &[usize]) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::ShapeEngine::roll_view<T>(&self, view: &numrs2::arrays::ArrayView<'_, T>, shift: isize, axis: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::ShapeEngine::rot90_view<T>(&self, view: &numrs2::arrays::ArrayView<'_, T>, k: i32, axes: core::option::Option<(usize, usize)>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::ShapeEngine::squeeze_view<'a, T>(&self, view: &numrs2::arrays::ArrayView<'a, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::ShapeEngine::swapaxes_view<'a, T>(&self, view: &numrs2::arrays::ArrayView<'a, T>, axis1: usize, axis2: usize) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::ShapeEngine::transpose_view<'a, T>(&self, view: &numrs2::arrays::ArrayView<'a, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
impl core::default::Default for numrs2::arrays::ShapeEngine
pub fn numrs2::arrays::ShapeEngine::default() -> Self
pub struct numrs2::arrays::shape_manipulation::ViewSystem
impl numrs2::arrays::ViewSystem
pub fn numrs2::arrays::ViewSystem::create_optimized_view<'a, T>(&mut self, data: &'a [T], shape: &[usize], intended_operations: &[numrs2::arrays::ViewOperation]) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::ViewSystem::create_view_chain<'a, T>(&mut self, initial_view: numrs2::arrays::ArrayView<'a, T>, operations: &[numrs2::arrays::ViewChainOperation]) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::ViewSystem::new() -> Self
impl core::default::Default for numrs2::arrays::ViewSystem
pub fn numrs2::arrays::ViewSystem::default() -> Self
pub mod numrs2::arrays::stride_optimization
pub enum numrs2::arrays::stride_optimization::AccessPattern
pub numrs2::arrays::stride_optimization::AccessPattern::Block
pub numrs2::arrays::stride_optimization::AccessPattern::Block::block_size: alloc::vec::Vec<usize>
pub numrs2::arrays::stride_optimization::AccessPattern::Broadcast
pub numrs2::arrays::stride_optimization::AccessPattern::ColumnWise
pub numrs2::arrays::stride_optimization::AccessPattern::Random
pub numrs2::arrays::stride_optimization::AccessPattern::RowWise
pub numrs2::arrays::stride_optimization::AccessPattern::SIMD
pub numrs2::arrays::stride_optimization::AccessPattern::SIMD::vector_width: usize
pub numrs2::arrays::stride_optimization::AccessPattern::Sequential
pub numrs2::arrays::stride_optimization::AccessPattern::Tiled
pub numrs2::arrays::stride_optimization::AccessPattern::Tiled::tile_size: alloc::vec::Vec<usize>
pub enum numrs2::arrays::stride_optimization::StridePattern
pub numrs2::arrays::stride_optimization::StridePattern::CContiguous
pub numrs2::arrays::stride_optimization::StridePattern::Empty
pub numrs2::arrays::stride_optimization::StridePattern::FortranContiguous
pub numrs2::arrays::stride_optimization::StridePattern::Irregular
pub numrs2::arrays::stride_optimization::StridePattern::OneDimensional
pub numrs2::arrays::stride_optimization::StridePattern::PowerOfTwo
pub numrs2::arrays::stride_optimization::StridePattern::UnitStride
pub enum numrs2::arrays::stride_optimization::TargetArchitecture
pub numrs2::arrays::stride_optimization::TargetArchitecture::ArmNeon
pub numrs2::arrays::stride_optimization::TargetArchitecture::Generic
pub numrs2::arrays::stride_optimization::TargetArchitecture::X86_64Avx2
pub numrs2::arrays::stride_optimization::TargetArchitecture::X86_64Avx512
pub struct numrs2::arrays::stride_optimization::OptimizationHints
pub numrs2::arrays::stride_optimization::OptimizationHints::alignment: usize
pub numrs2::arrays::stride_optimization::OptimizationHints::cache_line_size: usize
pub numrs2::arrays::stride_optimization::OptimizationHints::l1_cache_size: usize
pub numrs2::arrays::stride_optimization::OptimizationHints::l2_cache_size: usize
pub numrs2::arrays::stride_optimization::OptimizationHints::optimize_bandwidth: bool
pub numrs2::arrays::stride_optimization::OptimizationHints::optimize_locality: bool
pub numrs2::arrays::stride_optimization::OptimizationHints::simd_width: usize
impl core::default::Default for numrs2::arrays::OptimizationHints
pub fn numrs2::arrays::OptimizationHints::default() -> Self
pub struct numrs2::arrays::stride_optimization::StrideAnalysis
pub numrs2::arrays::stride_optimization::StrideAnalysis::bandwidth_efficiency: f64
pub numrs2::arrays::stride_optimization::StrideAnalysis::cache_utilization: f64
pub numrs2::arrays::stride_optimization::StrideAnalysis::cache_utilizations: alloc::vec::Vec<f64>
pub numrs2::arrays::stride_optimization::StrideAnalysis::is_optimal: bool
pub numrs2::arrays::stride_optimization::StrideAnalysis::memory_span: usize
pub numrs2::arrays::stride_optimization::StrideAnalysis::pattern: numrs2::arrays::StridePattern
pub numrs2::arrays::stride_optimization::StrideAnalysis::simd_efficiency: f64
impl core::default::Default for numrs2::arrays::StrideAnalysis
pub fn numrs2::arrays::StrideAnalysis::default() -> Self
pub struct numrs2::arrays::stride_optimization::StrideCalculator
impl numrs2::arrays::StrideCalculator
pub fn numrs2::arrays::StrideCalculator::analyze_stride_efficiency(&self, shape: &[usize], strides: &[usize]) -> numrs2::arrays::StrideAnalysis
pub fn numrs2::arrays::StrideCalculator::clear_cache(&mut self)
pub fn numrs2::arrays::StrideCalculator::compute_optimal_strides(&mut self, shape: &[usize], access_pattern: numrs2::arrays::AccessPattern) -> alloc::vec::Vec<usize>
pub fn numrs2::arrays::StrideCalculator::get_cache_stats(&self) -> (usize, usize)
pub fn numrs2::arrays::StrideCalculator::new(hints: numrs2::arrays::OptimizationHints) -> Self
pub fn numrs2::arrays::StrideCalculator::optimize_for_hardware(&mut self, shape: &[usize], access_pattern: numrs2::arrays::AccessPattern, target_arch: numrs2::arrays::TargetArchitecture) -> alloc::vec::Vec<usize>
impl core::default::Default for numrs2::arrays::StrideCalculator
pub fn numrs2::arrays::StrideCalculator::default() -> Self
pub enum numrs2::arrays::AccessPattern
pub numrs2::arrays::AccessPattern::Block
pub numrs2::arrays::AccessPattern::Block::block_size: alloc::vec::Vec<usize>
pub numrs2::arrays::AccessPattern::Broadcast
pub numrs2::arrays::AccessPattern::ColumnWise
pub numrs2::arrays::AccessPattern::Random
pub numrs2::arrays::AccessPattern::RowWise
pub numrs2::arrays::AccessPattern::SIMD
pub numrs2::arrays::AccessPattern::SIMD::vector_width: usize
pub numrs2::arrays::AccessPattern::Sequential
pub numrs2::arrays::AccessPattern::Tiled
pub numrs2::arrays::AccessPattern::Tiled::tile_size: alloc::vec::Vec<usize>
pub enum numrs2::arrays::BooleanCombineOp
pub numrs2::arrays::BooleanCombineOp::And
pub numrs2::arrays::BooleanCombineOp::Or
pub numrs2::arrays::BooleanCombineOp::Xor
pub enum numrs2::arrays::IndexSpec
pub numrs2::arrays::IndexSpec::All
pub numrs2::arrays::IndexSpec::Array(alloc::vec::Vec<usize>)
pub numrs2::arrays::IndexSpec::BoolMask(alloc::vec::Vec<bool>)
pub numrs2::arrays::IndexSpec::Ellipsis
pub numrs2::arrays::IndexSpec::Index(isize)
pub numrs2::arrays::IndexSpec::Indices(alloc::vec::Vec<usize>)
pub numrs2::arrays::IndexSpec::Int(isize)
pub numrs2::arrays::IndexSpec::Mask(alloc::vec::Vec<bool>)
pub numrs2::arrays::IndexSpec::NewAxis
pub numrs2::arrays::IndexSpec::Slice(core::option::Option<isize>, core::option::Option<isize>, core::option::Option<isize>)
impl numrs2::arrays::IndexSpec
pub fn numrs2::arrays::IndexSpec::from_range<R>(range: R, _axis_size: usize) -> Self where R: core::convert::Into<numrs2::arrays::SliceInfo>
pub fn numrs2::arrays::IndexSpec::resolve(&self, axis_size: usize) -> numrs2::Result<numrs2::arrays::ResolvedIndex>
pub enum numrs2::arrays::LayoutPattern
pub numrs2::arrays::LayoutPattern::CContiguous
pub numrs2::arrays::LayoutPattern::FortranContiguous
pub numrs2::arrays::LayoutPattern::Irregular
pub numrs2::arrays::LayoutPattern::Regular
pub numrs2::arrays::LayoutPattern::UnitStride
pub enum numrs2::arrays::MemoryLayout
pub numrs2::arrays::MemoryLayout::C
pub numrs2::arrays::MemoryLayout::Custom
pub numrs2::arrays::MemoryLayout::Fortran
pub numrs2::arrays::MemoryLayout::Strided
pub enum numrs2::arrays::MemoryOptimization
pub numrs2::arrays::MemoryOptimization::Balanced
pub numrs2::arrays::MemoryOptimization::Memory
pub numrs2::arrays::MemoryOptimization::Performance
pub enum numrs2::arrays::ResolvedIndex
pub numrs2::arrays::ResolvedIndex::Multiple(alloc::vec::Vec<usize>)
pub numrs2::arrays::ResolvedIndex::Single(usize)
pub enum numrs2::arrays::SliceSpec
pub numrs2::arrays::SliceSpec::All
pub numrs2::arrays::SliceSpec::Array(alloc::vec::Vec<usize>)
pub numrs2::arrays::SliceSpec::Ellipsis
pub numrs2::arrays::SliceSpec::Index(usize)
pub numrs2::arrays::SliceSpec::Mask(alloc::vec::Vec<bool>)
pub numrs2::arrays::SliceSpec::NewAxis
pub numrs2::arrays::SliceSpec::Range(numrs2::arrays::RangeSpec)
pub enum numrs2::arrays::StridePattern
pub numrs2::arrays::StridePattern::CContiguous
pub numrs2::arrays::StridePattern::Empty
pub numrs2::arrays::StridePattern::FortranContiguous
pub numrs2::arrays::StridePattern::Irregular
pub numrs2::arrays::StridePattern::OneDimensional
pub numrs2::arrays::StridePattern::PowerOfTwo
pub numrs2::arrays::StridePattern::UnitStride
pub enum numrs2::arrays::TargetArchitecture
pub numrs2::arrays::TargetArchitecture::ArmNeon
pub numrs2::arrays::TargetArchitecture::Generic
pub numrs2::arrays::TargetArchitecture::X86_64Avx2
pub numrs2::arrays::TargetArchitecture::X86_64Avx512
pub enum numrs2::arrays::ViewChainOperation
pub numrs2::arrays::ViewChainOperation::ExpandDims(alloc::vec::Vec<usize>)
pub numrs2::arrays::ViewChainOperation::MoveAxis(usize, usize)
pub numrs2::arrays::ViewChainOperation::Reshape(alloc::vec::Vec<usize>)
pub numrs2::arrays::ViewChainOperation::Squeeze(core::option::Option<alloc::vec::Vec<usize>>)
pub numrs2::arrays::ViewChainOperation::SwapAxes(usize, usize)
pub numrs2::arrays::ViewChainOperation::Transpose(core::option::Option<alloc::vec::Vec<usize>>)
pub enum numrs2::arrays::ViewOperation
pub numrs2::arrays::ViewOperation::Broadcasting
pub numrs2::arrays::ViewOperation::ColumnAccess
pub numrs2::arrays::ViewOperation::MatrixMultiply
pub numrs2::arrays::ViewOperation::RandomAccess
pub numrs2::arrays::ViewOperation::Reduction
pub numrs2::arrays::ViewOperation::RowAccess
pub numrs2::arrays::ViewOperation::SequentialScan
pub numrs2::arrays::ViewOperation::Transpose
pub struct numrs2::arrays::ArrayView<'a, T>
impl<'a, T> numrs2::arrays::ArrayView<'a, T>
pub fn numrs2::arrays::ArrayView<'a, T>::from_data(data: &'a [T], shape: numrs2::arrays::Shape) -> numrs2::Result<Self>
pub fn numrs2::arrays::ArrayView<'a, T>::get(&self, indices: &[usize]) -> numrs2::Result<&T>
pub fn numrs2::arrays::ArrayView<'a, T>::is_c_contiguous(&self) -> bool
pub fn numrs2::arrays::ArrayView<'a, T>::is_f_contiguous(&self) -> bool
pub fn numrs2::arrays::ArrayView<'a, T>::new(data: &'a [T], shape: numrs2::arrays::Shape, strides: alloc::vec::Vec<usize>, offset: usize) -> numrs2::Result<Self>
pub fn numrs2::arrays::ArrayView<'a, T>::reshape(&self, new_shape: numrs2::arrays::Shape) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>>
pub fn numrs2::arrays::ArrayView<'a, T>::shape(&self) -> &numrs2::arrays::Shape
pub fn numrs2::arrays::ArrayView<'a, T>::slice(&self, indices: &[numrs2::arrays::IndexSpec]) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>>
pub fn numrs2::arrays::ArrayView<'a, T>::strides(&self) -> &[usize]
pub fn numrs2::arrays::ArrayView<'a, T>::transpose(&self, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>>
impl<T: core::clone::Clone> numrs2::arrays::ArrayView<'_, T>
pub fn numrs2::arrays::ArrayView<'_, T>::to_vec(&self) -> alloc::vec::Vec<T>
pub struct numrs2::arrays::ArrayViewIterator<T>
impl<T> core::iter::traits::iterator::Iterator for numrs2::arrays::ArrayViewIterator<T>
pub type numrs2::arrays::ArrayViewIterator<T>::Item = *const T
pub fn numrs2::arrays::ArrayViewIterator<T>::next(&mut self) -> core::option::Option<Self::Item>
pub struct numrs2::arrays::BlockSpec
pub numrs2::arrays::BlockSpec::size: alloc::vec::Vec<usize>
pub numrs2::arrays::BlockSpec::start: alloc::vec::Vec<usize>
impl numrs2::arrays::BlockSpec
pub fn numrs2::arrays::BlockSpec::new(start: alloc::vec::Vec<usize>, size: alloc::vec::Vec<usize>) -> Self
pub struct numrs2::arrays::BroadcastConfig
pub numrs2::arrays::BroadcastConfig::enable_parallel: bool
pub numrs2::arrays::BroadcastConfig::enable_vectorization: bool
pub numrs2::arrays::BroadcastConfig::memory_optimization: numrs2::arrays::MemoryOptimization
pub numrs2::arrays::BroadcastConfig::parallel_threshold: usize
impl core::default::Default for numrs2::arrays::BroadcastConfig
pub fn numrs2::arrays::BroadcastConfig::default() -> Self
pub struct numrs2::arrays::BroadcastEngine
impl numrs2::arrays::BroadcastEngine
pub fn numrs2::arrays::BroadcastEngine::add<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Add<Output = T>
pub fn numrs2::arrays::BroadcastEngine::add_scalar<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, scalar: T) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Add<Output = T>
pub fn numrs2::arrays::BroadcastEngine::binary_op<T, F>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>, op: F) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T + core::marker::Send + core::marker::Sync
pub fn numrs2::arrays::BroadcastEngine::broadcast_shape(&self, shape1: &numrs2::arrays::Shape, shape2: &numrs2::arrays::Shape) -> numrs2::Result<numrs2::arrays::Shape>
pub fn numrs2::arrays::BroadcastEngine::can_broadcast(&self, shape1: &numrs2::arrays::Shape, shape2: &numrs2::arrays::Shape) -> bool
pub fn numrs2::arrays::BroadcastEngine::divide<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::FloatingPoint + core::marker::Copy + core::ops::arith::Div<Output = T>
pub fn numrs2::arrays::BroadcastEngine::equal<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<bool>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialEq
pub fn numrs2::arrays::BroadcastEngine::greater<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<bool>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastEngine::less<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<bool>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastEngine::logical_and(&self, a: &numrs2::arrays::ArrayView<'_, bool>, b: &numrs2::arrays::ArrayView<'_, bool>) -> numrs2::Result<alloc::vec::Vec<bool>>
pub fn numrs2::arrays::BroadcastEngine::logical_or(&self, a: &numrs2::arrays::ArrayView<'_, bool>, b: &numrs2::arrays::ArrayView<'_, bool>) -> numrs2::Result<alloc::vec::Vec<bool>>
pub fn numrs2::arrays::BroadcastEngine::maximum<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastEngine::minimum<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastEngine::multiply<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Mul<Output = T>
pub fn numrs2::arrays::BroadcastEngine::multiply_scalar<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, scalar: T) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Mul<Output = T>
pub fn numrs2::arrays::BroadcastEngine::new(config: numrs2::arrays::BroadcastConfig) -> Self
pub fn numrs2::arrays::BroadcastEngine::power<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::FloatingPoint + core::marker::Copy
pub fn numrs2::arrays::BroadcastEngine::scalar_op<T, F>(&self, array: &numrs2::arrays::ArrayView<'_, T>, scalar: T, op: F) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::arrays::BroadcastEngine::subtract<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Sub<Output = T>
impl core::default::Default for numrs2::arrays::BroadcastEngine
pub fn numrs2::arrays::BroadcastEngine::default() -> Self
pub struct numrs2::arrays::BroadcastOp
impl numrs2::arrays::BroadcastOp
pub fn numrs2::arrays::BroadcastOp::binary_op<T, F>(a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>, output: &mut [T], op: F) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::arrays::BroadcastOp::unary_op<T, F>(input: &numrs2::arrays::ArrayView<'_, T>, output: &mut [T], target_shape: &numrs2::arrays::Shape, op: F) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T) -> T
pub struct numrs2::arrays::BroadcastReduction
impl numrs2::arrays::BroadcastReduction
pub fn numrs2::arrays::BroadcastReduction::max<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastReduction::mean<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::FloatingPoint + core::marker::Copy + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T>
pub fn numrs2::arrays::BroadcastReduction::min<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastReduction::new(config: numrs2::arrays::BroadcastConfig) -> Self
pub fn numrs2::arrays::BroadcastReduction::sum<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Add<Output = T>
pub struct numrs2::arrays::FancyIndexConfig
pub numrs2::arrays::FancyIndexConfig::enable_bounds_checking: bool
pub numrs2::arrays::FancyIndexConfig::enable_index_validation: bool
pub numrs2::arrays::FancyIndexConfig::enable_parallel: bool
pub numrs2::arrays::FancyIndexConfig::max_temp_memory: usize
impl core::default::Default for numrs2::arrays::FancyIndexConfig
pub fn numrs2::arrays::FancyIndexConfig::default() -> Self
pub struct numrs2::arrays::FancyIndexEngine
impl numrs2::arrays::FancyIndexEngine
pub fn numrs2::arrays::FancyIndexEngine::advanced_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[numrs2::arrays::IndexSpec]) -> numrs2::Result<numrs2::arrays::FancyIndexResult<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::choose<T>(&self, choices: &[&numrs2::arrays::ArrayView<'_, T>], index_array: &[usize]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::index_with_arrays<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[alloc::vec::Vec<usize>]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::index_with_boolean<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, mask: &[bool]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::new(config: numrs2::arrays::FancyIndexConfig) -> Self
pub fn numrs2::arrays::FancyIndexEngine::nonzero<T, F>(&self, array: &numrs2::arrays::ArrayView<'_, T>, condition: F) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<usize>>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T) -> bool
pub fn numrs2::arrays::FancyIndexEngine::set_with_arrays<T>(&self, array: &mut [T], array_shape: &numrs2::arrays::Shape, indices: &[alloc::vec::Vec<usize>], values: &[T]) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::set_with_boolean<T>(&self, array: &mut [T], _array_shape: &numrs2::arrays::Shape, mask: &[bool], value: T) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::take<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[usize], axis: usize) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::where_condition<T, F>(&self, array: &numrs2::arrays::ArrayView<'_, T>, condition: F) -> numrs2::Result<alloc::vec::Vec<bool>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T) -> bool
impl core::default::Default for numrs2::arrays::FancyIndexEngine
pub fn numrs2::arrays::FancyIndexEngine::default() -> Self
pub struct numrs2::arrays::FancyIndexResult<T>
pub numrs2::arrays::FancyIndexResult::data: alloc::vec::Vec<T>
pub numrs2::arrays::FancyIndexResult::new_axes: alloc::vec::Vec<usize>
pub numrs2::arrays::FancyIndexResult::shape: numrs2::arrays::Shape
impl<T> numrs2::arrays::FancyIndexResult<T>
pub fn numrs2::arrays::FancyIndexResult<T>::to_view(&self) -> numrs2::Result<numrs2::arrays::ArrayView<'_, T>>
pub struct numrs2::arrays::IndexBuilder
impl numrs2::arrays::IndexBuilder
pub fn numrs2::arrays::IndexBuilder::all(self) -> Self
pub fn numrs2::arrays::IndexBuilder::array(self, indices: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::arrays::IndexBuilder::build(self) -> alloc::vec::Vec<numrs2::arrays::SliceSpec>
pub fn numrs2::arrays::IndexBuilder::ellipsis(self) -> Self
pub fn numrs2::arrays::IndexBuilder::index(self, idx: usize) -> Self
pub fn numrs2::arrays::IndexBuilder::mask(self, mask: alloc::vec::Vec<bool>) -> Self
pub fn numrs2::arrays::IndexBuilder::new() -> Self
pub fn numrs2::arrays::IndexBuilder::new_axis(self) -> Self
pub fn numrs2::arrays::IndexBuilder::range(self, start: usize, stop: usize, step: usize) -> Self
pub fn numrs2::arrays::IndexBuilder::slice<R: core::convert::Into<numrs2::arrays::RangeSpec>>(self, range: R) -> Self
impl core::default::Default for numrs2::arrays::IndexBuilder
pub fn numrs2::arrays::IndexBuilder::default() -> Self
pub struct numrs2::arrays::IndexingEngine
impl numrs2::arrays::IndexingEngine
pub fn numrs2::arrays::IndexingEngine::advanced_index<T>(&mut self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[numrs2::arrays::IndexSpec]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::block_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, block_spec: &numrs2::arrays::BlockSpec) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::circular_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[isize]) -> numrs2::Result<T> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::clear_cache(&mut self)
pub fn numrs2::arrays::IndexingEngine::conditional_index<T, F>(&self, array: &numrs2::arrays::ArrayView<'_, T>, predicate: F) -> numrs2::Result<alloc::vec::Vec<(alloc::vec::Vec<usize>, T)>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T) -> bool
pub fn numrs2::arrays::IndexingEngine::coordinate_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, coordinates: &[alloc::vec::Vec<usize>]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::diagonal_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, offset: isize, axis1: core::option::Option<usize>, axis2: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::enhanced_slice<'a, T>(&mut self, array: &numrs2::arrays::ArrayView<'a, T>, slices: &[numrs2::arrays::SliceSpec]) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::IndexingEngine::get_stats(&self) -> &numrs2::arrays::IndexingStats
pub fn numrs2::arrays::IndexingEngine::masked_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, mask: &[bool]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::multidim_slice<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, ranges: &[numrs2::arrays::RangeSpec]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::IndexingEngine::new() -> Self
impl core::default::Default for numrs2::arrays::IndexingEngine
pub fn numrs2::arrays::IndexingEngine::default() -> Self
pub struct numrs2::arrays::IndexingStats
pub struct numrs2::arrays::LayoutAnalysis
pub numrs2::arrays::LayoutAnalysis::efficiency: f64
pub numrs2::arrays::LayoutAnalysis::is_c_contiguous: bool
pub numrs2::arrays::LayoutAnalysis::is_contiguous: bool
pub numrs2::arrays::LayoutAnalysis::is_f_contiguous: bool
pub numrs2::arrays::LayoutAnalysis::layout_pattern: numrs2::arrays::LayoutPattern
pub numrs2::arrays::LayoutAnalysis::memory_span: usize
pub numrs2::arrays::LayoutAnalysis::recommended_layout: numrs2::arrays::MemoryLayout
pub struct numrs2::arrays::OptimizationHints
pub numrs2::arrays::OptimizationHints::alignment: usize
pub numrs2::arrays::OptimizationHints::cache_line_size: usize
pub numrs2::arrays::OptimizationHints::l1_cache_size: usize
pub numrs2::arrays::OptimizationHints::l2_cache_size: usize
pub numrs2::arrays::OptimizationHints::optimize_bandwidth: bool
pub numrs2::arrays::OptimizationHints::optimize_locality: bool
pub numrs2::arrays::OptimizationHints::simd_width: usize
impl core::default::Default for numrs2::arrays::OptimizationHints
pub fn numrs2::arrays::OptimizationHints::default() -> Self
pub struct numrs2::arrays::RangeSpec
pub numrs2::arrays::RangeSpec::start: usize
pub numrs2::arrays::RangeSpec::step: usize
pub numrs2::arrays::RangeSpec::stop: usize
impl numrs2::arrays::RangeSpec
pub fn numrs2::arrays::RangeSpec::new(start: usize, stop: usize, step: usize) -> Self
impl core::convert::From<core::ops::range::Range<usize>> for numrs2::arrays::RangeSpec
pub fn numrs2::arrays::RangeSpec::from(range: core::ops::range::Range<usize>) -> Self
impl core::convert::From<core::ops::range::RangeFrom<usize>> for numrs2::arrays::RangeSpec
pub fn numrs2::arrays::RangeSpec::from(range: core::ops::range::RangeFrom<usize>) -> Self
impl core::convert::From<core::ops::range::RangeFull> for numrs2::arrays::RangeSpec
pub fn numrs2::arrays::RangeSpec::from(_: core::ops::range::RangeFull) -> Self
impl core::convert::From<core::ops::range::RangeTo<usize>> for numrs2::arrays::RangeSpec
pub fn numrs2::arrays::RangeSpec::from(range: core::ops::range::RangeTo<usize>) -> Self
pub struct numrs2::arrays::Shape
pub numrs2::arrays::Shape::dims: alloc::vec::Vec<usize>
impl numrs2::arrays::Shape
pub fn numrs2::arrays::Shape::broadcast_with(&self, other: &numrs2::arrays::Shape) -> numrs2::Result<numrs2::arrays::Shape>
pub fn numrs2::arrays::Shape::c_strides(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::arrays::Shape::f_strides(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::arrays::Shape::from_1d(size: usize) -> Self
pub fn numrs2::arrays::Shape::from_2d(rows: usize, cols: usize) -> Self
pub fn numrs2::arrays::Shape::is_broadcastable_with(&self, other: &numrs2::arrays::Shape) -> bool
pub fn numrs2::arrays::Shape::ndim(&self) -> usize
pub fn numrs2::arrays::Shape::new(dims: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::arrays::Shape::reshape(&self, new_dims: alloc::vec::Vec<usize>) -> numrs2::Result<numrs2::arrays::Shape>
pub fn numrs2::arrays::Shape::size(&self) -> usize
pub fn numrs2::arrays::Shape::transpose(&self, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<numrs2::arrays::Shape>
pub struct numrs2::arrays::ShapeEngine
impl numrs2::arrays::ShapeEngine
pub fn numrs2::arrays::ShapeEngine::analyze_layout_efficiency(&self, shape: &[usize], strides: &[usize]) -> numrs2::arrays::LayoutAnalysis
pub fn numrs2::arrays::ShapeEngine::can_reshape(&self, current_shape: &[usize], new_shape: &[usize]) -> bool
pub fn numrs2::arrays::ShapeEngine::compute_strides(&mut self, shape: &[usize], layout: numrs2::arrays::MemoryLayout) -> alloc::vec::Vec<usize>
pub fn numrs2::arrays::ShapeEngine::expand_dims_view<'a, T>(&self, view: &numrs2::arrays::ArrayView<'a, T>, axes: alloc::vec::Vec<usize>) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::ShapeEngine::flip_view<T>(&self, view: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::ShapeEngine::is_broadcastable(&self, source_shape: &[usize], target_shape: &[usize]) -> bool
pub fn numrs2::arrays::ShapeEngine::moveaxis_view<'a, T>(&self, view: &numrs2::arrays::ArrayView<'a, T>, source: usize, destination: usize) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::ShapeEngine::new() -> Self
pub fn numrs2::arrays::ShapeEngine::reshape_view<'a, T>(&self, view: &numrs2::arrays::ArrayView<'a, T>, new_shape: &[usize]) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::ShapeEngine::roll_view<T>(&self, view: &numrs2::arrays::ArrayView<'_, T>, shift: isize, axis: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::ShapeEngine::rot90_view<T>(&self, view: &numrs2::arrays::ArrayView<'_, T>, k: i32, axes: core::option::Option<(usize, usize)>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::ShapeEngine::squeeze_view<'a, T>(&self, view: &numrs2::arrays::ArrayView<'a, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::ShapeEngine::swapaxes_view<'a, T>(&self, view: &numrs2::arrays::ArrayView<'a, T>, axis1: usize, axis2: usize) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::ShapeEngine::transpose_view<'a, T>(&self, view: &numrs2::arrays::ArrayView<'a, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
impl core::default::Default for numrs2::arrays::ShapeEngine
pub fn numrs2::arrays::ShapeEngine::default() -> Self
pub struct numrs2::arrays::SliceInfo
pub numrs2::arrays::SliceInfo::start: core::option::Option<isize>
pub numrs2::arrays::SliceInfo::step: core::option::Option<isize>
pub numrs2::arrays::SliceInfo::stop: core::option::Option<isize>
impl core::convert::From<core::ops::range::Range<usize>> for numrs2::arrays::SliceInfo
pub fn numrs2::arrays::SliceInfo::from(range: core::ops::range::Range<usize>) -> Self
impl core::convert::From<core::ops::range::RangeFrom<usize>> for numrs2::arrays::SliceInfo
pub fn numrs2::arrays::SliceInfo::from(range: core::ops::range::RangeFrom<usize>) -> Self
impl core::convert::From<core::ops::range::RangeFull> for numrs2::arrays::SliceInfo
pub fn numrs2::arrays::SliceInfo::from(_: core::ops::range::RangeFull) -> Self
impl core::convert::From<core::ops::range::RangeInclusive<usize>> for numrs2::arrays::SliceInfo
pub fn numrs2::arrays::SliceInfo::from(range: core::ops::range::RangeInclusive<usize>) -> Self
impl core::convert::From<core::ops::range::RangeTo<usize>> for numrs2::arrays::SliceInfo
pub fn numrs2::arrays::SliceInfo::from(range: core::ops::range::RangeTo<usize>) -> Self
impl core::convert::From<core::ops::range::RangeToInclusive<usize>> for numrs2::arrays::SliceInfo
pub fn numrs2::arrays::SliceInfo::from(range: core::ops::range::RangeToInclusive<usize>) -> Self
pub struct numrs2::arrays::SpecializedIndexing
impl numrs2::arrays::SpecializedIndexing
pub fn numrs2::arrays::SpecializedIndexing::index_with_coordinates<T>(array: &numrs2::arrays::ArrayView<'_, T>, coordinates: &[alloc::vec::Vec<usize>]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::SpecializedIndexing::meshgrid_index<T>(array: &numrs2::arrays::ArrayView<'_, T>, grid_indices: &[alloc::vec::Vec<usize>]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::SpecializedIndexing::multi_boolean_index<T>(array: &numrs2::arrays::ArrayView<'_, T>, conditions: &[alloc::vec::Vec<bool>], combine_op: numrs2::arrays::BooleanCombineOp) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub struct numrs2::arrays::StrideAnalysis
pub numrs2::arrays::StrideAnalysis::bandwidth_efficiency: f64
pub numrs2::arrays::StrideAnalysis::cache_utilization: f64
pub numrs2::arrays::StrideAnalysis::cache_utilizations: alloc::vec::Vec<f64>
pub numrs2::arrays::StrideAnalysis::is_optimal: bool
pub numrs2::arrays::StrideAnalysis::memory_span: usize
pub numrs2::arrays::StrideAnalysis::pattern: numrs2::arrays::StridePattern
pub numrs2::arrays::StrideAnalysis::simd_efficiency: f64
impl core::default::Default for numrs2::arrays::StrideAnalysis
pub fn numrs2::arrays::StrideAnalysis::default() -> Self
pub struct numrs2::arrays::StrideCalculator
impl numrs2::arrays::StrideCalculator
pub fn numrs2::arrays::StrideCalculator::analyze_stride_efficiency(&self, shape: &[usize], strides: &[usize]) -> numrs2::arrays::StrideAnalysis
pub fn numrs2::arrays::StrideCalculator::clear_cache(&mut self)
pub fn numrs2::arrays::StrideCalculator::compute_optimal_strides(&mut self, shape: &[usize], access_pattern: numrs2::arrays::AccessPattern) -> alloc::vec::Vec<usize>
pub fn numrs2::arrays::StrideCalculator::get_cache_stats(&self) -> (usize, usize)
pub fn numrs2::arrays::StrideCalculator::new(hints: numrs2::arrays::OptimizationHints) -> Self
pub fn numrs2::arrays::StrideCalculator::optimize_for_hardware(&mut self, shape: &[usize], access_pattern: numrs2::arrays::AccessPattern, target_arch: numrs2::arrays::TargetArchitecture) -> alloc::vec::Vec<usize>
impl core::default::Default for numrs2::arrays::StrideCalculator
pub fn numrs2::arrays::StrideCalculator::default() -> Self
pub struct numrs2::arrays::ViewSystem
impl numrs2::arrays::ViewSystem
pub fn numrs2::arrays::ViewSystem::create_optimized_view<'a, T>(&mut self, data: &'a [T], shape: &[usize], intended_operations: &[numrs2::arrays::ViewOperation]) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement
pub fn numrs2::arrays::ViewSystem::create_view_chain<'a, T>(&mut self, initial_view: numrs2::arrays::ArrayView<'a, T>, operations: &[numrs2::arrays::ViewChainOperation]) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::ViewSystem::new() -> Self
impl core::default::Default for numrs2::arrays::ViewSystem
pub fn numrs2::arrays::ViewSystem::default() -> Self
pub mod numrs2::autodiff
pub struct numrs2::autodiff::Dual<T>
impl<T: num_traits::float::Float> numrs2::autodiff::Dual<T>
pub fn numrs2::autodiff::Dual<T>::abs(&self) -> Self
pub fn numrs2::autodiff::Dual<T>::constant(value: T) -> Self
pub fn numrs2::autodiff::Dual<T>::cos(&self) -> Self
pub fn numrs2::autodiff::Dual<T>::cosh(&self) -> Self
pub fn numrs2::autodiff::Dual<T>::deriv(&self) -> T
pub fn numrs2::autodiff::Dual<T>::exp(&self) -> Self
pub fn numrs2::autodiff::Dual<T>::ln(&self) -> Self
pub fn numrs2::autodiff::Dual<T>::new(value: T, deriv: T) -> Self
pub fn numrs2::autodiff::Dual<T>::pow(&self, n: T) -> Self
pub fn numrs2::autodiff::Dual<T>::relu(&self) -> Self
pub fn numrs2::autodiff::Dual<T>::sigmoid(&self) -> Self
pub fn numrs2::autodiff::Dual<T>::sin(&self) -> Self
pub fn numrs2::autodiff::Dual<T>::sinh(&self) -> Self
pub fn numrs2::autodiff::Dual<T>::sqrt(&self) -> Self
pub fn numrs2::autodiff::Dual<T>::tan(&self) -> Self
pub fn numrs2::autodiff::Dual<T>::tanh(&self) -> Self
pub fn numrs2::autodiff::Dual<T>::value(&self) -> T
pub fn numrs2::autodiff::Dual<T>::variable(value: T) -> Self
impl<T: num_traits::float::Float + core::fmt::Display> core::fmt::Display for numrs2::autodiff::Dual<T>
pub fn numrs2::autodiff::Dual<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: num_traits::float::Float> core::ops::arith::Add for numrs2::autodiff::Dual<T>
pub type numrs2::autodiff::Dual<T>::Output = numrs2::autodiff::Dual<T>
pub fn numrs2::autodiff::Dual<T>::add(self, rhs: Self) -> Self::Output
impl<T: num_traits::float::Float> core::ops::arith::Div for numrs2::autodiff::Dual<T>
pub type numrs2::autodiff::Dual<T>::Output = numrs2::autodiff::Dual<T>
pub fn numrs2::autodiff::Dual<T>::div(self, rhs: Self) -> Self::Output
impl<T: num_traits::float::Float> core::ops::arith::Mul for numrs2::autodiff::Dual<T>
pub type numrs2::autodiff::Dual<T>::Output = numrs2::autodiff::Dual<T>
pub fn numrs2::autodiff::Dual<T>::mul(self, rhs: Self) -> Self::Output
impl<T: num_traits::float::Float> core::ops::arith::Neg for numrs2::autodiff::Dual<T>
pub type numrs2::autodiff::Dual<T>::Output = numrs2::autodiff::Dual<T>
pub fn numrs2::autodiff::Dual<T>::neg(self) -> Self::Output
impl<T: num_traits::float::Float> core::ops::arith::Sub for numrs2::autodiff::Dual<T>
pub type numrs2::autodiff::Dual<T>::Output = numrs2::autodiff::Dual<T>
pub fn numrs2::autodiff::Dual<T>::sub(self, rhs: Self) -> Self::Output
pub struct numrs2::autodiff::Tape<T>
impl<T: num_traits::float::Float> numrs2::autodiff::Tape<T>
pub fn numrs2::autodiff::Tape<T>::add(&mut self, x: numrs2::autodiff::Var, y: numrs2::autodiff::Var) -> numrs2::autodiff::Var
pub fn numrs2::autodiff::Tape<T>::backward(&mut self, output: numrs2::autodiff::Var)
pub fn numrs2::autodiff::Tape<T>::cos(&mut self, x: numrs2::autodiff::Var) -> numrs2::autodiff::Var
pub fn numrs2::autodiff::Tape<T>::div(&mut self, x: numrs2::autodiff::Var, y: numrs2::autodiff::Var) -> numrs2::autodiff::Var
pub fn numrs2::autodiff::Tape<T>::exp(&mut self, x: numrs2::autodiff::Var) -> numrs2::autodiff::Var
pub fn numrs2::autodiff::Tape<T>::grad(&self, var: numrs2::autodiff::Var) -> T
pub fn numrs2::autodiff::Tape<T>::is_empty(&self) -> bool
pub fn numrs2::autodiff::Tape<T>::len(&self) -> usize
pub fn numrs2::autodiff::Tape<T>::ln(&mut self, x: numrs2::autodiff::Var) -> numrs2::autodiff::Var
pub fn numrs2::autodiff::Tape<T>::mul(&mut self, x: numrs2::autodiff::Var, y: numrs2::autodiff::Var) -> numrs2::autodiff::Var
pub fn numrs2::autodiff::Tape<T>::new() -> Self
pub fn numrs2::autodiff::Tape<T>::pow(&mut self, x: numrs2::autodiff::Var, n: T) -> numrs2::autodiff::Var
pub fn numrs2::autodiff::Tape<T>::sin(&mut self, x: numrs2::autodiff::Var) -> numrs2::autodiff::Var
pub fn numrs2::autodiff::Tape<T>::sub(&mut self, x: numrs2::autodiff::Var, y: numrs2::autodiff::Var) -> numrs2::autodiff::Var
pub fn numrs2::autodiff::Tape<T>::value(&self, var: numrs2::autodiff::Var) -> T
pub fn numrs2::autodiff::Tape<T>::var(&mut self, value: T) -> numrs2::autodiff::Var
pub fn numrs2::autodiff::Tape<T>::zero_grad(&mut self)
impl<T: num_traits::float::Float> core::default::Default for numrs2::autodiff::Tape<T>
pub fn numrs2::autodiff::Tape<T>::default() -> Self
pub struct numrs2::autodiff::Var(_)
pub fn numrs2::autodiff::directional_derivative<F, T>(f: F, x: &numrs2::array::Array<T>, v: &numrs2::array::Array<T>) -> numrs2::Result<T> where F: core::ops::function::Fn(&numrs2::array::Array<numrs2::autodiff::Dual<T>>) -> numrs2::autodiff::Dual<T>, T: num_traits::float::Float
pub fn numrs2::autodiff::gradient<F, T>(f: F, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where F: core::ops::function::Fn(&numrs2::array::Array<numrs2::autodiff::Dual<T>>) -> numrs2::autodiff::Dual<T>, T: num_traits::float::Float
pub fn numrs2::autodiff::hessian<F, T>(f: F, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where F: core::ops::function::Fn(&[T]) -> T, T: num_traits::float::Float
pub fn numrs2::autodiff::jacobian<F, T>(f: F, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where F: core::ops::function::Fn(&numrs2::array::Array<numrs2::autodiff::Dual<T>>) -> numrs2::array::Array<numrs2::autodiff::Dual<T>>, T: num_traits::float::Float
pub fn numrs2::autodiff::nth_derivative<F, T>(f: F, x: T, n: usize) -> T where F: core::ops::function::Fn(numrs2::autodiff::Dual<T>) -> numrs2::autodiff::Dual<T> + core::marker::Copy, T: num_traits::float::Float
pub fn numrs2::autodiff::taylor_series<F, T>(f: F, a: T, order: usize) -> alloc::vec::Vec<T> where F: core::ops::function::Fn(numrs2::autodiff::Dual<T>) -> numrs2::autodiff::Dual<T> + core::marker::Copy, T: num_traits::float::Float
pub mod numrs2::axis_ops
pub trait numrs2::axis_ops::AxisOps<T>
pub fn numrs2::axis_ops::AxisOps::argmax_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::axis_ops::AxisOps::argmin_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::axis_ops::AxisOps::cumprod_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::axis_ops::AxisOps::cumsum_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::axis_ops::AxisOps::max_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::axis_ops::AxisOps::mean_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::axis_ops::AxisOps::min_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::axis_ops::AxisOps::prod_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::axis_ops::AxisOps::std_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float
pub fn numrs2::axis_ops::AxisOps::sum_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::axis_ops::AxisOps::var_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float
impl<T> numrs2::axis_ops::AxisOps<T> for numrs2::array::Array<T> where T: core::clone::Clone + core::cmp::PartialOrd + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::cast::NumCast + core::fmt::Debug
pub fn numrs2::array::Array<T>::argmax_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array::Array<T>::argmin_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array::Array<T>::cumprod_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::array::Array<T>::cumsum_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::max_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::mean_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::min_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::prod_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::array::Array<T>::std_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float
pub fn numrs2::array::Array<T>::sum_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::var_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float
pub fn numrs2::axis_ops::apply_along_axis<T, U, F>(array: &numrs2::array::Array<T>, axis: usize, func: F) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + core::fmt::Debug + num_traits::identities::Zero, U: core::clone::Clone + core::fmt::Debug, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> U
pub fn numrs2::axis_ops::apply_over_axes<T, F>(array: &numrs2::array::Array<T>, axes: &[usize], func: F) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug, F: core::ops::function::Fn(&numrs2::array::Array<T>, usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::axis_ops::vectorize<T, U, F>(func: F) -> impl core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::array::Array<U> where T: core::clone::Clone + core::fmt::Debug, U: core::clone::Clone + core::fmt::Debug, F: core::ops::function::Fn(T) -> U + core::clone::Clone
pub mod numrs2::bitwise_ops
pub fn numrs2::bitwise_ops::bitwise_and<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::bit::BitAnd<Output = T>
pub fn numrs2::bitwise_ops::bitwise_not<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + core::ops::bit::Not<Output = T>
pub fn numrs2::bitwise_ops::bitwise_or<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::bit::BitOr<Output = T>
pub fn numrs2::bitwise_ops::bitwise_xor<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::bit::BitXor<Output = T>
pub fn numrs2::bitwise_ops::invert<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + core::ops::bit::Not<Output = T>
pub fn numrs2::bitwise_ops::left_shift<T, U>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::bit::Shl<U, Output = T>, U: core::clone::Clone
pub fn numrs2::bitwise_ops::left_shift_scalar<T, U>(x: &numrs2::array::Array<T>, shift: U) -> numrs2::array::Array<T> where T: core::clone::Clone + core::ops::bit::Shl<U, Output = T>, U: core::clone::Clone
pub fn numrs2::bitwise_ops::right_shift<T, U>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::bit::Shr<U, Output = T>, U: core::clone::Clone
pub fn numrs2::bitwise_ops::right_shift_scalar<T, U>(x: &numrs2::array::Array<T>, shift: U) -> numrs2::array::Array<T> where T: core::clone::Clone + core::ops::bit::Shr<U, Output = T>, U: core::clone::Clone
pub mod numrs2::blas
pub fn numrs2::blas::dot<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::default::Default
pub fn numrs2::blas::gemm<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, c: &mut numrs2::array::Array<T>, alpha: T, beta: T, trans_a: bool, trans_b: bool) -> numrs2::Result<()> where T: num_traits::float::Float + core::default::Default + core::ops::arith::AddAssign
pub fn numrs2::blas::gemv<T>(a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &mut numrs2::array::Array<T>, alpha: T, beta: T, trans: bool) -> numrs2::Result<()> where T: num_traits::float::Float + core::default::Default
pub mod numrs2::char
pub mod numrs2::char::regex_ops
pub fn numrs2::char::regex_ops::findall(arr: &numrs2::array_ops::string_ops::StringArray, pattern: &str) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::char::regex_ops::match_pattern(arr: &numrs2::array_ops::string_ops::StringArray, pattern: &str) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::regex_ops::split_regex(arr: &numrs2::array_ops::string_ops::StringArray, pattern: &str, maxsplit: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::char::regex_ops::sub(arr: &numrs2::array_ops::string_ops::StringArray, pattern: &str, replacement: &str, count: core::option::Option<usize>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub enum numrs2::char::StringElement
pub numrs2::char::StringElement::Fixed
pub numrs2::char::StringElement::Fixed::data: alloc::vec::Vec<u8>
pub numrs2::char::StringElement::Fixed::max_len: usize
pub numrs2::char::StringElement::Unicode(alloc::string::String)
impl numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::as_str(&self) -> numrs2::Result<&str>
pub fn numrs2::array_ops::string_ops::StringElement::capacity(&self) -> usize
pub fn numrs2::array_ops::string_ops::StringElement::fixed(s: &str, max_len: usize) -> Self
pub fn numrs2::array_ops::string_ops::StringElement::is_empty(&self) -> numrs2::Result<bool>
pub fn numrs2::array_ops::string_ops::StringElement::len(&self) -> numrs2::Result<usize>
pub fn numrs2::array_ops::string_ops::StringElement::to_string(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::array_ops::string_ops::StringElement::unicode<S: core::convert::Into<alloc::string::String>>(s: S) -> Self
impl core::cmp::Ord for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::cmp(&self, other: &Self) -> core::cmp::Ordering
impl core::cmp::PartialOrd for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering>
impl core::default::Default for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::default() -> Self
impl core::fmt::Display for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add for numrs2::array_ops::string_ops::StringElement
pub type numrs2::array_ops::string_ops::StringElement::Output = numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::add(self, other: Self) -> Self
impl num_traits::identities::Zero for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::is_zero(&self) -> bool
pub fn numrs2::array_ops::string_ops::StringElement::zero() -> Self
pub fn numrs2::char::add(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::array_from_strings<S: core::convert::AsRef<str>>(strings: &[S], dtype: &str, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::array_with_prefix<S: core::convert::AsRef<str>>(prefix: S, suffixes: &[S], dtype: &str) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::array_with_suffix<S: core::convert::AsRef<str>>(prefixes: &[S], suffix: S, dtype: &str) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::capitalize(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::center(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::count(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::char::decode(arr: &numrs2::array_ops::string_ops::StringArray, encoding: &str, errors: &str) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::encode(arr: &numrs2::array_ops::string_ops::StringArray, encoding: &str, errors: &str) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::endswith(arr: &numrs2::array_ops::string_ops::StringArray, suffix: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::expandtabs(arr: &numrs2::array_ops::string_ops::StringArray, tabsize: core::option::Option<usize>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::find(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::char::greater(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::greater_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::isalnum(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::isalpha(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::isdigit(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::islower(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::isspace(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::istitle(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::isupper(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::join(sep: &str, arr: &[alloc::vec::Vec<alloc::string::String>]) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::less(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::less_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::ljust(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::lower(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::lstrip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::mod_format(arr: &numrs2::array_ops::string_ops::StringArray, values: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::multiply(arr: &numrs2::array_ops::string_ops::StringArray, times: &numrs2::array::Array<i32>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::not_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::partition(arr: &numrs2::array_ops::string_ops::StringArray, sep: &str) -> numrs2::Result<alloc::vec::Vec<(alloc::string::String, alloc::string::String, alloc::string::String)>>
pub fn numrs2::char::replace(arr: &numrs2::array_ops::string_ops::StringArray, old: &str, new: &str, count: core::option::Option<usize>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::rfind(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::char::rjust(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::rpartition(arr: &numrs2::array_ops::string_ops::StringArray, sep: &str) -> numrs2::Result<alloc::vec::Vec<(alloc::string::String, alloc::string::String, alloc::string::String)>>
pub fn numrs2::char::rsplit(arr: &numrs2::array_ops::string_ops::StringArray, sep: core::option::Option<&str>, maxsplit: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::char::rstrip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::split(arr: &numrs2::array_ops::string_ops::StringArray, sep: core::option::Option<&str>, maxsplit: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::char::splitlines(arr: &numrs2::array_ops::string_ops::StringArray, keepends: core::option::Option<bool>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::char::startswith(arr: &numrs2::array_ops::string_ops::StringArray, prefix: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::char::str_len(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::char::strip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::swapcase(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::title(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::translate(arr: &numrs2::array_ops::string_ops::StringArray, table: &std::collections::hash::map::HashMap<char, char>, delete: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::upper(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::char::zfill(arr: &numrs2::array_ops::string_ops::StringArray, width: usize) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub type numrs2::char::StringArray = numrs2::array::Array<numrs2::array_ops::string_ops::StringElement>
pub mod numrs2::cluster
pub enum numrs2::cluster::KMeansInit
pub numrs2::cluster::KMeansInit::KMeansPlusPlus
pub numrs2::cluster::KMeansInit::Manual
pub numrs2::cluster::KMeansInit::Random
pub enum numrs2::cluster::LinkageMethod
pub numrs2::cluster::LinkageMethod::Average
pub numrs2::cluster::LinkageMethod::Complete
pub numrs2::cluster::LinkageMethod::Single
pub numrs2::cluster::LinkageMethod::Ward
pub struct numrs2::cluster::Dendrogram<T>
pub numrs2::cluster::Dendrogram::linkage: alloc::vec::Vec<[T; 4]>
pub numrs2::cluster::Dendrogram::n_observations: usize
pub struct numrs2::cluster::KMeans<T>
impl<T> numrs2::cluster::KMeans<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::cluster::KMeans<T>::centroids(&self) -> core::option::Option<&numrs2::array::Array<T>>
pub fn numrs2::cluster::KMeans<T>::fit(self, x: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub fn numrs2::cluster::KMeans<T>::inertia(&self) -> core::option::Option<T>
pub fn numrs2::cluster::KMeans<T>::max_iter(self, max_iter: usize) -> Self
pub fn numrs2::cluster::KMeans<T>::n_iter(&self) -> usize
pub fn numrs2::cluster::KMeans<T>::new(k: usize, init: numrs2::cluster::KMeansInit) -> Self
pub fn numrs2::cluster::KMeans<T>::predict(&self, x: &numrs2::array::Array<T>) -> numrs2::Result<alloc::vec::Vec<usize>>
pub fn numrs2::cluster::KMeans<T>::tol(self, tol: T) -> Self
pub fn numrs2::cluster::fcluster<T>(dendro: &numrs2::cluster::Dendrogram<T>, n_clusters: usize) -> numrs2::Result<alloc::vec::Vec<usize>> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::cluster::hierarchical<T>(x: &numrs2::array::Array<T>, method: numrs2::cluster::LinkageMethod) -> numrs2::Result<numrs2::cluster::Dendrogram<T>> where T: num_traits::float::Float + core::fmt::Debug
pub mod numrs2::comparisons
pub struct numrs2::comparisons::ArrayCompareOptions
pub numrs2::comparisons::ArrayCompareOptions::allow_broadcasting: bool
pub numrs2::comparisons::ArrayCompareOptions::atol: core::option::Option<f64>
pub numrs2::comparisons::ArrayCompareOptions::equal_nan: bool
pub numrs2::comparisons::ArrayCompareOptions::ignore_indices: core::option::Option<alloc::vec::Vec<usize>>
pub numrs2::comparisons::ArrayCompareOptions::rtol: core::option::Option<f64>
pub fn numrs2::comparisons::all<T>(a: &numrs2::array::Array<T>) -> bool where T: core::clone::Clone + core::cmp::PartialEq + core::fmt::Debug, bool: core::convert::From<T>
pub fn numrs2::comparisons::allclose<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> bool where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::comparisons::allclose_with_tol<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, rtol: T, atol: T) -> bool where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::comparisons::any<T>(a: &numrs2::array::Array<T>) -> bool where T: core::clone::Clone + core::cmp::PartialEq + core::fmt::Debug, bool: core::convert::From<T>
pub fn numrs2::comparisons::array_compare<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, options: &numrs2::comparisons::ArrayCompareOptions) -> bool where T: core::clone::Clone + core::cmp::PartialEq + core::fmt::Debug + 'static
pub fn numrs2::comparisons::array_equal<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, equal_nan: core::option::Option<bool>) -> bool where T: core::clone::Clone + core::cmp::PartialEq + core::fmt::Debug + 'static
pub fn numrs2::comparisons::count_nonzero<T>(a: &numrs2::array::Array<T>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::comparisons::equal<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + core::cmp::PartialEq + core::fmt::Debug
pub fn numrs2::comparisons::flatnonzero<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::comparisons::greater<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + core::cmp::PartialOrd + core::fmt::Debug
pub fn numrs2::comparisons::greater_equal<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + core::cmp::PartialOrd + core::fmt::Debug
pub fn numrs2::comparisons::isclose<T>(a: T, b: T, rtol: T, atol: T) -> bool where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::comparisons::isclose_array<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, rtol: T, atol: T) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::comparisons::less<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + core::cmp::PartialOrd + core::fmt::Debug
pub fn numrs2::comparisons::less_equal<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + core::cmp::PartialOrd + core::fmt::Debug
pub fn numrs2::comparisons::logical_and(x1: &numrs2::array::Array<bool>, x2: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::comparisons::logical_not(x: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::comparisons::logical_or(x1: &numrs2::array::Array<bool>, x2: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::comparisons::logical_xor(x1: &numrs2::array::Array<bool>, x2: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::comparisons::not_equal<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + core::cmp::PartialEq + core::fmt::Debug
pub mod numrs2::comparisons_broadcast
pub mod numrs2::complex_ops
pub fn numrs2::complex_ops::absolute<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::complex_ops::angle<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>, deg: bool) -> numrs2::array::Array<T>
pub fn numrs2::complex_ops::conj<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<num_complex::Complex<T>>
pub fn numrs2::complex_ops::from_polar<T: num_traits::float::Float>(magnitude: &numrs2::array::Array<T>, angle: &numrs2::array::Array<T>, deg: bool) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::complex_ops::imag<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::complex_ops::iscomplex<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<bool>
pub fn numrs2::complex_ops::iscomplexobj<T: num_traits::float::Float>(_array: &numrs2::array::Array<num_complex::Complex<T>>) -> bool
pub fn numrs2::complex_ops::isreal<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<bool>
pub fn numrs2::complex_ops::isrealobj<T: num_traits::float::Float>(_array: &numrs2::array::Array<T>) -> bool
pub fn numrs2::complex_ops::real<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::complex_ops::to_complex<T: num_traits::float::Float>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<num_complex::Complex<T>>
pub mod numrs2::conversions
pub trait numrs2::conversions::ConvertibleTo<T>: core::marker::Sized
pub fn numrs2::conversions::ConvertibleTo::convert_to(&self) -> numrs2::Result<T>
impl<S, T> numrs2::conversions::ConvertibleTo<T> for S where S: core::clone::Clone + num_traits::cast::NumCast, T: core::clone::Clone + num_traits::cast::NumCast
pub fn S::convert_to(&self) -> numrs2::Result<T>
pub fn numrs2::conversions::promote_types<T, U>() -> core::any::TypeId where T: 'static, U: 'static
pub mod numrs2::derivative
pub enum numrs2::derivative::DerivativeMethod
pub numrs2::derivative::DerivativeMethod::Backward
pub numrs2::derivative::DerivativeMethod::Central
pub numrs2::derivative::DerivativeMethod::Forward
pub numrs2::derivative::DerivativeMethod::Richardson
pub fn numrs2::derivative::derivative<T, F>(f: F, x: T, method: numrs2::derivative::DerivativeMethod) -> T where T: num_traits::float::Float, F: core::ops::function::Fn(T) -> T
pub fn numrs2::derivative::directional_derivative<T, F>(f: &F, x: &[T], direction: &[T]) -> T where T: num_traits::float::Float + core::iter::traits::accum::Sum, F: core::ops::function::Fn(&[T]) -> T
pub fn numrs2::derivative::gradient<T, F>(f: &F, x: &[T], method: numrs2::derivative::DerivativeMethod) -> alloc::vec::Vec<T> where T: num_traits::float::Float, F: core::ops::function::Fn(&[T]) -> T
pub fn numrs2::derivative::hessian<T, F>(f: &F, x: &[T]) -> alloc::vec::Vec<alloc::vec::Vec<T>> where T: num_traits::float::Float, F: core::ops::function::Fn(&[T]) -> T
pub fn numrs2::derivative::jacobian<T, F>(f: &F, x: &[T], method: numrs2::derivative::DerivativeMethod) -> alloc::vec::Vec<alloc::vec::Vec<T>> where T: num_traits::float::Float, F: core::ops::function::Fn(&[T]) -> alloc::vec::Vec<T>
pub mod numrs2::distance
pub enum numrs2::distance::DistanceMetric
pub numrs2::distance::DistanceMetric::Chebyshev
pub numrs2::distance::DistanceMetric::Correlation
pub numrs2::distance::DistanceMetric::Cosine
pub numrs2::distance::DistanceMetric::Euclidean
pub numrs2::distance::DistanceMetric::Hamming
pub numrs2::distance::DistanceMetric::Manhattan
pub numrs2::distance::DistanceMetric::Minkowski(f64)
pub fn numrs2::distance::cdist<T>(xa: &numrs2::array::Array<T>, xb: &numrs2::array::Array<T>, metric: numrs2::distance::DistanceMetric) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::distance::chebyshev<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::distance::correlation<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::distance::cosine<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::distance::euclidean<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::distance::hamming<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::distance::hamming_threshold<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, threshold: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::distance::manhattan<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::distance::minkowski<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, p: f64) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::distance::pdist<T>(x: &numrs2::array::Array<T>, metric: numrs2::distance::DistanceMetric) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug
pub mod numrs2::error
pub mod numrs2::error::computation
pub enum numrs2::error::computation::ComputationError
pub numrs2::error::computation::ComputationError::ConvergenceFailure
pub numrs2::error::computation::ComputationError::ConvergenceFailure::algorithm: alloc::string::String
pub numrs2::error::computation::ComputationError::ConvergenceFailure::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::ConvergenceFailure::iterations: usize
pub numrs2::error::computation::ComputationError::ConvergenceFailure::reason: alloc::string::String
pub numrs2::error::computation::ComputationError::ConvergenceFailure::residual: core::option::Option<f64>
pub numrs2::error::computation::ComputationError::ConvergenceFailure::tolerance: core::option::Option<f64>
pub numrs2::error::computation::ComputationError::EigenvalueError
pub numrs2::error::computation::ComputationError::EigenvalueError::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::EigenvalueError::matrix_properties: core::option::Option<alloc::string::String>
pub numrs2::error::computation::ComputationError::EigenvalueError::operation: alloc::string::String
pub numrs2::error::computation::ComputationError::EigenvalueError::reason: alloc::string::String
pub numrs2::error::computation::ComputationError::FFTError
pub numrs2::error::computation::ComputationError::FFTError::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::FFTError::reason: alloc::string::String
pub numrs2::error::computation::ComputationError::FFTError::signal_length: usize
pub numrs2::error::computation::ComputationError::FFTError::transform_type: alloc::string::String
pub numrs2::error::computation::ComputationError::IntegrationError
pub numrs2::error::computation::ComputationError::IntegrationError::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::IntegrationError::error_estimate: core::option::Option<f64>
pub numrs2::error::computation::ComputationError::IntegrationError::method: alloc::string::String
pub numrs2::error::computation::ComputationError::IntegrationError::reason: alloc::string::String
pub numrs2::error::computation::ComputationError::IntegrationError::step_size: core::option::Option<f64>
pub numrs2::error::computation::ComputationError::InterpolationError
pub numrs2::error::computation::ComputationError::InterpolationError::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::InterpolationError::data_points: usize
pub numrs2::error::computation::ComputationError::InterpolationError::method: alloc::string::String
pub numrs2::error::computation::ComputationError::InterpolationError::reason: alloc::string::String
pub numrs2::error::computation::ComputationError::InvalidMathOperation
pub numrs2::error::computation::ComputationError::InvalidMathOperation::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::InvalidMathOperation::operation: alloc::string::String
pub numrs2::error::computation::ComputationError::InvalidMathOperation::reason: alloc::string::String
pub numrs2::error::computation::ComputationError::InvalidMathOperation::suggested_alternative: core::option::Option<alloc::string::String>
pub numrs2::error::computation::ComputationError::LinearAlgebraLibraryError
pub numrs2::error::computation::ComputationError::LinearAlgebraLibraryError::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::LinearAlgebraLibraryError::details: core::option::Option<alloc::string::String>
pub numrs2::error::computation::ComputationError::LinearAlgebraLibraryError::error_code: i32
pub numrs2::error::computation::ComputationError::LinearAlgebraLibraryError::library: alloc::string::String
pub numrs2::error::computation::ComputationError::LinearAlgebraLibraryError::operation: alloc::string::String
pub numrs2::error::computation::ComputationError::NumericalInstability
pub numrs2::error::computation::ComputationError::NumericalInstability::condition_number: core::option::Option<f64>
pub numrs2::error::computation::ComputationError::NumericalInstability::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::NumericalInstability::details: alloc::string::String
pub numrs2::error::computation::ComputationError::NumericalInstability::operation: alloc::string::String
pub numrs2::error::computation::ComputationError::OptimizationError
pub numrs2::error::computation::ComputationError::OptimizationError::algorithm: alloc::string::String
pub numrs2::error::computation::ComputationError::OptimizationError::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::OptimizationError::gradient_norm: core::option::Option<f64>
pub numrs2::error::computation::ComputationError::OptimizationError::objective_value: core::option::Option<f64>
pub numrs2::error::computation::ComputationError::OptimizationError::reason: alloc::string::String
pub numrs2::error::computation::ComputationError::Overflow
pub numrs2::error::computation::ComputationError::Overflow::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::Overflow::details: alloc::string::String
pub numrs2::error::computation::ComputationError::Overflow::operation: alloc::string::String
pub numrs2::error::computation::ComputationError::Overflow::value: core::option::Option<alloc::string::String>
pub numrs2::error::computation::ComputationError::RandomGenerationError
pub numrs2::error::computation::ComputationError::RandomGenerationError::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::RandomGenerationError::distribution: core::option::Option<alloc::string::String>
pub numrs2::error::computation::ComputationError::RandomGenerationError::parameters: core::option::Option<alloc::string::String>
pub numrs2::error::computation::ComputationError::RandomGenerationError::reason: alloc::string::String
pub numrs2::error::computation::ComputationError::SVDError
pub numrs2::error::computation::ComputationError::SVDError::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::SVDError::matrix_shape: alloc::vec::Vec<usize>
pub numrs2::error::computation::ComputationError::SVDError::reason: alloc::string::String
pub numrs2::error::computation::ComputationError::SVDError::requested_components: core::option::Option<usize>
pub numrs2::error::computation::ComputationError::SingularMatrix
pub numrs2::error::computation::ComputationError::SingularMatrix::condition_number: core::option::Option<f64>
pub numrs2::error::computation::ComputationError::SingularMatrix::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::SingularMatrix::expected_rank: core::option::Option<usize>
pub numrs2::error::computation::ComputationError::SingularMatrix::operation: alloc::string::String
pub numrs2::error::computation::ComputationError::SingularMatrix::rank: core::option::Option<usize>
pub numrs2::error::computation::ComputationError::Underflow
pub numrs2::error::computation::ComputationError::Underflow::context: numrs2::error::OperationContext
pub numrs2::error::computation::ComputationError::Underflow::details: alloc::string::String
pub numrs2::error::computation::ComputationError::Underflow::operation: alloc::string::String
pub numrs2::error::computation::ComputationError::Underflow::value: core::option::Option<alloc::string::String>
impl numrs2::error::ComputationError
pub fn numrs2::error::ComputationError::blas_error(operation: &str, error_code: i32) -> Self
pub fn numrs2::error::ComputationError::convergence_failure(algorithm: &str, reason: &str, iterations: usize) -> Self
pub fn numrs2::error::ComputationError::fft_error(reason: &str, signal_length: usize, transform_type: &str) -> Self
pub fn numrs2::error::ComputationError::lapack_error(operation: &str, error_code: i32) -> Self
pub fn numrs2::error::ComputationError::numerical_instability(operation: &str, details: &str) -> Self
pub fn numrs2::error::ComputationError::overflow(operation: &str, details: &str) -> Self
pub fn numrs2::error::ComputationError::singular_matrix(operation: &str) -> Self
impl numrs2::error::ComputationError
pub fn numrs2::error::ComputationError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::ComputationError::is_potentially_recoverable(&self) -> bool
pub fn numrs2::error::ComputationError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::ComputationError::severity(&self) -> numrs2::error::ErrorSeverity
pub mod numrs2::error::context
pub enum numrs2::error::context::ErrorSeverity
pub numrs2::error::context::ErrorSeverity::Critical
pub numrs2::error::context::ErrorSeverity::High
pub numrs2::error::context::ErrorSeverity::Low
pub numrs2::error::context::ErrorSeverity::Medium
impl core::fmt::Display for numrs2::error::ErrorSeverity
pub fn numrs2::error::ErrorSeverity::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub enum numrs2::error::context::MemoryPressure
pub numrs2::error::context::MemoryPressure::Critical
pub numrs2::error::context::MemoryPressure::High
pub numrs2::error::context::MemoryPressure::Low
pub numrs2::error::context::MemoryPressure::Medium
pub struct numrs2::error::context::ErrorContext<E>
impl<E> numrs2::error::ErrorContext<E>
pub fn numrs2::error::ErrorContext<E>::chain(&self) -> &[alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>]
pub fn numrs2::error::ErrorContext<E>::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::ErrorContext<E>::error(&self) -> &E
pub fn numrs2::error::ErrorContext<E>::into_inner(self) -> E
pub fn numrs2::error::ErrorContext<E>::location(&self) -> core::option::Option<&numrs2::error::ErrorLocation>
pub fn numrs2::error::ErrorContext<E>::new(error: E, context: numrs2::error::OperationContext) -> Self
pub fn numrs2::error::ErrorContext<E>::recovery_suggestions(&self) -> &[alloc::string::String]
pub fn numrs2::error::ErrorContext<E>::with_location(self, location: numrs2::error::ErrorLocation) -> Self
pub fn numrs2::error::ErrorContext<E>::with_source<S>(self, source: S) -> Self where S: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::error::ErrorContext<E>::with_suggestion(self, suggestion: &str) -> Self
impl<E: core::error::Error + 'static> core::error::Error for numrs2::error::ErrorContext<E>
pub fn numrs2::error::ErrorContext<E>::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl<E: core::fmt::Display> core::fmt::Display for numrs2::error::ErrorContext<E>
pub fn numrs2::error::ErrorContext<E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::error::context::ErrorLocation
pub numrs2::error::context::ErrorLocation::file: alloc::string::String
pub numrs2::error::context::ErrorLocation::function: alloc::string::String
pub numrs2::error::context::ErrorLocation::line: u32
pub numrs2::error::context::ErrorLocation::module_path: core::option::Option<alloc::string::String>
impl numrs2::error::ErrorLocation
pub fn numrs2::error::ErrorLocation::new(file: &str, line: u32, function: &str) -> Self
pub fn numrs2::error::ErrorLocation::with_module(file: &str, line: u32, function: &str, module_path: &str) -> Self
impl core::fmt::Display for numrs2::error::ErrorLocation
pub fn numrs2::error::ErrorLocation::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::error::context::MemoryInfo
pub numrs2::error::context::MemoryInfo::available_memory: core::option::Option<usize>
pub numrs2::error::context::MemoryInfo::peak_usage: usize
pub numrs2::error::context::MemoryInfo::pressure_level: numrs2::error::MemoryPressure
pub numrs2::error::context::MemoryInfo::total_allocated: usize
pub struct numrs2::error::context::OperationContext
pub numrs2::error::context::OperationContext::dtypes: alloc::vec::Vec<alloc::string::String>
pub numrs2::error::context::OperationContext::memory_info: core::option::Option<numrs2::error::MemoryInfo>
pub numrs2::error::context::OperationContext::operation: core::option::Option<alloc::string::String>
pub numrs2::error::context::OperationContext::parameters: std::collections::hash::map::HashMap<alloc::string::String, alloc::string::String>
pub numrs2::error::context::OperationContext::performance_hints: alloc::vec::Vec<alloc::string::String>
pub numrs2::error::context::OperationContext::shapes: alloc::vec::Vec<alloc::vec::Vec<usize>>
pub numrs2::error::context::OperationContext::thread_info: core::option::Option<numrs2::error::ThreadInfo>
pub numrs2::error::context::OperationContext::timestamp: u64
impl numrs2::error::OperationContext
pub fn numrs2::error::OperationContext::new(operation: &str) -> Self
pub fn numrs2::error::OperationContext::with_dtype(self, dtype: &str) -> Self
pub fn numrs2::error::OperationContext::with_memory_info(self, memory_info: numrs2::error::MemoryInfo) -> Self
pub fn numrs2::error::OperationContext::with_parameter<K, V>(self, key: K, value: V) -> Self where K: core::convert::Into<alloc::string::String>, V: core::fmt::Display
pub fn numrs2::error::OperationContext::with_performance_hint(self, hint: &str) -> Self
pub fn numrs2::error::OperationContext::with_shape(self, shape: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::error::OperationContext::with_shapes(self, shapes: &[alloc::vec::Vec<usize>]) -> Self
pub fn numrs2::error::OperationContext::with_thread_info(self, thread_info: numrs2::error::ThreadInfo) -> Self
impl core::default::Default for numrs2::error::OperationContext
pub fn numrs2::error::OperationContext::default() -> Self
pub struct numrs2::error::context::ThreadInfo
pub numrs2::error::context::ThreadInfo::is_parallel: bool
pub numrs2::error::context::ThreadInfo::pool_info: core::option::Option<alloc::string::String>
pub numrs2::error::context::ThreadInfo::thread_count: core::option::Option<usize>
pub numrs2::error::context::ThreadInfo::thread_id: alloc::string::String
pub mod numrs2::error::core
pub enum numrs2::error::core::CoreError
pub numrs2::error::core::CoreError::BroadcastError
pub numrs2::error::core::CoreError::BroadcastError::context: numrs2::error::OperationContext
pub numrs2::error::core::CoreError::BroadcastError::shape1: alloc::vec::Vec<usize>
pub numrs2::error::core::CoreError::BroadcastError::shape2: alloc::vec::Vec<usize>
pub numrs2::error::core::CoreError::DimensionMismatch
pub numrs2::error::core::CoreError::DimensionMismatch::actual_dims: core::option::Option<usize>
pub numrs2::error::core::CoreError::DimensionMismatch::context: numrs2::error::OperationContext
pub numrs2::error::core::CoreError::DimensionMismatch::expected_dims: core::option::Option<usize>
pub numrs2::error::core::CoreError::DimensionMismatch::message: alloc::string::String
pub numrs2::error::core::CoreError::FeatureNotEnabled
pub numrs2::error::core::CoreError::FeatureNotEnabled::context: numrs2::error::OperationContext
pub numrs2::error::core::CoreError::FeatureNotEnabled::feature: alloc::string::String
pub numrs2::error::core::CoreError::FeatureNotEnabled::feature_flag: alloc::string::String
pub numrs2::error::core::CoreError::IndexOutOfBounds
pub numrs2::error::core::CoreError::IndexOutOfBounds::axis: usize
pub numrs2::error::core::CoreError::IndexOutOfBounds::context: numrs2::error::OperationContext
pub numrs2::error::core::CoreError::IndexOutOfBounds::index: isize
pub numrs2::error::core::CoreError::IndexOutOfBounds::size: usize
pub numrs2::error::core::CoreError::InvalidAxis
pub numrs2::error::core::CoreError::InvalidAxis::axis: isize
pub numrs2::error::core::CoreError::InvalidAxis::context: numrs2::error::OperationContext
pub numrs2::error::core::CoreError::InvalidAxis::ndim: usize
pub numrs2::error::core::CoreError::InvalidOperation
pub numrs2::error::core::CoreError::InvalidOperation::context: numrs2::error::OperationContext
pub numrs2::error::core::CoreError::InvalidOperation::operation: alloc::string::String
pub numrs2::error::core::CoreError::InvalidOperation::reason: alloc::string::String
pub numrs2::error::core::CoreError::NotImplemented
pub numrs2::error::core::CoreError::NotImplemented::alternative: core::option::Option<alloc::string::String>
pub numrs2::error::core::CoreError::NotImplemented::context: numrs2::error::OperationContext
pub numrs2::error::core::CoreError::NotImplemented::feature: alloc::string::String
pub numrs2::error::core::CoreError::NotImplemented::planned_version: core::option::Option<alloc::string::String>
pub numrs2::error::core::CoreError::ShapeMismatch
pub numrs2::error::core::CoreError::ShapeMismatch::actual: alloc::vec::Vec<usize>
pub numrs2::error::core::CoreError::ShapeMismatch::context: numrs2::error::OperationContext
pub numrs2::error::core::CoreError::ShapeMismatch::expected: alloc::vec::Vec<usize>
pub numrs2::error::core::CoreError::StrideError
pub numrs2::error::core::CoreError::StrideError::actual_strides: core::option::Option<alloc::vec::Vec<isize>>
pub numrs2::error::core::CoreError::StrideError::context: numrs2::error::OperationContext
pub numrs2::error::core::CoreError::StrideError::expected_strides: core::option::Option<alloc::vec::Vec<isize>>
pub numrs2::error::core::CoreError::StrideError::message: alloc::string::String
pub numrs2::error::core::CoreError::TypeConversion
pub numrs2::error::core::CoreError::TypeConversion::context: numrs2::error::OperationContext
pub numrs2::error::core::CoreError::TypeConversion::from_type: alloc::string::String
pub numrs2::error::core::CoreError::TypeConversion::reason: alloc::string::String
pub numrs2::error::core::CoreError::TypeConversion::to_type: alloc::string::String
pub numrs2::error::core::CoreError::ValueError
pub numrs2::error::core::CoreError::ValueError::actual_value: core::option::Option<alloc::string::String>
pub numrs2::error::core::CoreError::ValueError::context: numrs2::error::OperationContext
pub numrs2::error::core::CoreError::ValueError::expected_range: core::option::Option<alloc::string::String>
pub numrs2::error::core::CoreError::ValueError::message: alloc::string::String
pub numrs2::error::core::CoreError::ViewError
pub numrs2::error::core::CoreError::ViewError::context: numrs2::error::OperationContext
pub numrs2::error::core::CoreError::ViewError::message: alloc::string::String
pub numrs2::error::core::CoreError::ViewError::view_type: alloc::string::String
impl numrs2::error::CoreError
pub fn numrs2::error::CoreError::broadcast_error(shape1: alloc::vec::Vec<usize>, shape2: alloc::vec::Vec<usize>, operation: &str) -> Self
pub fn numrs2::error::CoreError::dimension_mismatch(message: &str, expected: core::option::Option<usize>, actual: core::option::Option<usize>) -> Self
pub fn numrs2::error::CoreError::feature_not_enabled(feature: &str, feature_flag: &str) -> Self
pub fn numrs2::error::CoreError::index_out_of_bounds(index: isize, axis: usize, size: usize, operation: &str) -> Self
pub fn numrs2::error::CoreError::invalid_operation(operation: &str, reason: &str) -> Self
pub fn numrs2::error::CoreError::not_implemented(feature: &str) -> Self
pub fn numrs2::error::CoreError::shape_mismatch(expected: alloc::vec::Vec<usize>, actual: alloc::vec::Vec<usize>, operation: &str) -> Self
impl numrs2::error::CoreError
pub fn numrs2::error::CoreError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::CoreError::is_programming_error(&self) -> bool
pub fn numrs2::error::CoreError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::CoreError::severity(&self) -> numrs2::error::ErrorSeverity
pub mod numrs2::error::io
pub enum numrs2::error::io::IOError
pub numrs2::error::io::IOError::AccessDenied
pub numrs2::error::io::IOError::AccessDenied::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::AccessDenied::operation: alloc::string::String
pub numrs2::error::io::IOError::AccessDenied::reason: alloc::string::String
pub numrs2::error::io::IOError::AccessDenied::required_permissions: core::option::Option<alloc::string::String>
pub numrs2::error::io::IOError::AccessDenied::resource: alloc::string::String
pub numrs2::error::io::IOError::Compression
pub numrs2::error::io::IOError::Compression::algorithm: alloc::string::String
pub numrs2::error::io::IOError::Compression::compression_ratio: core::option::Option<f64>
pub numrs2::error::io::IOError::Compression::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::Compression::reason: alloc::string::String
pub numrs2::error::io::IOError::Database
pub numrs2::error::io::IOError::Database::connection_string: core::option::Option<alloc::string::String>
pub numrs2::error::io::IOError::Database::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::Database::database_type: core::option::Option<alloc::string::String>
pub numrs2::error::io::IOError::Database::operation: alloc::string::String
pub numrs2::error::io::IOError::Database::reason: alloc::string::String
pub numrs2::error::io::IOError::Deserialization
pub numrs2::error::io::IOError::Deserialization::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::Deserialization::data_size: core::option::Option<usize>
pub numrs2::error::io::IOError::Deserialization::file_path: core::option::Option<std::path::PathBuf>
pub numrs2::error::io::IOError::Deserialization::format: alloc::string::String
pub numrs2::error::io::IOError::Deserialization::reason: alloc::string::String
pub numrs2::error::io::IOError::Encoding
pub numrs2::error::io::IOError::Encoding::byte_position: core::option::Option<usize>
pub numrs2::error::io::IOError::Encoding::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::Encoding::details: alloc::string::String
pub numrs2::error::io::IOError::Encoding::encoding: alloc::string::String
pub numrs2::error::io::IOError::FileOperation
pub numrs2::error::io::IOError::FileOperation::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::FileOperation::io_error_kind: core::option::Option<std::io::error::ErrorKind>
pub numrs2::error::io::IOError::FileOperation::operation: alloc::string::String
pub numrs2::error::io::IOError::FileOperation::path: std::path::PathBuf
pub numrs2::error::io::IOError::FileOperation::reason: alloc::string::String
pub numrs2::error::io::IOError::InvalidFormat
pub numrs2::error::io::IOError::InvalidFormat::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::InvalidFormat::details: alloc::string::String
pub numrs2::error::io::IOError::InvalidFormat::expected_format: core::option::Option<alloc::string::String>
pub numrs2::error::io::IOError::InvalidFormat::file_path: core::option::Option<std::path::PathBuf>
pub numrs2::error::io::IOError::InvalidFormat::format: alloc::string::String
pub numrs2::error::io::IOError::MemoryMapping
pub numrs2::error::io::IOError::MemoryMapping::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::MemoryMapping::file_path: std::path::PathBuf
pub numrs2::error::io::IOError::MemoryMapping::mapping_size: core::option::Option<usize>
pub numrs2::error::io::IOError::MemoryMapping::offset: core::option::Option<usize>
pub numrs2::error::io::IOError::MemoryMapping::reason: alloc::string::String
pub numrs2::error::io::IOError::Network
pub numrs2::error::io::IOError::Network::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::Network::operation: alloc::string::String
pub numrs2::error::io::IOError::Network::reason: alloc::string::String
pub numrs2::error::io::IOError::Network::status_code: core::option::Option<u16>
pub numrs2::error::io::IOError::Network::url: core::option::Option<alloc::string::String>
pub numrs2::error::io::IOError::Serialization
pub numrs2::error::io::IOError::Serialization::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::Serialization::data_type: core::option::Option<alloc::string::String>
pub numrs2::error::io::IOError::Serialization::format: alloc::string::String
pub numrs2::error::io::IOError::Serialization::reason: alloc::string::String
pub numrs2::error::io::IOError::Stream
pub numrs2::error::io::IOError::Stream::bytes_processed: core::option::Option<usize>
pub numrs2::error::io::IOError::Stream::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::Stream::reason: alloc::string::String
pub numrs2::error::io::IOError::Stream::stream_type: alloc::string::String
pub numrs2::error::io::IOError::TemporaryResource
pub numrs2::error::io::IOError::TemporaryResource::cleanup_attempted: bool
pub numrs2::error::io::IOError::TemporaryResource::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::TemporaryResource::reason: alloc::string::String
pub numrs2::error::io::IOError::TemporaryResource::resource_type: alloc::string::String
pub numrs2::error::io::IOError::Validation
pub numrs2::error::io::IOError::Validation::actual_value: core::option::Option<alloc::string::String>
pub numrs2::error::io::IOError::Validation::context: numrs2::error::OperationContext
pub numrs2::error::io::IOError::Validation::details: alloc::string::String
pub numrs2::error::io::IOError::Validation::expected_value: core::option::Option<alloc::string::String>
pub numrs2::error::io::IOError::Validation::validation_type: alloc::string::String
impl numrs2::error::IOError
pub fn numrs2::error::IOError::access_denied(operation: &str, resource: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::deserialization(format: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::file_operation(operation: &str, path: std::path::PathBuf, reason: &str) -> Self
pub fn numrs2::error::IOError::invalid_format(format: &str, details: &str) -> Self
pub fn numrs2::error::IOError::network(operation: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::serialization(format: &str, reason: &str) -> Self
impl numrs2::error::IOError
pub fn numrs2::error::IOError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::IOError::is_transient(&self) -> bool
pub fn numrs2::error::IOError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::IOError::severity(&self) -> numrs2::error::ErrorSeverity
impl core::convert::From<std::io::error::Error> for numrs2::error::IOError
pub fn numrs2::error::IOError::from(err: std::io::error::Error) -> Self
pub mod numrs2::error::memory
pub enum numrs2::error::memory::AccessType
pub numrs2::error::memory::AccessType::Execute
pub numrs2::error::memory::AccessType::Read
pub numrs2::error::memory::AccessType::ReadWrite
pub numrs2::error::memory::AccessType::Write
pub enum numrs2::error::memory::CorruptionType
pub numrs2::error::memory::CorruptionType::BufferOverflow
pub numrs2::error::memory::CorruptionType::BufferUnderflow
pub numrs2::error::memory::CorruptionType::DoubleFree
pub numrs2::error::memory::CorruptionType::HeapCorruption
pub numrs2::error::memory::CorruptionType::InvalidPointer
pub numrs2::error::memory::CorruptionType::StackOverflow
pub numrs2::error::memory::CorruptionType::UseAfterFree
pub enum numrs2::error::memory::MemoryError
pub numrs2::error::memory::MemoryError::AlignmentError
pub numrs2::error::memory::MemoryError::AlignmentError::actual_alignment: core::option::Option<usize>
pub numrs2::error::memory::MemoryError::AlignmentError::context: numrs2::error::OperationContext
pub numrs2::error::memory::MemoryError::AlignmentError::reason: alloc::string::String
pub numrs2::error::memory::MemoryError::AlignmentError::required_alignment: usize
pub numrs2::error::memory::MemoryError::AllocationFailed
pub numrs2::error::memory::MemoryError::AllocationFailed::allocator_type: core::option::Option<alloc::string::String>
pub numrs2::error::memory::MemoryError::AllocationFailed::available_bytes: core::option::Option<usize>
pub numrs2::error::memory::MemoryError::AllocationFailed::context: numrs2::error::OperationContext
pub numrs2::error::memory::MemoryError::AllocationFailed::reason: alloc::string::String
pub numrs2::error::memory::MemoryError::AllocationFailed::requested_bytes: usize
pub numrs2::error::memory::MemoryError::ArenaOverflow
pub numrs2::error::memory::MemoryError::ArenaOverflow::arena_size: usize
pub numrs2::error::memory::MemoryError::ArenaOverflow::context: numrs2::error::OperationContext
pub numrs2::error::memory::MemoryError::ArenaOverflow::remaining_bytes: usize
pub numrs2::error::memory::MemoryError::ArenaOverflow::requested_bytes: usize
pub numrs2::error::memory::MemoryError::Fragmentation
pub numrs2::error::memory::MemoryError::Fragmentation::context: numrs2::error::OperationContext
pub numrs2::error::memory::MemoryError::Fragmentation::fragmentation_level: f64
pub numrs2::error::memory::MemoryError::Fragmentation::largest_free_block: core::option::Option<usize>
pub numrs2::error::memory::MemoryError::Fragmentation::reason: alloc::string::String
pub numrs2::error::memory::MemoryError::GpuMemoryError
pub numrs2::error::memory::MemoryError::GpuMemoryError::available_bytes: core::option::Option<usize>
pub numrs2::error::memory::MemoryError::GpuMemoryError::context: numrs2::error::OperationContext
pub numrs2::error::memory::MemoryError::GpuMemoryError::device_id: core::option::Option<usize>
pub numrs2::error::memory::MemoryError::GpuMemoryError::reason: alloc::string::String
pub numrs2::error::memory::MemoryError::GpuMemoryError::requested_bytes: core::option::Option<usize>
pub numrs2::error::memory::MemoryError::InvalidAccess
pub numrs2::error::memory::MemoryError::InvalidAccess::access_type: numrs2::error::AccessType
pub numrs2::error::memory::MemoryError::InvalidAccess::address: core::option::Option<usize>
pub numrs2::error::memory::MemoryError::InvalidAccess::context: numrs2::error::OperationContext
pub numrs2::error::memory::MemoryError::InvalidAccess::reason: alloc::string::String
pub numrs2::error::memory::MemoryError::InvalidAccess::valid_range: core::option::Option<(usize, usize)>
pub numrs2::error::memory::MemoryError::MappingError
pub numrs2::error::memory::MemoryError::MappingError::context: numrs2::error::OperationContext
pub numrs2::error::memory::MemoryError::MappingError::file_path: core::option::Option<alloc::string::String>
pub numrs2::error::memory::MemoryError::MappingError::mapping_size: core::option::Option<usize>
pub numrs2::error::memory::MemoryError::MappingError::reason: alloc::string::String
pub numrs2::error::memory::MemoryError::MemoryCorruption
pub numrs2::error::memory::MemoryError::MemoryCorruption::affected_range: core::option::Option<(usize, usize)>
pub numrs2::error::memory::MemoryError::MemoryCorruption::context: numrs2::error::OperationContext
pub numrs2::error::memory::MemoryError::MemoryCorruption::corruption_type: numrs2::error::CorruptionType
pub numrs2::error::memory::MemoryError::MemoryCorruption::details: alloc::string::String
pub numrs2::error::memory::MemoryError::MemoryLeak
pub numrs2::error::memory::MemoryError::MemoryLeak::allocation_source: core::option::Option<alloc::string::String>
pub numrs2::error::memory::MemoryError::MemoryLeak::context: numrs2::error::OperationContext
pub numrs2::error::memory::MemoryError::MemoryLeak::details: alloc::string::String
pub numrs2::error::memory::MemoryError::MemoryLeak::leaked_bytes: usize
pub numrs2::error::memory::MemoryError::NumaError
pub numrs2::error::memory::MemoryError::NumaError::context: numrs2::error::OperationContext
pub numrs2::error::memory::MemoryError::NumaError::numa_node: core::option::Option<usize>
pub numrs2::error::memory::MemoryError::NumaError::preferred_node: core::option::Option<usize>
pub numrs2::error::memory::MemoryError::NumaError::reason: alloc::string::String
pub numrs2::error::memory::MemoryError::OutOfMemory
pub numrs2::error::memory::MemoryError::OutOfMemory::context: numrs2::error::OperationContext
pub numrs2::error::memory::MemoryError::OutOfMemory::details: alloc::string::String
pub numrs2::error::memory::MemoryError::OutOfMemory::process_limit: core::option::Option<usize>
pub numrs2::error::memory::MemoryError::OutOfMemory::system_available: core::option::Option<usize>
pub numrs2::error::memory::MemoryError::OutOfMemory::total_requested: usize
pub numrs2::error::memory::MemoryError::PoolExhausted
pub numrs2::error::memory::MemoryError::PoolExhausted::allocated_blocks: usize
pub numrs2::error::memory::MemoryError::PoolExhausted::block_size: usize
pub numrs2::error::memory::MemoryError::PoolExhausted::context: numrs2::error::OperationContext
pub numrs2::error::memory::MemoryError::PoolExhausted::pool_size: usize
pub numrs2::error::memory::MemoryError::PoolExhausted::pool_type: alloc::string::String
impl numrs2::error::MemoryError
pub fn numrs2::error::MemoryError::alignment_error(reason: &str, required_alignment: usize) -> Self
pub fn numrs2::error::MemoryError::allocation_failed(reason: &str, requested_bytes: usize) -> Self
pub fn numrs2::error::MemoryError::arena_overflow(requested_bytes: usize, remaining_bytes: usize, arena_size: usize) -> Self
pub fn numrs2::error::MemoryError::gpu_memory_error(reason: &str, device_id: core::option::Option<usize>) -> Self
pub fn numrs2::error::MemoryError::memory_corruption(details: &str, corruption_type: numrs2::error::CorruptionType) -> Self
pub fn numrs2::error::MemoryError::out_of_memory(details: &str, total_requested: usize) -> Self
pub fn numrs2::error::MemoryError::pool_exhausted(pool_type: &str, pool_size: usize, block_size: usize) -> Self
impl numrs2::error::MemoryError
pub fn numrs2::error::MemoryError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::MemoryError::is_transient(&self) -> bool
pub fn numrs2::error::MemoryError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::MemoryError::severity(&self) -> numrs2::error::ErrorSeverity
pub mod numrs2::error::prelude
pub enum numrs2::error::prelude::ComputationError
pub numrs2::error::prelude::ComputationError::ConvergenceFailure
pub numrs2::error::prelude::ComputationError::ConvergenceFailure::algorithm: alloc::string::String
pub numrs2::error::prelude::ComputationError::ConvergenceFailure::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::ConvergenceFailure::iterations: usize
pub numrs2::error::prelude::ComputationError::ConvergenceFailure::reason: alloc::string::String
pub numrs2::error::prelude::ComputationError::ConvergenceFailure::residual: core::option::Option<f64>
pub numrs2::error::prelude::ComputationError::ConvergenceFailure::tolerance: core::option::Option<f64>
pub numrs2::error::prelude::ComputationError::EigenvalueError
pub numrs2::error::prelude::ComputationError::EigenvalueError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::EigenvalueError::matrix_properties: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::ComputationError::EigenvalueError::operation: alloc::string::String
pub numrs2::error::prelude::ComputationError::EigenvalueError::reason: alloc::string::String
pub numrs2::error::prelude::ComputationError::FFTError
pub numrs2::error::prelude::ComputationError::FFTError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::FFTError::reason: alloc::string::String
pub numrs2::error::prelude::ComputationError::FFTError::signal_length: usize
pub numrs2::error::prelude::ComputationError::FFTError::transform_type: alloc::string::String
pub numrs2::error::prelude::ComputationError::IntegrationError
pub numrs2::error::prelude::ComputationError::IntegrationError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::IntegrationError::error_estimate: core::option::Option<f64>
pub numrs2::error::prelude::ComputationError::IntegrationError::method: alloc::string::String
pub numrs2::error::prelude::ComputationError::IntegrationError::reason: alloc::string::String
pub numrs2::error::prelude::ComputationError::IntegrationError::step_size: core::option::Option<f64>
pub numrs2::error::prelude::ComputationError::InterpolationError
pub numrs2::error::prelude::ComputationError::InterpolationError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::InterpolationError::data_points: usize
pub numrs2::error::prelude::ComputationError::InterpolationError::method: alloc::string::String
pub numrs2::error::prelude::ComputationError::InterpolationError::reason: alloc::string::String
pub numrs2::error::prelude::ComputationError::InvalidMathOperation
pub numrs2::error::prelude::ComputationError::InvalidMathOperation::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::InvalidMathOperation::operation: alloc::string::String
pub numrs2::error::prelude::ComputationError::InvalidMathOperation::reason: alloc::string::String
pub numrs2::error::prelude::ComputationError::InvalidMathOperation::suggested_alternative: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::ComputationError::LinearAlgebraLibraryError
pub numrs2::error::prelude::ComputationError::LinearAlgebraLibraryError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::LinearAlgebraLibraryError::details: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::ComputationError::LinearAlgebraLibraryError::error_code: i32
pub numrs2::error::prelude::ComputationError::LinearAlgebraLibraryError::library: alloc::string::String
pub numrs2::error::prelude::ComputationError::LinearAlgebraLibraryError::operation: alloc::string::String
pub numrs2::error::prelude::ComputationError::NumericalInstability
pub numrs2::error::prelude::ComputationError::NumericalInstability::condition_number: core::option::Option<f64>
pub numrs2::error::prelude::ComputationError::NumericalInstability::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::NumericalInstability::details: alloc::string::String
pub numrs2::error::prelude::ComputationError::NumericalInstability::operation: alloc::string::String
pub numrs2::error::prelude::ComputationError::OptimizationError
pub numrs2::error::prelude::ComputationError::OptimizationError::algorithm: alloc::string::String
pub numrs2::error::prelude::ComputationError::OptimizationError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::OptimizationError::gradient_norm: core::option::Option<f64>
pub numrs2::error::prelude::ComputationError::OptimizationError::objective_value: core::option::Option<f64>
pub numrs2::error::prelude::ComputationError::OptimizationError::reason: alloc::string::String
pub numrs2::error::prelude::ComputationError::Overflow
pub numrs2::error::prelude::ComputationError::Overflow::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::Overflow::details: alloc::string::String
pub numrs2::error::prelude::ComputationError::Overflow::operation: alloc::string::String
pub numrs2::error::prelude::ComputationError::Overflow::value: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::ComputationError::RandomGenerationError
pub numrs2::error::prelude::ComputationError::RandomGenerationError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::RandomGenerationError::distribution: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::ComputationError::RandomGenerationError::parameters: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::ComputationError::RandomGenerationError::reason: alloc::string::String
pub numrs2::error::prelude::ComputationError::SVDError
pub numrs2::error::prelude::ComputationError::SVDError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::SVDError::matrix_shape: alloc::vec::Vec<usize>
pub numrs2::error::prelude::ComputationError::SVDError::reason: alloc::string::String
pub numrs2::error::prelude::ComputationError::SVDError::requested_components: core::option::Option<usize>
pub numrs2::error::prelude::ComputationError::SingularMatrix
pub numrs2::error::prelude::ComputationError::SingularMatrix::condition_number: core::option::Option<f64>
pub numrs2::error::prelude::ComputationError::SingularMatrix::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::SingularMatrix::expected_rank: core::option::Option<usize>
pub numrs2::error::prelude::ComputationError::SingularMatrix::operation: alloc::string::String
pub numrs2::error::prelude::ComputationError::SingularMatrix::rank: core::option::Option<usize>
pub numrs2::error::prelude::ComputationError::Underflow
pub numrs2::error::prelude::ComputationError::Underflow::context: numrs2::error::OperationContext
pub numrs2::error::prelude::ComputationError::Underflow::details: alloc::string::String
pub numrs2::error::prelude::ComputationError::Underflow::operation: alloc::string::String
pub numrs2::error::prelude::ComputationError::Underflow::value: core::option::Option<alloc::string::String>
impl numrs2::error::ComputationError
pub fn numrs2::error::ComputationError::blas_error(operation: &str, error_code: i32) -> Self
pub fn numrs2::error::ComputationError::convergence_failure(algorithm: &str, reason: &str, iterations: usize) -> Self
pub fn numrs2::error::ComputationError::fft_error(reason: &str, signal_length: usize, transform_type: &str) -> Self
pub fn numrs2::error::ComputationError::lapack_error(operation: &str, error_code: i32) -> Self
pub fn numrs2::error::ComputationError::numerical_instability(operation: &str, details: &str) -> Self
pub fn numrs2::error::ComputationError::overflow(operation: &str, details: &str) -> Self
pub fn numrs2::error::ComputationError::singular_matrix(operation: &str) -> Self
impl numrs2::error::ComputationError
pub fn numrs2::error::ComputationError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::ComputationError::is_potentially_recoverable(&self) -> bool
pub fn numrs2::error::ComputationError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::ComputationError::severity(&self) -> numrs2::error::ErrorSeverity
pub enum numrs2::error::prelude::CoreError
pub numrs2::error::prelude::CoreError::BroadcastError
pub numrs2::error::prelude::CoreError::BroadcastError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::CoreError::BroadcastError::shape1: alloc::vec::Vec<usize>
pub numrs2::error::prelude::CoreError::BroadcastError::shape2: alloc::vec::Vec<usize>
pub numrs2::error::prelude::CoreError::DimensionMismatch
pub numrs2::error::prelude::CoreError::DimensionMismatch::actual_dims: core::option::Option<usize>
pub numrs2::error::prelude::CoreError::DimensionMismatch::context: numrs2::error::OperationContext
pub numrs2::error::prelude::CoreError::DimensionMismatch::expected_dims: core::option::Option<usize>
pub numrs2::error::prelude::CoreError::DimensionMismatch::message: alloc::string::String
pub numrs2::error::prelude::CoreError::FeatureNotEnabled
pub numrs2::error::prelude::CoreError::FeatureNotEnabled::context: numrs2::error::OperationContext
pub numrs2::error::prelude::CoreError::FeatureNotEnabled::feature: alloc::string::String
pub numrs2::error::prelude::CoreError::FeatureNotEnabled::feature_flag: alloc::string::String
pub numrs2::error::prelude::CoreError::IndexOutOfBounds
pub numrs2::error::prelude::CoreError::IndexOutOfBounds::axis: usize
pub numrs2::error::prelude::CoreError::IndexOutOfBounds::context: numrs2::error::OperationContext
pub numrs2::error::prelude::CoreError::IndexOutOfBounds::index: isize
pub numrs2::error::prelude::CoreError::IndexOutOfBounds::size: usize
pub numrs2::error::prelude::CoreError::InvalidAxis
pub numrs2::error::prelude::CoreError::InvalidAxis::axis: isize
pub numrs2::error::prelude::CoreError::InvalidAxis::context: numrs2::error::OperationContext
pub numrs2::error::prelude::CoreError::InvalidAxis::ndim: usize
pub numrs2::error::prelude::CoreError::InvalidOperation
pub numrs2::error::prelude::CoreError::InvalidOperation::context: numrs2::error::OperationContext
pub numrs2::error::prelude::CoreError::InvalidOperation::operation: alloc::string::String
pub numrs2::error::prelude::CoreError::InvalidOperation::reason: alloc::string::String
pub numrs2::error::prelude::CoreError::NotImplemented
pub numrs2::error::prelude::CoreError::NotImplemented::alternative: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::CoreError::NotImplemented::context: numrs2::error::OperationContext
pub numrs2::error::prelude::CoreError::NotImplemented::feature: alloc::string::String
pub numrs2::error::prelude::CoreError::NotImplemented::planned_version: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::CoreError::ShapeMismatch
pub numrs2::error::prelude::CoreError::ShapeMismatch::actual: alloc::vec::Vec<usize>
pub numrs2::error::prelude::CoreError::ShapeMismatch::context: numrs2::error::OperationContext
pub numrs2::error::prelude::CoreError::ShapeMismatch::expected: alloc::vec::Vec<usize>
pub numrs2::error::prelude::CoreError::StrideError
pub numrs2::error::prelude::CoreError::StrideError::actual_strides: core::option::Option<alloc::vec::Vec<isize>>
pub numrs2::error::prelude::CoreError::StrideError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::CoreError::StrideError::expected_strides: core::option::Option<alloc::vec::Vec<isize>>
pub numrs2::error::prelude::CoreError::StrideError::message: alloc::string::String
pub numrs2::error::prelude::CoreError::TypeConversion
pub numrs2::error::prelude::CoreError::TypeConversion::context: numrs2::error::OperationContext
pub numrs2::error::prelude::CoreError::TypeConversion::from_type: alloc::string::String
pub numrs2::error::prelude::CoreError::TypeConversion::reason: alloc::string::String
pub numrs2::error::prelude::CoreError::TypeConversion::to_type: alloc::string::String
pub numrs2::error::prelude::CoreError::ValueError
pub numrs2::error::prelude::CoreError::ValueError::actual_value: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::CoreError::ValueError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::CoreError::ValueError::expected_range: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::CoreError::ValueError::message: alloc::string::String
pub numrs2::error::prelude::CoreError::ViewError
pub numrs2::error::prelude::CoreError::ViewError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::CoreError::ViewError::message: alloc::string::String
pub numrs2::error::prelude::CoreError::ViewError::view_type: alloc::string::String
impl numrs2::error::CoreError
pub fn numrs2::error::CoreError::broadcast_error(shape1: alloc::vec::Vec<usize>, shape2: alloc::vec::Vec<usize>, operation: &str) -> Self
pub fn numrs2::error::CoreError::dimension_mismatch(message: &str, expected: core::option::Option<usize>, actual: core::option::Option<usize>) -> Self
pub fn numrs2::error::CoreError::feature_not_enabled(feature: &str, feature_flag: &str) -> Self
pub fn numrs2::error::CoreError::index_out_of_bounds(index: isize, axis: usize, size: usize, operation: &str) -> Self
pub fn numrs2::error::CoreError::invalid_operation(operation: &str, reason: &str) -> Self
pub fn numrs2::error::CoreError::not_implemented(feature: &str) -> Self
pub fn numrs2::error::CoreError::shape_mismatch(expected: alloc::vec::Vec<usize>, actual: alloc::vec::Vec<usize>, operation: &str) -> Self
impl numrs2::error::CoreError
pub fn numrs2::error::CoreError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::CoreError::is_programming_error(&self) -> bool
pub fn numrs2::error::CoreError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::CoreError::severity(&self) -> numrs2::error::ErrorSeverity
pub enum numrs2::error::prelude::ErrorCategory
pub numrs2::error::prelude::ErrorCategory::Computation
pub numrs2::error::prelude::ErrorCategory::Core
pub numrs2::error::prelude::ErrorCategory::IO
pub numrs2::error::prelude::ErrorCategory::Memory
impl core::fmt::Display for numrs2::error::ErrorCategory
pub fn numrs2::error::ErrorCategory::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub enum numrs2::error::prelude::ErrorSeverity
pub numrs2::error::prelude::ErrorSeverity::Critical
pub numrs2::error::prelude::ErrorSeverity::High
pub numrs2::error::prelude::ErrorSeverity::Low
pub numrs2::error::prelude::ErrorSeverity::Medium
impl core::fmt::Display for numrs2::error::ErrorSeverity
pub fn numrs2::error::ErrorSeverity::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub enum numrs2::error::prelude::IOError
pub numrs2::error::prelude::IOError::AccessDenied
pub numrs2::error::prelude::IOError::AccessDenied::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::AccessDenied::operation: alloc::string::String
pub numrs2::error::prelude::IOError::AccessDenied::reason: alloc::string::String
pub numrs2::error::prelude::IOError::AccessDenied::required_permissions: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::IOError::AccessDenied::resource: alloc::string::String
pub numrs2::error::prelude::IOError::Compression
pub numrs2::error::prelude::IOError::Compression::algorithm: alloc::string::String
pub numrs2::error::prelude::IOError::Compression::compression_ratio: core::option::Option<f64>
pub numrs2::error::prelude::IOError::Compression::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::Compression::reason: alloc::string::String
pub numrs2::error::prelude::IOError::Database
pub numrs2::error::prelude::IOError::Database::connection_string: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::IOError::Database::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::Database::database_type: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::IOError::Database::operation: alloc::string::String
pub numrs2::error::prelude::IOError::Database::reason: alloc::string::String
pub numrs2::error::prelude::IOError::Deserialization
pub numrs2::error::prelude::IOError::Deserialization::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::Deserialization::data_size: core::option::Option<usize>
pub numrs2::error::prelude::IOError::Deserialization::file_path: core::option::Option<std::path::PathBuf>
pub numrs2::error::prelude::IOError::Deserialization::format: alloc::string::String
pub numrs2::error::prelude::IOError::Deserialization::reason: alloc::string::String
pub numrs2::error::prelude::IOError::Encoding
pub numrs2::error::prelude::IOError::Encoding::byte_position: core::option::Option<usize>
pub numrs2::error::prelude::IOError::Encoding::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::Encoding::details: alloc::string::String
pub numrs2::error::prelude::IOError::Encoding::encoding: alloc::string::String
pub numrs2::error::prelude::IOError::FileOperation
pub numrs2::error::prelude::IOError::FileOperation::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::FileOperation::io_error_kind: core::option::Option<std::io::error::ErrorKind>
pub numrs2::error::prelude::IOError::FileOperation::operation: alloc::string::String
pub numrs2::error::prelude::IOError::FileOperation::path: std::path::PathBuf
pub numrs2::error::prelude::IOError::FileOperation::reason: alloc::string::String
pub numrs2::error::prelude::IOError::InvalidFormat
pub numrs2::error::prelude::IOError::InvalidFormat::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::InvalidFormat::details: alloc::string::String
pub numrs2::error::prelude::IOError::InvalidFormat::expected_format: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::IOError::InvalidFormat::file_path: core::option::Option<std::path::PathBuf>
pub numrs2::error::prelude::IOError::InvalidFormat::format: alloc::string::String
pub numrs2::error::prelude::IOError::MemoryMapping
pub numrs2::error::prelude::IOError::MemoryMapping::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::MemoryMapping::file_path: std::path::PathBuf
pub numrs2::error::prelude::IOError::MemoryMapping::mapping_size: core::option::Option<usize>
pub numrs2::error::prelude::IOError::MemoryMapping::offset: core::option::Option<usize>
pub numrs2::error::prelude::IOError::MemoryMapping::reason: alloc::string::String
pub numrs2::error::prelude::IOError::Network
pub numrs2::error::prelude::IOError::Network::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::Network::operation: alloc::string::String
pub numrs2::error::prelude::IOError::Network::reason: alloc::string::String
pub numrs2::error::prelude::IOError::Network::status_code: core::option::Option<u16>
pub numrs2::error::prelude::IOError::Network::url: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::IOError::Serialization
pub numrs2::error::prelude::IOError::Serialization::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::Serialization::data_type: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::IOError::Serialization::format: alloc::string::String
pub numrs2::error::prelude::IOError::Serialization::reason: alloc::string::String
pub numrs2::error::prelude::IOError::Stream
pub numrs2::error::prelude::IOError::Stream::bytes_processed: core::option::Option<usize>
pub numrs2::error::prelude::IOError::Stream::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::Stream::reason: alloc::string::String
pub numrs2::error::prelude::IOError::Stream::stream_type: alloc::string::String
pub numrs2::error::prelude::IOError::TemporaryResource
pub numrs2::error::prelude::IOError::TemporaryResource::cleanup_attempted: bool
pub numrs2::error::prelude::IOError::TemporaryResource::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::TemporaryResource::reason: alloc::string::String
pub numrs2::error::prelude::IOError::TemporaryResource::resource_type: alloc::string::String
pub numrs2::error::prelude::IOError::Validation
pub numrs2::error::prelude::IOError::Validation::actual_value: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::IOError::Validation::context: numrs2::error::OperationContext
pub numrs2::error::prelude::IOError::Validation::details: alloc::string::String
pub numrs2::error::prelude::IOError::Validation::expected_value: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::IOError::Validation::validation_type: alloc::string::String
impl numrs2::error::IOError
pub fn numrs2::error::IOError::access_denied(operation: &str, resource: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::deserialization(format: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::file_operation(operation: &str, path: std::path::PathBuf, reason: &str) -> Self
pub fn numrs2::error::IOError::invalid_format(format: &str, details: &str) -> Self
pub fn numrs2::error::IOError::network(operation: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::serialization(format: &str, reason: &str) -> Self
impl numrs2::error::IOError
pub fn numrs2::error::IOError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::IOError::is_transient(&self) -> bool
pub fn numrs2::error::IOError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::IOError::severity(&self) -> numrs2::error::ErrorSeverity
impl core::convert::From<std::io::error::Error> for numrs2::error::IOError
pub fn numrs2::error::IOError::from(err: std::io::error::Error) -> Self
pub enum numrs2::error::prelude::MemoryError
pub numrs2::error::prelude::MemoryError::AlignmentError
pub numrs2::error::prelude::MemoryError::AlignmentError::actual_alignment: core::option::Option<usize>
pub numrs2::error::prelude::MemoryError::AlignmentError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::MemoryError::AlignmentError::reason: alloc::string::String
pub numrs2::error::prelude::MemoryError::AlignmentError::required_alignment: usize
pub numrs2::error::prelude::MemoryError::AllocationFailed
pub numrs2::error::prelude::MemoryError::AllocationFailed::allocator_type: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::MemoryError::AllocationFailed::available_bytes: core::option::Option<usize>
pub numrs2::error::prelude::MemoryError::AllocationFailed::context: numrs2::error::OperationContext
pub numrs2::error::prelude::MemoryError::AllocationFailed::reason: alloc::string::String
pub numrs2::error::prelude::MemoryError::AllocationFailed::requested_bytes: usize
pub numrs2::error::prelude::MemoryError::ArenaOverflow
pub numrs2::error::prelude::MemoryError::ArenaOverflow::arena_size: usize
pub numrs2::error::prelude::MemoryError::ArenaOverflow::context: numrs2::error::OperationContext
pub numrs2::error::prelude::MemoryError::ArenaOverflow::remaining_bytes: usize
pub numrs2::error::prelude::MemoryError::ArenaOverflow::requested_bytes: usize
pub numrs2::error::prelude::MemoryError::Fragmentation
pub numrs2::error::prelude::MemoryError::Fragmentation::context: numrs2::error::OperationContext
pub numrs2::error::prelude::MemoryError::Fragmentation::fragmentation_level: f64
pub numrs2::error::prelude::MemoryError::Fragmentation::largest_free_block: core::option::Option<usize>
pub numrs2::error::prelude::MemoryError::Fragmentation::reason: alloc::string::String
pub numrs2::error::prelude::MemoryError::GpuMemoryError
pub numrs2::error::prelude::MemoryError::GpuMemoryError::available_bytes: core::option::Option<usize>
pub numrs2::error::prelude::MemoryError::GpuMemoryError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::MemoryError::GpuMemoryError::device_id: core::option::Option<usize>
pub numrs2::error::prelude::MemoryError::GpuMemoryError::reason: alloc::string::String
pub numrs2::error::prelude::MemoryError::GpuMemoryError::requested_bytes: core::option::Option<usize>
pub numrs2::error::prelude::MemoryError::InvalidAccess
pub numrs2::error::prelude::MemoryError::InvalidAccess::access_type: numrs2::error::AccessType
pub numrs2::error::prelude::MemoryError::InvalidAccess::address: core::option::Option<usize>
pub numrs2::error::prelude::MemoryError::InvalidAccess::context: numrs2::error::OperationContext
pub numrs2::error::prelude::MemoryError::InvalidAccess::reason: alloc::string::String
pub numrs2::error::prelude::MemoryError::InvalidAccess::valid_range: core::option::Option<(usize, usize)>
pub numrs2::error::prelude::MemoryError::MappingError
pub numrs2::error::prelude::MemoryError::MappingError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::MemoryError::MappingError::file_path: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::MemoryError::MappingError::mapping_size: core::option::Option<usize>
pub numrs2::error::prelude::MemoryError::MappingError::reason: alloc::string::String
pub numrs2::error::prelude::MemoryError::MemoryCorruption
pub numrs2::error::prelude::MemoryError::MemoryCorruption::affected_range: core::option::Option<(usize, usize)>
pub numrs2::error::prelude::MemoryError::MemoryCorruption::context: numrs2::error::OperationContext
pub numrs2::error::prelude::MemoryError::MemoryCorruption::corruption_type: numrs2::error::CorruptionType
pub numrs2::error::prelude::MemoryError::MemoryCorruption::details: alloc::string::String
pub numrs2::error::prelude::MemoryError::MemoryLeak
pub numrs2::error::prelude::MemoryError::MemoryLeak::allocation_source: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::MemoryError::MemoryLeak::context: numrs2::error::OperationContext
pub numrs2::error::prelude::MemoryError::MemoryLeak::details: alloc::string::String
pub numrs2::error::prelude::MemoryError::MemoryLeak::leaked_bytes: usize
pub numrs2::error::prelude::MemoryError::NumaError
pub numrs2::error::prelude::MemoryError::NumaError::context: numrs2::error::OperationContext
pub numrs2::error::prelude::MemoryError::NumaError::numa_node: core::option::Option<usize>
pub numrs2::error::prelude::MemoryError::NumaError::preferred_node: core::option::Option<usize>
pub numrs2::error::prelude::MemoryError::NumaError::reason: alloc::string::String
pub numrs2::error::prelude::MemoryError::OutOfMemory
pub numrs2::error::prelude::MemoryError::OutOfMemory::context: numrs2::error::OperationContext
pub numrs2::error::prelude::MemoryError::OutOfMemory::details: alloc::string::String
pub numrs2::error::prelude::MemoryError::OutOfMemory::process_limit: core::option::Option<usize>
pub numrs2::error::prelude::MemoryError::OutOfMemory::system_available: core::option::Option<usize>
pub numrs2::error::prelude::MemoryError::OutOfMemory::total_requested: usize
pub numrs2::error::prelude::MemoryError::PoolExhausted
pub numrs2::error::prelude::MemoryError::PoolExhausted::allocated_blocks: usize
pub numrs2::error::prelude::MemoryError::PoolExhausted::block_size: usize
pub numrs2::error::prelude::MemoryError::PoolExhausted::context: numrs2::error::OperationContext
pub numrs2::error::prelude::MemoryError::PoolExhausted::pool_size: usize
pub numrs2::error::prelude::MemoryError::PoolExhausted::pool_type: alloc::string::String
impl numrs2::error::MemoryError
pub fn numrs2::error::MemoryError::alignment_error(reason: &str, required_alignment: usize) -> Self
pub fn numrs2::error::MemoryError::allocation_failed(reason: &str, requested_bytes: usize) -> Self
pub fn numrs2::error::MemoryError::arena_overflow(requested_bytes: usize, remaining_bytes: usize, arena_size: usize) -> Self
pub fn numrs2::error::MemoryError::gpu_memory_error(reason: &str, device_id: core::option::Option<usize>) -> Self
pub fn numrs2::error::MemoryError::memory_corruption(details: &str, corruption_type: numrs2::error::CorruptionType) -> Self
pub fn numrs2::error::MemoryError::out_of_memory(details: &str, total_requested: usize) -> Self
pub fn numrs2::error::MemoryError::pool_exhausted(pool_type: &str, pool_size: usize, block_size: usize) -> Self
impl numrs2::error::MemoryError
pub fn numrs2::error::MemoryError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::MemoryError::is_transient(&self) -> bool
pub fn numrs2::error::MemoryError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::MemoryError::severity(&self) -> numrs2::error::ErrorSeverity
pub enum numrs2::error::prelude::NumRs2Error
pub numrs2::error::prelude::NumRs2Error::AllocationFailed(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::BlasError(i32)
pub numrs2::error::prelude::NumRs2Error::Computation(numrs2::error::ComputationError)
pub numrs2::error::prelude::NumRs2Error::ComputationError(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::ConversionError(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::Core(numrs2::error::CoreError)
pub numrs2::error::prelude::NumRs2Error::DeserializationError(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::DimensionMismatch(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::FeatureNotEnabled(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::IO(numrs2::error::IOError)
pub numrs2::error::prelude::NumRs2Error::IOError(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::IndexError(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::IndexOutOfBounds(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::InvalidOperation(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::LapackError(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::Memory(numrs2::error::MemoryError)
pub numrs2::error::prelude::NumRs2Error::NotImplemented(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::RuntimeError(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::SerializationError(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::ShapeMismatch
pub numrs2::error::prelude::NumRs2Error::ShapeMismatch::actual: alloc::vec::Vec<usize>
pub numrs2::error::prelude::NumRs2Error::ShapeMismatch::expected: alloc::vec::Vec<usize>
pub numrs2::error::prelude::NumRs2Error::TypeCastError(alloc::string::String)
pub numrs2::error::prelude::NumRs2Error::ValueError(alloc::string::String)
impl numrs2::NumRs2Error
pub fn numrs2::NumRs2Error::at_location(self, location: numrs2::error::ErrorLocation) -> numrs2::error::ErrorContext<Self>
pub fn numrs2::NumRs2Error::category(&self) -> numrs2::error::ErrorCategory
pub fn numrs2::NumRs2Error::is_recoverable(&self) -> bool
pub fn numrs2::NumRs2Error::severity(&self) -> numrs2::error::ErrorSeverity
pub fn numrs2::NumRs2Error::with_context<C: core::convert::Into<numrs2::error::OperationContext>>(self, context: C) -> numrs2::error::ErrorContext<Self>
impl core::convert::From<std::io::error::Error> for numrs2::NumRs2Error
pub fn numrs2::NumRs2Error::from(err: std::io::error::Error) -> Self
pub struct numrs2::error::prelude::ErrorContext<E>
impl<E> numrs2::error::ErrorContext<E>
pub fn numrs2::error::ErrorContext<E>::chain(&self) -> &[alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>]
pub fn numrs2::error::ErrorContext<E>::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::ErrorContext<E>::error(&self) -> &E
pub fn numrs2::error::ErrorContext<E>::into_inner(self) -> E
pub fn numrs2::error::ErrorContext<E>::location(&self) -> core::option::Option<&numrs2::error::ErrorLocation>
pub fn numrs2::error::ErrorContext<E>::new(error: E, context: numrs2::error::OperationContext) -> Self
pub fn numrs2::error::ErrorContext<E>::recovery_suggestions(&self) -> &[alloc::string::String]
pub fn numrs2::error::ErrorContext<E>::with_location(self, location: numrs2::error::ErrorLocation) -> Self
pub fn numrs2::error::ErrorContext<E>::with_source<S>(self, source: S) -> Self where S: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::error::ErrorContext<E>::with_suggestion(self, suggestion: &str) -> Self
impl<E: core::error::Error + 'static> core::error::Error for numrs2::error::ErrorContext<E>
pub fn numrs2::error::ErrorContext<E>::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl<E: core::fmt::Display> core::fmt::Display for numrs2::error::ErrorContext<E>
pub fn numrs2::error::ErrorContext<E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::error::prelude::ErrorLocation
pub numrs2::error::prelude::ErrorLocation::file: alloc::string::String
pub numrs2::error::prelude::ErrorLocation::function: alloc::string::String
pub numrs2::error::prelude::ErrorLocation::line: u32
pub numrs2::error::prelude::ErrorLocation::module_path: core::option::Option<alloc::string::String>
impl numrs2::error::ErrorLocation
pub fn numrs2::error::ErrorLocation::new(file: &str, line: u32, function: &str) -> Self
pub fn numrs2::error::ErrorLocation::with_module(file: &str, line: u32, function: &str, module_path: &str) -> Self
impl core::fmt::Display for numrs2::error::ErrorLocation
pub fn numrs2::error::ErrorLocation::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::error::prelude::OperationContext
pub numrs2::error::prelude::OperationContext::dtypes: alloc::vec::Vec<alloc::string::String>
pub numrs2::error::prelude::OperationContext::memory_info: core::option::Option<numrs2::error::MemoryInfo>
pub numrs2::error::prelude::OperationContext::operation: core::option::Option<alloc::string::String>
pub numrs2::error::prelude::OperationContext::parameters: std::collections::hash::map::HashMap<alloc::string::String, alloc::string::String>
pub numrs2::error::prelude::OperationContext::performance_hints: alloc::vec::Vec<alloc::string::String>
pub numrs2::error::prelude::OperationContext::shapes: alloc::vec::Vec<alloc::vec::Vec<usize>>
pub numrs2::error::prelude::OperationContext::thread_info: core::option::Option<numrs2::error::ThreadInfo>
pub numrs2::error::prelude::OperationContext::timestamp: u64
impl numrs2::error::OperationContext
pub fn numrs2::error::OperationContext::new(operation: &str) -> Self
pub fn numrs2::error::OperationContext::with_dtype(self, dtype: &str) -> Self
pub fn numrs2::error::OperationContext::with_memory_info(self, memory_info: numrs2::error::MemoryInfo) -> Self
pub fn numrs2::error::OperationContext::with_parameter<K, V>(self, key: K, value: V) -> Self where K: core::convert::Into<alloc::string::String>, V: core::fmt::Display
pub fn numrs2::error::OperationContext::with_performance_hint(self, hint: &str) -> Self
pub fn numrs2::error::OperationContext::with_shape(self, shape: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::error::OperationContext::with_shapes(self, shapes: &[alloc::vec::Vec<usize>]) -> Self
pub fn numrs2::error::OperationContext::with_thread_info(self, thread_info: numrs2::error::ThreadInfo) -> Self
impl core::default::Default for numrs2::error::OperationContext
pub fn numrs2::error::OperationContext::default() -> Self
pub type numrs2::error::prelude::ContextResult<T> = core::result::Result<T, numrs2::error::ErrorContext<numrs2::NumRs2Error>>
pub type numrs2::error::prelude::Result<T> = core::result::Result<T, numrs2::NumRs2Error>
pub enum numrs2::error::AccessType
pub numrs2::error::AccessType::Execute
pub numrs2::error::AccessType::Read
pub numrs2::error::AccessType::ReadWrite
pub numrs2::error::AccessType::Write
pub enum numrs2::error::ComputationError
pub enum numrs2::error::ComputationError
pub numrs2::error::ComputationError::ConvergenceFailure
pub numrs2::error::ComputationError::ConvergenceFailure
pub numrs2::error::ComputationError::ConvergenceFailure::algorithm: alloc::string::String
pub numrs2::error::ComputationError::ConvergenceFailure::algorithm: alloc::string::String
pub numrs2::error::ComputationError::ConvergenceFailure::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::ConvergenceFailure::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::ConvergenceFailure::iterations: usize
pub numrs2::error::ComputationError::ConvergenceFailure::iterations: usize
pub numrs2::error::ComputationError::ConvergenceFailure::reason: alloc::string::String
pub numrs2::error::ComputationError::ConvergenceFailure::reason: alloc::string::String
pub numrs2::error::ComputationError::ConvergenceFailure::residual: core::option::Option<f64>
pub numrs2::error::ComputationError::ConvergenceFailure::residual: core::option::Option<f64>
pub numrs2::error::ComputationError::ConvergenceFailure::tolerance: core::option::Option<f64>
pub numrs2::error::ComputationError::ConvergenceFailure::tolerance: core::option::Option<f64>
pub numrs2::error::ComputationError::EigenvalueError
pub numrs2::error::ComputationError::EigenvalueError
pub numrs2::error::ComputationError::EigenvalueError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::EigenvalueError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::EigenvalueError::matrix_properties: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::EigenvalueError::matrix_properties: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::EigenvalueError::operation: alloc::string::String
pub numrs2::error::ComputationError::EigenvalueError::operation: alloc::string::String
pub numrs2::error::ComputationError::EigenvalueError::reason: alloc::string::String
pub numrs2::error::ComputationError::EigenvalueError::reason: alloc::string::String
pub numrs2::error::ComputationError::FFTError
pub numrs2::error::ComputationError::FFTError
pub numrs2::error::ComputationError::FFTError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::FFTError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::FFTError::reason: alloc::string::String
pub numrs2::error::ComputationError::FFTError::reason: alloc::string::String
pub numrs2::error::ComputationError::FFTError::signal_length: usize
pub numrs2::error::ComputationError::FFTError::signal_length: usize
pub numrs2::error::ComputationError::FFTError::transform_type: alloc::string::String
pub numrs2::error::ComputationError::FFTError::transform_type: alloc::string::String
pub numrs2::error::ComputationError::IntegrationError
pub numrs2::error::ComputationError::IntegrationError
pub numrs2::error::ComputationError::IntegrationError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::IntegrationError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::IntegrationError::error_estimate: core::option::Option<f64>
pub numrs2::error::ComputationError::IntegrationError::error_estimate: core::option::Option<f64>
pub numrs2::error::ComputationError::IntegrationError::method: alloc::string::String
pub numrs2::error::ComputationError::IntegrationError::method: alloc::string::String
pub numrs2::error::ComputationError::IntegrationError::reason: alloc::string::String
pub numrs2::error::ComputationError::IntegrationError::reason: alloc::string::String
pub numrs2::error::ComputationError::IntegrationError::step_size: core::option::Option<f64>
pub numrs2::error::ComputationError::IntegrationError::step_size: core::option::Option<f64>
pub numrs2::error::ComputationError::InterpolationError
pub numrs2::error::ComputationError::InterpolationError
pub numrs2::error::ComputationError::InterpolationError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::InterpolationError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::InterpolationError::data_points: usize
pub numrs2::error::ComputationError::InterpolationError::data_points: usize
pub numrs2::error::ComputationError::InterpolationError::method: alloc::string::String
pub numrs2::error::ComputationError::InterpolationError::method: alloc::string::String
pub numrs2::error::ComputationError::InterpolationError::reason: alloc::string::String
pub numrs2::error::ComputationError::InterpolationError::reason: alloc::string::String
pub numrs2::error::ComputationError::InvalidMathOperation
pub numrs2::error::ComputationError::InvalidMathOperation
pub numrs2::error::ComputationError::InvalidMathOperation::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::InvalidMathOperation::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::InvalidMathOperation::operation: alloc::string::String
pub numrs2::error::ComputationError::InvalidMathOperation::operation: alloc::string::String
pub numrs2::error::ComputationError::InvalidMathOperation::reason: alloc::string::String
pub numrs2::error::ComputationError::InvalidMathOperation::reason: alloc::string::String
pub numrs2::error::ComputationError::InvalidMathOperation::suggested_alternative: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::InvalidMathOperation::suggested_alternative: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::LinearAlgebraLibraryError
pub numrs2::error::ComputationError::LinearAlgebraLibraryError
pub numrs2::error::ComputationError::LinearAlgebraLibraryError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::LinearAlgebraLibraryError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::LinearAlgebraLibraryError::details: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::LinearAlgebraLibraryError::details: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::LinearAlgebraLibraryError::error_code: i32
pub numrs2::error::ComputationError::LinearAlgebraLibraryError::error_code: i32
pub numrs2::error::ComputationError::LinearAlgebraLibraryError::library: alloc::string::String
pub numrs2::error::ComputationError::LinearAlgebraLibraryError::library: alloc::string::String
pub numrs2::error::ComputationError::LinearAlgebraLibraryError::operation: alloc::string::String
pub numrs2::error::ComputationError::LinearAlgebraLibraryError::operation: alloc::string::String
pub numrs2::error::ComputationError::NumericalInstability
pub numrs2::error::ComputationError::NumericalInstability
pub numrs2::error::ComputationError::NumericalInstability::condition_number: core::option::Option<f64>
pub numrs2::error::ComputationError::NumericalInstability::condition_number: core::option::Option<f64>
pub numrs2::error::ComputationError::NumericalInstability::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::NumericalInstability::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::NumericalInstability::details: alloc::string::String
pub numrs2::error::ComputationError::NumericalInstability::details: alloc::string::String
pub numrs2::error::ComputationError::NumericalInstability::operation: alloc::string::String
pub numrs2::error::ComputationError::NumericalInstability::operation: alloc::string::String
pub numrs2::error::ComputationError::OptimizationError
pub numrs2::error::ComputationError::OptimizationError
pub numrs2::error::ComputationError::OptimizationError::algorithm: alloc::string::String
pub numrs2::error::ComputationError::OptimizationError::algorithm: alloc::string::String
pub numrs2::error::ComputationError::OptimizationError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::OptimizationError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::OptimizationError::gradient_norm: core::option::Option<f64>
pub numrs2::error::ComputationError::OptimizationError::gradient_norm: core::option::Option<f64>
pub numrs2::error::ComputationError::OptimizationError::objective_value: core::option::Option<f64>
pub numrs2::error::ComputationError::OptimizationError::objective_value: core::option::Option<f64>
pub numrs2::error::ComputationError::OptimizationError::reason: alloc::string::String
pub numrs2::error::ComputationError::OptimizationError::reason: alloc::string::String
pub numrs2::error::ComputationError::Overflow
pub numrs2::error::ComputationError::Overflow
pub numrs2::error::ComputationError::Overflow::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::Overflow::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::Overflow::details: alloc::string::String
pub numrs2::error::ComputationError::Overflow::details: alloc::string::String
pub numrs2::error::ComputationError::Overflow::operation: alloc::string::String
pub numrs2::error::ComputationError::Overflow::operation: alloc::string::String
pub numrs2::error::ComputationError::Overflow::value: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::Overflow::value: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::RandomGenerationError
pub numrs2::error::ComputationError::RandomGenerationError
pub numrs2::error::ComputationError::RandomGenerationError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::RandomGenerationError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::RandomGenerationError::distribution: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::RandomGenerationError::distribution: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::RandomGenerationError::parameters: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::RandomGenerationError::parameters: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::RandomGenerationError::reason: alloc::string::String
pub numrs2::error::ComputationError::RandomGenerationError::reason: alloc::string::String
pub numrs2::error::ComputationError::SVDError
pub numrs2::error::ComputationError::SVDError
pub numrs2::error::ComputationError::SVDError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::SVDError::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::SVDError::matrix_shape: alloc::vec::Vec<usize>
pub numrs2::error::ComputationError::SVDError::matrix_shape: alloc::vec::Vec<usize>
pub numrs2::error::ComputationError::SVDError::reason: alloc::string::String
pub numrs2::error::ComputationError::SVDError::reason: alloc::string::String
pub numrs2::error::ComputationError::SVDError::requested_components: core::option::Option<usize>
pub numrs2::error::ComputationError::SVDError::requested_components: core::option::Option<usize>
pub numrs2::error::ComputationError::SingularMatrix
pub numrs2::error::ComputationError::SingularMatrix
pub numrs2::error::ComputationError::SingularMatrix::condition_number: core::option::Option<f64>
pub numrs2::error::ComputationError::SingularMatrix::condition_number: core::option::Option<f64>
pub numrs2::error::ComputationError::SingularMatrix::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::SingularMatrix::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::SingularMatrix::expected_rank: core::option::Option<usize>
pub numrs2::error::ComputationError::SingularMatrix::expected_rank: core::option::Option<usize>
pub numrs2::error::ComputationError::SingularMatrix::operation: alloc::string::String
pub numrs2::error::ComputationError::SingularMatrix::operation: alloc::string::String
pub numrs2::error::ComputationError::SingularMatrix::rank: core::option::Option<usize>
pub numrs2::error::ComputationError::SingularMatrix::rank: core::option::Option<usize>
pub numrs2::error::ComputationError::Underflow
pub numrs2::error::ComputationError::Underflow
pub numrs2::error::ComputationError::Underflow::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::Underflow::context: numrs2::error::OperationContext
pub numrs2::error::ComputationError::Underflow::details: alloc::string::String
pub numrs2::error::ComputationError::Underflow::details: alloc::string::String
pub numrs2::error::ComputationError::Underflow::operation: alloc::string::String
pub numrs2::error::ComputationError::Underflow::operation: alloc::string::String
pub numrs2::error::ComputationError::Underflow::value: core::option::Option<alloc::string::String>
pub numrs2::error::ComputationError::Underflow::value: core::option::Option<alloc::string::String>
impl numrs2::error::ComputationError
impl numrs2::error::ComputationError
pub fn numrs2::error::ComputationError::blas_error(operation: &str, error_code: i32) -> Self
pub fn numrs2::error::ComputationError::blas_error(operation: &str, error_code: i32) -> Self
pub fn numrs2::error::ComputationError::convergence_failure(algorithm: &str, reason: &str, iterations: usize) -> Self
pub fn numrs2::error::ComputationError::convergence_failure(algorithm: &str, reason: &str, iterations: usize) -> Self
pub fn numrs2::error::ComputationError::fft_error(reason: &str, signal_length: usize, transform_type: &str) -> Self
pub fn numrs2::error::ComputationError::fft_error(reason: &str, signal_length: usize, transform_type: &str) -> Self
pub fn numrs2::error::ComputationError::lapack_error(operation: &str, error_code: i32) -> Self
pub fn numrs2::error::ComputationError::lapack_error(operation: &str, error_code: i32) -> Self
pub fn numrs2::error::ComputationError::numerical_instability(operation: &str, details: &str) -> Self
pub fn numrs2::error::ComputationError::numerical_instability(operation: &str, details: &str) -> Self
pub fn numrs2::error::ComputationError::overflow(operation: &str, details: &str) -> Self
pub fn numrs2::error::ComputationError::overflow(operation: &str, details: &str) -> Self
pub fn numrs2::error::ComputationError::singular_matrix(operation: &str) -> Self
pub fn numrs2::error::ComputationError::singular_matrix(operation: &str) -> Self
impl numrs2::error::ComputationError
impl numrs2::error::ComputationError
pub fn numrs2::error::ComputationError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::ComputationError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::ComputationError::is_potentially_recoverable(&self) -> bool
pub fn numrs2::error::ComputationError::is_potentially_recoverable(&self) -> bool
pub fn numrs2::error::ComputationError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::ComputationError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::ComputationError::severity(&self) -> numrs2::error::ErrorSeverity
pub fn numrs2::error::ComputationError::severity(&self) -> numrs2::error::ErrorSeverity
pub enum numrs2::error::CoreError
pub enum numrs2::error::CoreError
pub numrs2::error::CoreError::BroadcastError
pub numrs2::error::CoreError::BroadcastError
pub numrs2::error::CoreError::BroadcastError::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::BroadcastError::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::BroadcastError::shape1: alloc::vec::Vec<usize>
pub numrs2::error::CoreError::BroadcastError::shape1: alloc::vec::Vec<usize>
pub numrs2::error::CoreError::BroadcastError::shape2: alloc::vec::Vec<usize>
pub numrs2::error::CoreError::BroadcastError::shape2: alloc::vec::Vec<usize>
pub numrs2::error::CoreError::DimensionMismatch
pub numrs2::error::CoreError::DimensionMismatch
pub numrs2::error::CoreError::DimensionMismatch::actual_dims: core::option::Option<usize>
pub numrs2::error::CoreError::DimensionMismatch::actual_dims: core::option::Option<usize>
pub numrs2::error::CoreError::DimensionMismatch::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::DimensionMismatch::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::DimensionMismatch::expected_dims: core::option::Option<usize>
pub numrs2::error::CoreError::DimensionMismatch::expected_dims: core::option::Option<usize>
pub numrs2::error::CoreError::DimensionMismatch::message: alloc::string::String
pub numrs2::error::CoreError::DimensionMismatch::message: alloc::string::String
pub numrs2::error::CoreError::FeatureNotEnabled
pub numrs2::error::CoreError::FeatureNotEnabled
pub numrs2::error::CoreError::FeatureNotEnabled::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::FeatureNotEnabled::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::FeatureNotEnabled::feature: alloc::string::String
pub numrs2::error::CoreError::FeatureNotEnabled::feature: alloc::string::String
pub numrs2::error::CoreError::FeatureNotEnabled::feature_flag: alloc::string::String
pub numrs2::error::CoreError::FeatureNotEnabled::feature_flag: alloc::string::String
pub numrs2::error::CoreError::IndexOutOfBounds
pub numrs2::error::CoreError::IndexOutOfBounds
pub numrs2::error::CoreError::IndexOutOfBounds::axis: usize
pub numrs2::error::CoreError::IndexOutOfBounds::axis: usize
pub numrs2::error::CoreError::IndexOutOfBounds::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::IndexOutOfBounds::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::IndexOutOfBounds::index: isize
pub numrs2::error::CoreError::IndexOutOfBounds::index: isize
pub numrs2::error::CoreError::IndexOutOfBounds::size: usize
pub numrs2::error::CoreError::IndexOutOfBounds::size: usize
pub numrs2::error::CoreError::InvalidAxis
pub numrs2::error::CoreError::InvalidAxis
pub numrs2::error::CoreError::InvalidAxis::axis: isize
pub numrs2::error::CoreError::InvalidAxis::axis: isize
pub numrs2::error::CoreError::InvalidAxis::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::InvalidAxis::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::InvalidAxis::ndim: usize
pub numrs2::error::CoreError::InvalidAxis::ndim: usize
pub numrs2::error::CoreError::InvalidOperation
pub numrs2::error::CoreError::InvalidOperation
pub numrs2::error::CoreError::InvalidOperation::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::InvalidOperation::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::InvalidOperation::operation: alloc::string::String
pub numrs2::error::CoreError::InvalidOperation::operation: alloc::string::String
pub numrs2::error::CoreError::InvalidOperation::reason: alloc::string::String
pub numrs2::error::CoreError::InvalidOperation::reason: alloc::string::String
pub numrs2::error::CoreError::NotImplemented
pub numrs2::error::CoreError::NotImplemented
pub numrs2::error::CoreError::NotImplemented::alternative: core::option::Option<alloc::string::String>
pub numrs2::error::CoreError::NotImplemented::alternative: core::option::Option<alloc::string::String>
pub numrs2::error::CoreError::NotImplemented::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::NotImplemented::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::NotImplemented::feature: alloc::string::String
pub numrs2::error::CoreError::NotImplemented::feature: alloc::string::String
pub numrs2::error::CoreError::NotImplemented::planned_version: core::option::Option<alloc::string::String>
pub numrs2::error::CoreError::NotImplemented::planned_version: core::option::Option<alloc::string::String>
pub numrs2::error::CoreError::ShapeMismatch
pub numrs2::error::CoreError::ShapeMismatch
pub numrs2::error::CoreError::ShapeMismatch::actual: alloc::vec::Vec<usize>
pub numrs2::error::CoreError::ShapeMismatch::actual: alloc::vec::Vec<usize>
pub numrs2::error::CoreError::ShapeMismatch::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::ShapeMismatch::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::ShapeMismatch::expected: alloc::vec::Vec<usize>
pub numrs2::error::CoreError::ShapeMismatch::expected: alloc::vec::Vec<usize>
pub numrs2::error::CoreError::StrideError
pub numrs2::error::CoreError::StrideError
pub numrs2::error::CoreError::StrideError::actual_strides: core::option::Option<alloc::vec::Vec<isize>>
pub numrs2::error::CoreError::StrideError::actual_strides: core::option::Option<alloc::vec::Vec<isize>>
pub numrs2::error::CoreError::StrideError::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::StrideError::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::StrideError::expected_strides: core::option::Option<alloc::vec::Vec<isize>>
pub numrs2::error::CoreError::StrideError::expected_strides: core::option::Option<alloc::vec::Vec<isize>>
pub numrs2::error::CoreError::StrideError::message: alloc::string::String
pub numrs2::error::CoreError::StrideError::message: alloc::string::String
pub numrs2::error::CoreError::TypeConversion
pub numrs2::error::CoreError::TypeConversion
pub numrs2::error::CoreError::TypeConversion::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::TypeConversion::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::TypeConversion::from_type: alloc::string::String
pub numrs2::error::CoreError::TypeConversion::from_type: alloc::string::String
pub numrs2::error::CoreError::TypeConversion::reason: alloc::string::String
pub numrs2::error::CoreError::TypeConversion::reason: alloc::string::String
pub numrs2::error::CoreError::TypeConversion::to_type: alloc::string::String
pub numrs2::error::CoreError::TypeConversion::to_type: alloc::string::String
pub numrs2::error::CoreError::ValueError
pub numrs2::error::CoreError::ValueError
pub numrs2::error::CoreError::ValueError::actual_value: core::option::Option<alloc::string::String>
pub numrs2::error::CoreError::ValueError::actual_value: core::option::Option<alloc::string::String>
pub numrs2::error::CoreError::ValueError::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::ValueError::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::ValueError::expected_range: core::option::Option<alloc::string::String>
pub numrs2::error::CoreError::ValueError::expected_range: core::option::Option<alloc::string::String>
pub numrs2::error::CoreError::ValueError::message: alloc::string::String
pub numrs2::error::CoreError::ValueError::message: alloc::string::String
pub numrs2::error::CoreError::ViewError
pub numrs2::error::CoreError::ViewError
pub numrs2::error::CoreError::ViewError::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::ViewError::context: numrs2::error::OperationContext
pub numrs2::error::CoreError::ViewError::message: alloc::string::String
pub numrs2::error::CoreError::ViewError::message: alloc::string::String
pub numrs2::error::CoreError::ViewError::view_type: alloc::string::String
pub numrs2::error::CoreError::ViewError::view_type: alloc::string::String
impl numrs2::error::CoreError
impl numrs2::error::CoreError
pub fn numrs2::error::CoreError::broadcast_error(shape1: alloc::vec::Vec<usize>, shape2: alloc::vec::Vec<usize>, operation: &str) -> Self
pub fn numrs2::error::CoreError::broadcast_error(shape1: alloc::vec::Vec<usize>, shape2: alloc::vec::Vec<usize>, operation: &str) -> Self
pub fn numrs2::error::CoreError::dimension_mismatch(message: &str, expected: core::option::Option<usize>, actual: core::option::Option<usize>) -> Self
pub fn numrs2::error::CoreError::dimension_mismatch(message: &str, expected: core::option::Option<usize>, actual: core::option::Option<usize>) -> Self
pub fn numrs2::error::CoreError::feature_not_enabled(feature: &str, feature_flag: &str) -> Self
pub fn numrs2::error::CoreError::feature_not_enabled(feature: &str, feature_flag: &str) -> Self
pub fn numrs2::error::CoreError::index_out_of_bounds(index: isize, axis: usize, size: usize, operation: &str) -> Self
pub fn numrs2::error::CoreError::index_out_of_bounds(index: isize, axis: usize, size: usize, operation: &str) -> Self
pub fn numrs2::error::CoreError::invalid_operation(operation: &str, reason: &str) -> Self
pub fn numrs2::error::CoreError::invalid_operation(operation: &str, reason: &str) -> Self
pub fn numrs2::error::CoreError::not_implemented(feature: &str) -> Self
pub fn numrs2::error::CoreError::not_implemented(feature: &str) -> Self
pub fn numrs2::error::CoreError::shape_mismatch(expected: alloc::vec::Vec<usize>, actual: alloc::vec::Vec<usize>, operation: &str) -> Self
pub fn numrs2::error::CoreError::shape_mismatch(expected: alloc::vec::Vec<usize>, actual: alloc::vec::Vec<usize>, operation: &str) -> Self
impl numrs2::error::CoreError
impl numrs2::error::CoreError
pub fn numrs2::error::CoreError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::CoreError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::CoreError::is_programming_error(&self) -> bool
pub fn numrs2::error::CoreError::is_programming_error(&self) -> bool
pub fn numrs2::error::CoreError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::CoreError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::CoreError::severity(&self) -> numrs2::error::ErrorSeverity
pub fn numrs2::error::CoreError::severity(&self) -> numrs2::error::ErrorSeverity
pub enum numrs2::error::CorruptionType
pub numrs2::error::CorruptionType::BufferOverflow
pub numrs2::error::CorruptionType::BufferUnderflow
pub numrs2::error::CorruptionType::DoubleFree
pub numrs2::error::CorruptionType::HeapCorruption
pub numrs2::error::CorruptionType::InvalidPointer
pub numrs2::error::CorruptionType::StackOverflow
pub numrs2::error::CorruptionType::UseAfterFree
pub enum numrs2::error::ErrorCategory
pub numrs2::error::ErrorCategory::Computation
pub numrs2::error::ErrorCategory::Core
pub numrs2::error::ErrorCategory::IO
pub numrs2::error::ErrorCategory::Memory
impl core::fmt::Display for numrs2::error::ErrorCategory
pub fn numrs2::error::ErrorCategory::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub enum numrs2::error::ErrorSeverity
pub enum numrs2::error::ErrorSeverity
pub numrs2::error::ErrorSeverity::Critical
pub numrs2::error::ErrorSeverity::Critical
pub numrs2::error::ErrorSeverity::High
pub numrs2::error::ErrorSeverity::High
pub numrs2::error::ErrorSeverity::Low
pub numrs2::error::ErrorSeverity::Low
pub numrs2::error::ErrorSeverity::Medium
pub numrs2::error::ErrorSeverity::Medium
impl core::fmt::Display for numrs2::error::ErrorSeverity
impl core::fmt::Display for numrs2::error::ErrorSeverity
pub fn numrs2::error::ErrorSeverity::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub fn numrs2::error::ErrorSeverity::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub enum numrs2::error::IOError
pub enum numrs2::error::IOError
pub numrs2::error::IOError::AccessDenied
pub numrs2::error::IOError::AccessDenied
pub numrs2::error::IOError::AccessDenied::context: numrs2::error::OperationContext
pub numrs2::error::IOError::AccessDenied::context: numrs2::error::OperationContext
pub numrs2::error::IOError::AccessDenied::operation: alloc::string::String
pub numrs2::error::IOError::AccessDenied::operation: alloc::string::String
pub numrs2::error::IOError::AccessDenied::reason: alloc::string::String
pub numrs2::error::IOError::AccessDenied::reason: alloc::string::String
pub numrs2::error::IOError::AccessDenied::required_permissions: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::AccessDenied::required_permissions: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::AccessDenied::resource: alloc::string::String
pub numrs2::error::IOError::AccessDenied::resource: alloc::string::String
pub numrs2::error::IOError::Compression
pub numrs2::error::IOError::Compression
pub numrs2::error::IOError::Compression::algorithm: alloc::string::String
pub numrs2::error::IOError::Compression::algorithm: alloc::string::String
pub numrs2::error::IOError::Compression::compression_ratio: core::option::Option<f64>
pub numrs2::error::IOError::Compression::compression_ratio: core::option::Option<f64>
pub numrs2::error::IOError::Compression::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Compression::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Compression::reason: alloc::string::String
pub numrs2::error::IOError::Compression::reason: alloc::string::String
pub numrs2::error::IOError::Database
pub numrs2::error::IOError::Database
pub numrs2::error::IOError::Database::connection_string: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::Database::connection_string: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::Database::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Database::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Database::database_type: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::Database::database_type: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::Database::operation: alloc::string::String
pub numrs2::error::IOError::Database::operation: alloc::string::String
pub numrs2::error::IOError::Database::reason: alloc::string::String
pub numrs2::error::IOError::Database::reason: alloc::string::String
pub numrs2::error::IOError::Deserialization
pub numrs2::error::IOError::Deserialization
pub numrs2::error::IOError::Deserialization::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Deserialization::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Deserialization::data_size: core::option::Option<usize>
pub numrs2::error::IOError::Deserialization::data_size: core::option::Option<usize>
pub numrs2::error::IOError::Deserialization::file_path: core::option::Option<std::path::PathBuf>
pub numrs2::error::IOError::Deserialization::file_path: core::option::Option<std::path::PathBuf>
pub numrs2::error::IOError::Deserialization::format: alloc::string::String
pub numrs2::error::IOError::Deserialization::format: alloc::string::String
pub numrs2::error::IOError::Deserialization::reason: alloc::string::String
pub numrs2::error::IOError::Deserialization::reason: alloc::string::String
pub numrs2::error::IOError::Encoding
pub numrs2::error::IOError::Encoding
pub numrs2::error::IOError::Encoding::byte_position: core::option::Option<usize>
pub numrs2::error::IOError::Encoding::byte_position: core::option::Option<usize>
pub numrs2::error::IOError::Encoding::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Encoding::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Encoding::details: alloc::string::String
pub numrs2::error::IOError::Encoding::details: alloc::string::String
pub numrs2::error::IOError::Encoding::encoding: alloc::string::String
pub numrs2::error::IOError::Encoding::encoding: alloc::string::String
pub numrs2::error::IOError::FileOperation
pub numrs2::error::IOError::FileOperation
pub numrs2::error::IOError::FileOperation::context: numrs2::error::OperationContext
pub numrs2::error::IOError::FileOperation::context: numrs2::error::OperationContext
pub numrs2::error::IOError::FileOperation::io_error_kind: core::option::Option<std::io::error::ErrorKind>
pub numrs2::error::IOError::FileOperation::io_error_kind: core::option::Option<std::io::error::ErrorKind>
pub numrs2::error::IOError::FileOperation::operation: alloc::string::String
pub numrs2::error::IOError::FileOperation::operation: alloc::string::String
pub numrs2::error::IOError::FileOperation::path: std::path::PathBuf
pub numrs2::error::IOError::FileOperation::path: std::path::PathBuf
pub numrs2::error::IOError::FileOperation::reason: alloc::string::String
pub numrs2::error::IOError::FileOperation::reason: alloc::string::String
pub numrs2::error::IOError::InvalidFormat
pub numrs2::error::IOError::InvalidFormat
pub numrs2::error::IOError::InvalidFormat::context: numrs2::error::OperationContext
pub numrs2::error::IOError::InvalidFormat::context: numrs2::error::OperationContext
pub numrs2::error::IOError::InvalidFormat::details: alloc::string::String
pub numrs2::error::IOError::InvalidFormat::details: alloc::string::String
pub numrs2::error::IOError::InvalidFormat::expected_format: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::InvalidFormat::expected_format: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::InvalidFormat::file_path: core::option::Option<std::path::PathBuf>
pub numrs2::error::IOError::InvalidFormat::file_path: core::option::Option<std::path::PathBuf>
pub numrs2::error::IOError::InvalidFormat::format: alloc::string::String
pub numrs2::error::IOError::InvalidFormat::format: alloc::string::String
pub numrs2::error::IOError::MemoryMapping
pub numrs2::error::IOError::MemoryMapping
pub numrs2::error::IOError::MemoryMapping::context: numrs2::error::OperationContext
pub numrs2::error::IOError::MemoryMapping::context: numrs2::error::OperationContext
pub numrs2::error::IOError::MemoryMapping::file_path: std::path::PathBuf
pub numrs2::error::IOError::MemoryMapping::file_path: std::path::PathBuf
pub numrs2::error::IOError::MemoryMapping::mapping_size: core::option::Option<usize>
pub numrs2::error::IOError::MemoryMapping::mapping_size: core::option::Option<usize>
pub numrs2::error::IOError::MemoryMapping::offset: core::option::Option<usize>
pub numrs2::error::IOError::MemoryMapping::offset: core::option::Option<usize>
pub numrs2::error::IOError::MemoryMapping::reason: alloc::string::String
pub numrs2::error::IOError::MemoryMapping::reason: alloc::string::String
pub numrs2::error::IOError::Network
pub numrs2::error::IOError::Network
pub numrs2::error::IOError::Network::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Network::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Network::operation: alloc::string::String
pub numrs2::error::IOError::Network::operation: alloc::string::String
pub numrs2::error::IOError::Network::reason: alloc::string::String
pub numrs2::error::IOError::Network::reason: alloc::string::String
pub numrs2::error::IOError::Network::status_code: core::option::Option<u16>
pub numrs2::error::IOError::Network::status_code: core::option::Option<u16>
pub numrs2::error::IOError::Network::url: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::Network::url: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::Serialization
pub numrs2::error::IOError::Serialization
pub numrs2::error::IOError::Serialization::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Serialization::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Serialization::data_type: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::Serialization::data_type: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::Serialization::format: alloc::string::String
pub numrs2::error::IOError::Serialization::format: alloc::string::String
pub numrs2::error::IOError::Serialization::reason: alloc::string::String
pub numrs2::error::IOError::Serialization::reason: alloc::string::String
pub numrs2::error::IOError::Stream
pub numrs2::error::IOError::Stream
pub numrs2::error::IOError::Stream::bytes_processed: core::option::Option<usize>
pub numrs2::error::IOError::Stream::bytes_processed: core::option::Option<usize>
pub numrs2::error::IOError::Stream::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Stream::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Stream::reason: alloc::string::String
pub numrs2::error::IOError::Stream::reason: alloc::string::String
pub numrs2::error::IOError::Stream::stream_type: alloc::string::String
pub numrs2::error::IOError::Stream::stream_type: alloc::string::String
pub numrs2::error::IOError::TemporaryResource
pub numrs2::error::IOError::TemporaryResource
pub numrs2::error::IOError::TemporaryResource::cleanup_attempted: bool
pub numrs2::error::IOError::TemporaryResource::cleanup_attempted: bool
pub numrs2::error::IOError::TemporaryResource::context: numrs2::error::OperationContext
pub numrs2::error::IOError::TemporaryResource::context: numrs2::error::OperationContext
pub numrs2::error::IOError::TemporaryResource::reason: alloc::string::String
pub numrs2::error::IOError::TemporaryResource::reason: alloc::string::String
pub numrs2::error::IOError::TemporaryResource::resource_type: alloc::string::String
pub numrs2::error::IOError::TemporaryResource::resource_type: alloc::string::String
pub numrs2::error::IOError::Validation
pub numrs2::error::IOError::Validation
pub numrs2::error::IOError::Validation::actual_value: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::Validation::actual_value: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::Validation::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Validation::context: numrs2::error::OperationContext
pub numrs2::error::IOError::Validation::details: alloc::string::String
pub numrs2::error::IOError::Validation::details: alloc::string::String
pub numrs2::error::IOError::Validation::expected_value: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::Validation::expected_value: core::option::Option<alloc::string::String>
pub numrs2::error::IOError::Validation::validation_type: alloc::string::String
pub numrs2::error::IOError::Validation::validation_type: alloc::string::String
impl numrs2::error::IOError
impl numrs2::error::IOError
pub fn numrs2::error::IOError::access_denied(operation: &str, resource: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::access_denied(operation: &str, resource: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::deserialization(format: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::deserialization(format: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::file_operation(operation: &str, path: std::path::PathBuf, reason: &str) -> Self
pub fn numrs2::error::IOError::file_operation(operation: &str, path: std::path::PathBuf, reason: &str) -> Self
pub fn numrs2::error::IOError::invalid_format(format: &str, details: &str) -> Self
pub fn numrs2::error::IOError::invalid_format(format: &str, details: &str) -> Self
pub fn numrs2::error::IOError::network(operation: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::network(operation: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::serialization(format: &str, reason: &str) -> Self
pub fn numrs2::error::IOError::serialization(format: &str, reason: &str) -> Self
impl numrs2::error::IOError
impl numrs2::error::IOError
pub fn numrs2::error::IOError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::IOError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::IOError::is_transient(&self) -> bool
pub fn numrs2::error::IOError::is_transient(&self) -> bool
pub fn numrs2::error::IOError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::IOError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::IOError::severity(&self) -> numrs2::error::ErrorSeverity
pub fn numrs2::error::IOError::severity(&self) -> numrs2::error::ErrorSeverity
impl core::convert::From<std::io::error::Error> for numrs2::error::IOError
impl core::convert::From<std::io::error::Error> for numrs2::error::IOError
pub fn numrs2::error::IOError::from(err: std::io::error::Error) -> Self
pub fn numrs2::error::IOError::from(err: std::io::error::Error) -> Self
pub enum numrs2::error::MemoryError
pub enum numrs2::error::MemoryError
pub numrs2::error::MemoryError::AlignmentError
pub numrs2::error::MemoryError::AlignmentError
pub numrs2::error::MemoryError::AlignmentError::actual_alignment: core::option::Option<usize>
pub numrs2::error::MemoryError::AlignmentError::actual_alignment: core::option::Option<usize>
pub numrs2::error::MemoryError::AlignmentError::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::AlignmentError::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::AlignmentError::reason: alloc::string::String
pub numrs2::error::MemoryError::AlignmentError::reason: alloc::string::String
pub numrs2::error::MemoryError::AlignmentError::required_alignment: usize
pub numrs2::error::MemoryError::AlignmentError::required_alignment: usize
pub numrs2::error::MemoryError::AllocationFailed
pub numrs2::error::MemoryError::AllocationFailed
pub numrs2::error::MemoryError::AllocationFailed::allocator_type: core::option::Option<alloc::string::String>
pub numrs2::error::MemoryError::AllocationFailed::allocator_type: core::option::Option<alloc::string::String>
pub numrs2::error::MemoryError::AllocationFailed::available_bytes: core::option::Option<usize>
pub numrs2::error::MemoryError::AllocationFailed::available_bytes: core::option::Option<usize>
pub numrs2::error::MemoryError::AllocationFailed::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::AllocationFailed::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::AllocationFailed::reason: alloc::string::String
pub numrs2::error::MemoryError::AllocationFailed::reason: alloc::string::String
pub numrs2::error::MemoryError::AllocationFailed::requested_bytes: usize
pub numrs2::error::MemoryError::AllocationFailed::requested_bytes: usize
pub numrs2::error::MemoryError::ArenaOverflow
pub numrs2::error::MemoryError::ArenaOverflow
pub numrs2::error::MemoryError::ArenaOverflow::arena_size: usize
pub numrs2::error::MemoryError::ArenaOverflow::arena_size: usize
pub numrs2::error::MemoryError::ArenaOverflow::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::ArenaOverflow::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::ArenaOverflow::remaining_bytes: usize
pub numrs2::error::MemoryError::ArenaOverflow::remaining_bytes: usize
pub numrs2::error::MemoryError::ArenaOverflow::requested_bytes: usize
pub numrs2::error::MemoryError::ArenaOverflow::requested_bytes: usize
pub numrs2::error::MemoryError::Fragmentation
pub numrs2::error::MemoryError::Fragmentation
pub numrs2::error::MemoryError::Fragmentation::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::Fragmentation::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::Fragmentation::fragmentation_level: f64
pub numrs2::error::MemoryError::Fragmentation::fragmentation_level: f64
pub numrs2::error::MemoryError::Fragmentation::largest_free_block: core::option::Option<usize>
pub numrs2::error::MemoryError::Fragmentation::largest_free_block: core::option::Option<usize>
pub numrs2::error::MemoryError::Fragmentation::reason: alloc::string::String
pub numrs2::error::MemoryError::Fragmentation::reason: alloc::string::String
pub numrs2::error::MemoryError::GpuMemoryError
pub numrs2::error::MemoryError::GpuMemoryError
pub numrs2::error::MemoryError::GpuMemoryError::available_bytes: core::option::Option<usize>
pub numrs2::error::MemoryError::GpuMemoryError::available_bytes: core::option::Option<usize>
pub numrs2::error::MemoryError::GpuMemoryError::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::GpuMemoryError::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::GpuMemoryError::device_id: core::option::Option<usize>
pub numrs2::error::MemoryError::GpuMemoryError::device_id: core::option::Option<usize>
pub numrs2::error::MemoryError::GpuMemoryError::reason: alloc::string::String
pub numrs2::error::MemoryError::GpuMemoryError::reason: alloc::string::String
pub numrs2::error::MemoryError::GpuMemoryError::requested_bytes: core::option::Option<usize>
pub numrs2::error::MemoryError::GpuMemoryError::requested_bytes: core::option::Option<usize>
pub numrs2::error::MemoryError::InvalidAccess
pub numrs2::error::MemoryError::InvalidAccess
pub numrs2::error::MemoryError::InvalidAccess::access_type: numrs2::error::AccessType
pub numrs2::error::MemoryError::InvalidAccess::access_type: numrs2::error::AccessType
pub numrs2::error::MemoryError::InvalidAccess::address: core::option::Option<usize>
pub numrs2::error::MemoryError::InvalidAccess::address: core::option::Option<usize>
pub numrs2::error::MemoryError::InvalidAccess::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::InvalidAccess::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::InvalidAccess::reason: alloc::string::String
pub numrs2::error::MemoryError::InvalidAccess::reason: alloc::string::String
pub numrs2::error::MemoryError::InvalidAccess::valid_range: core::option::Option<(usize, usize)>
pub numrs2::error::MemoryError::InvalidAccess::valid_range: core::option::Option<(usize, usize)>
pub numrs2::error::MemoryError::MappingError
pub numrs2::error::MemoryError::MappingError
pub numrs2::error::MemoryError::MappingError::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::MappingError::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::MappingError::file_path: core::option::Option<alloc::string::String>
pub numrs2::error::MemoryError::MappingError::file_path: core::option::Option<alloc::string::String>
pub numrs2::error::MemoryError::MappingError::mapping_size: core::option::Option<usize>
pub numrs2::error::MemoryError::MappingError::mapping_size: core::option::Option<usize>
pub numrs2::error::MemoryError::MappingError::reason: alloc::string::String
pub numrs2::error::MemoryError::MappingError::reason: alloc::string::String
pub numrs2::error::MemoryError::MemoryCorruption
pub numrs2::error::MemoryError::MemoryCorruption
pub numrs2::error::MemoryError::MemoryCorruption::affected_range: core::option::Option<(usize, usize)>
pub numrs2::error::MemoryError::MemoryCorruption::affected_range: core::option::Option<(usize, usize)>
pub numrs2::error::MemoryError::MemoryCorruption::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::MemoryCorruption::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::MemoryCorruption::corruption_type: numrs2::error::CorruptionType
pub numrs2::error::MemoryError::MemoryCorruption::corruption_type: numrs2::error::CorruptionType
pub numrs2::error::MemoryError::MemoryCorruption::details: alloc::string::String
pub numrs2::error::MemoryError::MemoryCorruption::details: alloc::string::String
pub numrs2::error::MemoryError::MemoryLeak
pub numrs2::error::MemoryError::MemoryLeak
pub numrs2::error::MemoryError::MemoryLeak::allocation_source: core::option::Option<alloc::string::String>
pub numrs2::error::MemoryError::MemoryLeak::allocation_source: core::option::Option<alloc::string::String>
pub numrs2::error::MemoryError::MemoryLeak::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::MemoryLeak::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::MemoryLeak::details: alloc::string::String
pub numrs2::error::MemoryError::MemoryLeak::details: alloc::string::String
pub numrs2::error::MemoryError::MemoryLeak::leaked_bytes: usize
pub numrs2::error::MemoryError::MemoryLeak::leaked_bytes: usize
pub numrs2::error::MemoryError::NumaError
pub numrs2::error::MemoryError::NumaError
pub numrs2::error::MemoryError::NumaError::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::NumaError::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::NumaError::numa_node: core::option::Option<usize>
pub numrs2::error::MemoryError::NumaError::numa_node: core::option::Option<usize>
pub numrs2::error::MemoryError::NumaError::preferred_node: core::option::Option<usize>
pub numrs2::error::MemoryError::NumaError::preferred_node: core::option::Option<usize>
pub numrs2::error::MemoryError::NumaError::reason: alloc::string::String
pub numrs2::error::MemoryError::NumaError::reason: alloc::string::String
pub numrs2::error::MemoryError::OutOfMemory
pub numrs2::error::MemoryError::OutOfMemory
pub numrs2::error::MemoryError::OutOfMemory::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::OutOfMemory::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::OutOfMemory::details: alloc::string::String
pub numrs2::error::MemoryError::OutOfMemory::details: alloc::string::String
pub numrs2::error::MemoryError::OutOfMemory::process_limit: core::option::Option<usize>
pub numrs2::error::MemoryError::OutOfMemory::process_limit: core::option::Option<usize>
pub numrs2::error::MemoryError::OutOfMemory::system_available: core::option::Option<usize>
pub numrs2::error::MemoryError::OutOfMemory::system_available: core::option::Option<usize>
pub numrs2::error::MemoryError::OutOfMemory::total_requested: usize
pub numrs2::error::MemoryError::OutOfMemory::total_requested: usize
pub numrs2::error::MemoryError::PoolExhausted
pub numrs2::error::MemoryError::PoolExhausted
pub numrs2::error::MemoryError::PoolExhausted::allocated_blocks: usize
pub numrs2::error::MemoryError::PoolExhausted::allocated_blocks: usize
pub numrs2::error::MemoryError::PoolExhausted::block_size: usize
pub numrs2::error::MemoryError::PoolExhausted::block_size: usize
pub numrs2::error::MemoryError::PoolExhausted::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::PoolExhausted::context: numrs2::error::OperationContext
pub numrs2::error::MemoryError::PoolExhausted::pool_size: usize
pub numrs2::error::MemoryError::PoolExhausted::pool_size: usize
pub numrs2::error::MemoryError::PoolExhausted::pool_type: alloc::string::String
pub numrs2::error::MemoryError::PoolExhausted::pool_type: alloc::string::String
impl numrs2::error::MemoryError
impl numrs2::error::MemoryError
pub fn numrs2::error::MemoryError::alignment_error(reason: &str, required_alignment: usize) -> Self
pub fn numrs2::error::MemoryError::alignment_error(reason: &str, required_alignment: usize) -> Self
pub fn numrs2::error::MemoryError::allocation_failed(reason: &str, requested_bytes: usize) -> Self
pub fn numrs2::error::MemoryError::allocation_failed(reason: &str, requested_bytes: usize) -> Self
pub fn numrs2::error::MemoryError::arena_overflow(requested_bytes: usize, remaining_bytes: usize, arena_size: usize) -> Self
pub fn numrs2::error::MemoryError::arena_overflow(requested_bytes: usize, remaining_bytes: usize, arena_size: usize) -> Self
pub fn numrs2::error::MemoryError::gpu_memory_error(reason: &str, device_id: core::option::Option<usize>) -> Self
pub fn numrs2::error::MemoryError::gpu_memory_error(reason: &str, device_id: core::option::Option<usize>) -> Self
pub fn numrs2::error::MemoryError::memory_corruption(details: &str, corruption_type: numrs2::error::CorruptionType) -> Self
pub fn numrs2::error::MemoryError::memory_corruption(details: &str, corruption_type: numrs2::error::CorruptionType) -> Self
pub fn numrs2::error::MemoryError::out_of_memory(details: &str, total_requested: usize) -> Self
pub fn numrs2::error::MemoryError::out_of_memory(details: &str, total_requested: usize) -> Self
pub fn numrs2::error::MemoryError::pool_exhausted(pool_type: &str, pool_size: usize, block_size: usize) -> Self
pub fn numrs2::error::MemoryError::pool_exhausted(pool_type: &str, pool_size: usize, block_size: usize) -> Self
impl numrs2::error::MemoryError
impl numrs2::error::MemoryError
pub fn numrs2::error::MemoryError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::MemoryError::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::MemoryError::is_transient(&self) -> bool
pub fn numrs2::error::MemoryError::is_transient(&self) -> bool
pub fn numrs2::error::MemoryError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::MemoryError::recovery_suggestions(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::error::MemoryError::severity(&self) -> numrs2::error::ErrorSeverity
pub fn numrs2::error::MemoryError::severity(&self) -> numrs2::error::ErrorSeverity
pub enum numrs2::error::MemoryPressure
pub numrs2::error::MemoryPressure::Critical
pub numrs2::error::MemoryPressure::High
pub numrs2::error::MemoryPressure::Low
pub numrs2::error::MemoryPressure::Medium
pub enum numrs2::error::NumRs2Error
pub numrs2::error::NumRs2Error::AllocationFailed(alloc::string::String)
pub numrs2::error::NumRs2Error::BlasError(i32)
pub numrs2::error::NumRs2Error::Computation(numrs2::error::ComputationError)
pub numrs2::error::NumRs2Error::ComputationError(alloc::string::String)
pub numrs2::error::NumRs2Error::ConversionError(alloc::string::String)
pub numrs2::error::NumRs2Error::Core(numrs2::error::CoreError)
pub numrs2::error::NumRs2Error::DeserializationError(alloc::string::String)
pub numrs2::error::NumRs2Error::DimensionMismatch(alloc::string::String)
pub numrs2::error::NumRs2Error::FeatureNotEnabled(alloc::string::String)
pub numrs2::error::NumRs2Error::IO(numrs2::error::IOError)
pub numrs2::error::NumRs2Error::IOError(alloc::string::String)
pub numrs2::error::NumRs2Error::IndexError(alloc::string::String)
pub numrs2::error::NumRs2Error::IndexOutOfBounds(alloc::string::String)
pub numrs2::error::NumRs2Error::InvalidOperation(alloc::string::String)
pub numrs2::error::NumRs2Error::LapackError(alloc::string::String)
pub numrs2::error::NumRs2Error::Memory(numrs2::error::MemoryError)
pub numrs2::error::NumRs2Error::NotImplemented(alloc::string::String)
pub numrs2::error::NumRs2Error::RuntimeError(alloc::string::String)
pub numrs2::error::NumRs2Error::SerializationError(alloc::string::String)
pub numrs2::error::NumRs2Error::ShapeMismatch
pub numrs2::error::NumRs2Error::ShapeMismatch::actual: alloc::vec::Vec<usize>
pub numrs2::error::NumRs2Error::ShapeMismatch::expected: alloc::vec::Vec<usize>
pub numrs2::error::NumRs2Error::TypeCastError(alloc::string::String)
pub numrs2::error::NumRs2Error::ValueError(alloc::string::String)
impl numrs2::NumRs2Error
pub fn numrs2::NumRs2Error::at_location(self, location: numrs2::error::ErrorLocation) -> numrs2::error::ErrorContext<Self>
pub fn numrs2::NumRs2Error::category(&self) -> numrs2::error::ErrorCategory
pub fn numrs2::NumRs2Error::is_recoverable(&self) -> bool
pub fn numrs2::NumRs2Error::severity(&self) -> numrs2::error::ErrorSeverity
pub fn numrs2::NumRs2Error::with_context<C: core::convert::Into<numrs2::error::OperationContext>>(self, context: C) -> numrs2::error::ErrorContext<Self>
impl core::convert::From<std::io::error::Error> for numrs2::NumRs2Error
pub fn numrs2::NumRs2Error::from(err: std::io::error::Error) -> Self
pub struct numrs2::error::ErrorContext<E>
pub struct numrs2::error::ErrorContext<E>
impl<E> numrs2::error::ErrorContext<E>
impl<E> numrs2::error::ErrorContext<E>
pub fn numrs2::error::ErrorContext<E>::chain(&self) -> &[alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>]
pub fn numrs2::error::ErrorContext<E>::chain(&self) -> &[alloc::boxed::Box<(dyn core::error::Error + core::marker::Send + core::marker::Sync)>]
pub fn numrs2::error::ErrorContext<E>::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::ErrorContext<E>::context(&self) -> &numrs2::error::OperationContext
pub fn numrs2::error::ErrorContext<E>::error(&self) -> &E
pub fn numrs2::error::ErrorContext<E>::error(&self) -> &E
pub fn numrs2::error::ErrorContext<E>::into_inner(self) -> E
pub fn numrs2::error::ErrorContext<E>::into_inner(self) -> E
pub fn numrs2::error::ErrorContext<E>::location(&self) -> core::option::Option<&numrs2::error::ErrorLocation>
pub fn numrs2::error::ErrorContext<E>::location(&self) -> core::option::Option<&numrs2::error::ErrorLocation>
pub fn numrs2::error::ErrorContext<E>::new(error: E, context: numrs2::error::OperationContext) -> Self
pub fn numrs2::error::ErrorContext<E>::new(error: E, context: numrs2::error::OperationContext) -> Self
pub fn numrs2::error::ErrorContext<E>::recovery_suggestions(&self) -> &[alloc::string::String]
pub fn numrs2::error::ErrorContext<E>::recovery_suggestions(&self) -> &[alloc::string::String]
pub fn numrs2::error::ErrorContext<E>::with_location(self, location: numrs2::error::ErrorLocation) -> Self
pub fn numrs2::error::ErrorContext<E>::with_location(self, location: numrs2::error::ErrorLocation) -> Self
pub fn numrs2::error::ErrorContext<E>::with_source<S>(self, source: S) -> Self where S: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::error::ErrorContext<E>::with_source<S>(self, source: S) -> Self where S: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::error::ErrorContext<E>::with_suggestion(self, suggestion: &str) -> Self
pub fn numrs2::error::ErrorContext<E>::with_suggestion(self, suggestion: &str) -> Self
impl<E: core::error::Error + 'static> core::error::Error for numrs2::error::ErrorContext<E>
impl<E: core::error::Error + 'static> core::error::Error for numrs2::error::ErrorContext<E>
pub fn numrs2::error::ErrorContext<E>::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
pub fn numrs2::error::ErrorContext<E>::source(&self) -> core::option::Option<&(dyn core::error::Error + 'static)>
impl<E: core::fmt::Display> core::fmt::Display for numrs2::error::ErrorContext<E>
impl<E: core::fmt::Display> core::fmt::Display for numrs2::error::ErrorContext<E>
pub fn numrs2::error::ErrorContext<E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub fn numrs2::error::ErrorContext<E>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::error::ErrorLocation
pub struct numrs2::error::ErrorLocation
pub numrs2::error::ErrorLocation::file: alloc::string::String
pub numrs2::error::ErrorLocation::file: alloc::string::String
pub numrs2::error::ErrorLocation::function: alloc::string::String
pub numrs2::error::ErrorLocation::function: alloc::string::String
pub numrs2::error::ErrorLocation::line: u32
pub numrs2::error::ErrorLocation::line: u32
pub numrs2::error::ErrorLocation::module_path: core::option::Option<alloc::string::String>
pub numrs2::error::ErrorLocation::module_path: core::option::Option<alloc::string::String>
impl numrs2::error::ErrorLocation
impl numrs2::error::ErrorLocation
pub fn numrs2::error::ErrorLocation::new(file: &str, line: u32, function: &str) -> Self
pub fn numrs2::error::ErrorLocation::new(file: &str, line: u32, function: &str) -> Self
pub fn numrs2::error::ErrorLocation::with_module(file: &str, line: u32, function: &str, module_path: &str) -> Self
pub fn numrs2::error::ErrorLocation::with_module(file: &str, line: u32, function: &str, module_path: &str) -> Self
impl core::fmt::Display for numrs2::error::ErrorLocation
impl core::fmt::Display for numrs2::error::ErrorLocation
pub fn numrs2::error::ErrorLocation::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub fn numrs2::error::ErrorLocation::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::error::MemoryInfo
pub numrs2::error::MemoryInfo::available_memory: core::option::Option<usize>
pub numrs2::error::MemoryInfo::peak_usage: usize
pub numrs2::error::MemoryInfo::pressure_level: numrs2::error::MemoryPressure
pub numrs2::error::MemoryInfo::total_allocated: usize
pub struct numrs2::error::OperationContext
pub struct numrs2::error::OperationContext
pub numrs2::error::OperationContext::dtypes: alloc::vec::Vec<alloc::string::String>
pub numrs2::error::OperationContext::dtypes: alloc::vec::Vec<alloc::string::String>
pub numrs2::error::OperationContext::memory_info: core::option::Option<numrs2::error::MemoryInfo>
pub numrs2::error::OperationContext::memory_info: core::option::Option<numrs2::error::MemoryInfo>
pub numrs2::error::OperationContext::operation: core::option::Option<alloc::string::String>
pub numrs2::error::OperationContext::operation: core::option::Option<alloc::string::String>
pub numrs2::error::OperationContext::parameters: std::collections::hash::map::HashMap<alloc::string::String, alloc::string::String>
pub numrs2::error::OperationContext::parameters: std::collections::hash::map::HashMap<alloc::string::String, alloc::string::String>
pub numrs2::error::OperationContext::performance_hints: alloc::vec::Vec<alloc::string::String>
pub numrs2::error::OperationContext::performance_hints: alloc::vec::Vec<alloc::string::String>
pub numrs2::error::OperationContext::shapes: alloc::vec::Vec<alloc::vec::Vec<usize>>
pub numrs2::error::OperationContext::shapes: alloc::vec::Vec<alloc::vec::Vec<usize>>
pub numrs2::error::OperationContext::thread_info: core::option::Option<numrs2::error::ThreadInfo>
pub numrs2::error::OperationContext::thread_info: core::option::Option<numrs2::error::ThreadInfo>
pub numrs2::error::OperationContext::timestamp: u64
pub numrs2::error::OperationContext::timestamp: u64
impl numrs2::error::OperationContext
impl numrs2::error::OperationContext
pub fn numrs2::error::OperationContext::new(operation: &str) -> Self
pub fn numrs2::error::OperationContext::new(operation: &str) -> Self
pub fn numrs2::error::OperationContext::with_dtype(self, dtype: &str) -> Self
pub fn numrs2::error::OperationContext::with_dtype(self, dtype: &str) -> Self
pub fn numrs2::error::OperationContext::with_memory_info(self, memory_info: numrs2::error::MemoryInfo) -> Self
pub fn numrs2::error::OperationContext::with_memory_info(self, memory_info: numrs2::error::MemoryInfo) -> Self
pub fn numrs2::error::OperationContext::with_parameter<K, V>(self, key: K, value: V) -> Self where K: core::convert::Into<alloc::string::String>, V: core::fmt::Display
pub fn numrs2::error::OperationContext::with_parameter<K, V>(self, key: K, value: V) -> Self where K: core::convert::Into<alloc::string::String>, V: core::fmt::Display
pub fn numrs2::error::OperationContext::with_performance_hint(self, hint: &str) -> Self
pub fn numrs2::error::OperationContext::with_performance_hint(self, hint: &str) -> Self
pub fn numrs2::error::OperationContext::with_shape(self, shape: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::error::OperationContext::with_shape(self, shape: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::error::OperationContext::with_shapes(self, shapes: &[alloc::vec::Vec<usize>]) -> Self
pub fn numrs2::error::OperationContext::with_shapes(self, shapes: &[alloc::vec::Vec<usize>]) -> Self
pub fn numrs2::error::OperationContext::with_thread_info(self, thread_info: numrs2::error::ThreadInfo) -> Self
pub fn numrs2::error::OperationContext::with_thread_info(self, thread_info: numrs2::error::ThreadInfo) -> Self
impl core::default::Default for numrs2::error::OperationContext
impl core::default::Default for numrs2::error::OperationContext
pub fn numrs2::error::OperationContext::default() -> Self
pub fn numrs2::error::OperationContext::default() -> Self
pub struct numrs2::error::ThreadInfo
pub numrs2::error::ThreadInfo::is_parallel: bool
pub numrs2::error::ThreadInfo::pool_info: core::option::Option<alloc::string::String>
pub numrs2::error::ThreadInfo::thread_count: core::option::Option<usize>
pub numrs2::error::ThreadInfo::thread_id: alloc::string::String
pub type numrs2::error::ContextResult<T> = core::result::Result<T, numrs2::error::ErrorContext<numrs2::NumRs2Error>>
pub type numrs2::error::Result<T> = core::result::Result<T, numrs2::NumRs2Error>
pub mod numrs2::error_handling
pub enum numrs2::error_handling::ErrorAction
pub numrs2::error_handling::ErrorAction::Call
pub numrs2::error_handling::ErrorAction::Ignore
pub numrs2::error_handling::ErrorAction::Raise
pub numrs2::error_handling::ErrorAction::Warn
impl core::fmt::Display for numrs2::error_handling::ErrorAction
pub fn numrs2::error_handling::ErrorAction::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::str::traits::FromStr for numrs2::error_handling::ErrorAction
pub type numrs2::error_handling::ErrorAction::Err = alloc::string::String
pub fn numrs2::error_handling::ErrorAction::from_str(s: &str) -> core::result::Result<Self, Self::Err>
pub enum numrs2::error_handling::FloatingPointError
pub numrs2::error_handling::FloatingPointError::DivideByZero
pub numrs2::error_handling::FloatingPointError::Invalid
pub numrs2::error_handling::FloatingPointError::Overflow
pub numrs2::error_handling::FloatingPointError::Underflow
impl core::fmt::Display for numrs2::error_handling::FloatingPointError
pub fn numrs2::error_handling::FloatingPointError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::error_handling::ErrorState
pub numrs2::error_handling::ErrorState::divide: numrs2::error_handling::ErrorAction
pub numrs2::error_handling::ErrorState::invalid: numrs2::error_handling::ErrorAction
pub numrs2::error_handling::ErrorState::over: numrs2::error_handling::ErrorAction
pub numrs2::error_handling::ErrorState::under: numrs2::error_handling::ErrorAction
impl numrs2::error_handling::ErrorState
pub fn numrs2::error_handling::ErrorState::new(action: numrs2::error_handling::ErrorAction) -> Self
pub fn numrs2::error_handling::ErrorState::with_actions(divide: numrs2::error_handling::ErrorAction, over: numrs2::error_handling::ErrorAction, under: numrs2::error_handling::ErrorAction, invalid: numrs2::error_handling::ErrorAction) -> Self
impl core::default::Default for numrs2::error_handling::ErrorState
pub fn numrs2::error_handling::ErrorState::default() -> Self
pub struct numrs2::error_handling::ErrorStateBuilder
impl numrs2::error_handling::ErrorStateBuilder
pub fn numrs2::error_handling::ErrorStateBuilder::divide(self, action: numrs2::error_handling::ErrorAction) -> Self
pub fn numrs2::error_handling::ErrorStateBuilder::enter(self) -> numrs2::error_handling::ErrorStateGuard
pub fn numrs2::error_handling::ErrorStateBuilder::invalid(self, action: numrs2::error_handling::ErrorAction) -> Self
pub fn numrs2::error_handling::ErrorStateBuilder::over(self, action: numrs2::error_handling::ErrorAction) -> Self
pub fn numrs2::error_handling::ErrorStateBuilder::under(self, action: numrs2::error_handling::ErrorAction) -> Self
pub struct numrs2::error_handling::ErrorStateGuard
impl core::ops::drop::Drop for numrs2::error_handling::ErrorStateGuard
pub fn numrs2::error_handling::ErrorStateGuard::drop(&mut self)
pub fn numrs2::error_handling::errstate() -> numrs2::error_handling::ErrorStateBuilder
pub fn numrs2::error_handling::geterr() -> numrs2::error_handling::ErrorState
pub fn numrs2::error_handling::geterrcall() -> core::option::Option<numrs2::error_handling::ErrorCallback>
pub fn numrs2::error_handling::handle_error(error_type: numrs2::error_handling::FloatingPointError, message: &str) -> bool
pub fn numrs2::error_handling::seterr(all: core::option::Option<numrs2::error_handling::ErrorAction>, divide: core::option::Option<numrs2::error_handling::ErrorAction>, over: core::option::Option<numrs2::error_handling::ErrorAction>, under: core::option::Option<numrs2::error_handling::ErrorAction>, invalid: core::option::Option<numrs2::error_handling::ErrorAction>) -> numrs2::error_handling::ErrorState
pub fn numrs2::error_handling::seterrcall(callback: core::option::Option<numrs2::error_handling::ErrorCallback>)
pub type numrs2::error_handling::ErrorCallback = alloc::sync::Arc<(dyn core::ops::function::Fn(&str) + core::marker::Send + core::marker::Sync)>
pub mod numrs2::expr
pub enum numrs2::expr::ExprKey
pub numrs2::expr::ExprKey::Array(u64)
pub numrs2::expr::ExprKey::Binary
pub numrs2::expr::ExprKey::Binary::left: alloc::boxed::Box<numrs2::expr::ExprKey>
pub numrs2::expr::ExprKey::Binary::op: &'static str
pub numrs2::expr::ExprKey::Binary::right: alloc::boxed::Box<numrs2::expr::ExprKey>
pub numrs2::expr::ExprKey::Scalar
pub numrs2::expr::ExprKey::Scalar::op: &'static str
pub numrs2::expr::ExprKey::Scalar::operand: alloc::boxed::Box<numrs2::expr::ExprKey>
pub numrs2::expr::ExprKey::Scalar::scalar_hash: u64
pub numrs2::expr::ExprKey::Unary
pub numrs2::expr::ExprKey::Unary::op: &'static str
pub numrs2::expr::ExprKey::Unary::operand: alloc::boxed::Box<numrs2::expr::ExprKey>
impl numrs2::expr::ExprKey
pub fn numrs2::expr::ExprKey::array(id: u64) -> Self
pub fn numrs2::expr::ExprKey::binary(op: &'static str, left: numrs2::expr::ExprKey, right: numrs2::expr::ExprKey) -> Self
pub fn numrs2::expr::ExprKey::scalar(op: &'static str, operand: numrs2::expr::ExprKey, scalar_hash: u64) -> Self
pub fn numrs2::expr::ExprKey::unary(op: &'static str, operand: numrs2::expr::ExprKey) -> Self
pub struct numrs2::expr::ArrayExpr<'a, T: core::clone::Clone>
impl<'a, T: core::clone::Clone> numrs2::expr::ArrayExpr<'a, T>
pub fn numrs2::expr::ArrayExpr<'a, T>::new(array: &'a numrs2::array::Array<T>) -> Self
impl<'a, T: core::clone::Clone> numrs2::expr::Expr<T> for numrs2::expr::ArrayExpr<'a, T>
pub fn numrs2::expr::ArrayExpr<'a, T>::eval(&self) -> numrs2::array::Array<T>
pub fn numrs2::expr::ArrayExpr<'a, T>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::ArrayExpr<'a, T>::shape(&self) -> &[usize]
pub fn numrs2::expr::ArrayExpr<'a, T>::size(&self) -> usize
impl<'a> numrs2::expr::SimdEval<f64> for numrs2::expr::ArrayExpr<'a, f64>
pub struct numrs2::expr::BinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::Expr<T>, R: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
impl<T, L, R, F> numrs2::expr::BinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::Expr<T>, R: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::new(left: L, right: R, op: F) -> numrs2::Result<Self>
impl<L, R, F> numrs2::expr::SimdEval<f64> for numrs2::expr::BinaryExpr<f64, L, R, F> where L: numrs2::expr::Expr<f64>, R: numrs2::expr::Expr<f64>, F: core::ops::function::Fn(f64, f64) -> f64
impl<T, L, R, F> numrs2::expr::Expr<T> for numrs2::expr::BinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::Expr<T>, R: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::shape(&self) -> &[usize]
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::size(&self) -> usize
pub struct numrs2::expr::BroadcastScalarExpr<T: core::clone::Clone>
impl<T: core::clone::Clone> numrs2::expr::BroadcastScalarExpr<T>
pub fn numrs2::expr::BroadcastScalarExpr<T>::new(value: T, shape: &[usize]) -> Self
impl<T: core::clone::Clone> numrs2::expr::Expr<T> for numrs2::expr::BroadcastScalarExpr<T>
pub fn numrs2::expr::BroadcastScalarExpr<T>::eval_at(&self, _index: usize) -> T
pub fn numrs2::expr::BroadcastScalarExpr<T>::shape(&self) -> &[usize]
pub fn numrs2::expr::BroadcastScalarExpr<T>::size(&self) -> usize
pub struct numrs2::expr::CSEAnalysisResult
pub numrs2::expr::CSEAnalysisResult::common_subexpressions: usize
pub numrs2::expr::CSEAnalysisResult::occurrence_counts: std::collections::hash::map::HashMap<alloc::string::String, usize>
pub numrs2::expr::CSEAnalysisResult::savings_ratio: f64
pub numrs2::expr::CSEAnalysisResult::total_nodes: usize
impl numrs2::expr::CSEAnalysisResult
pub fn numrs2::expr::CSEAnalysisResult::calculate_savings(&mut self)
pub fn numrs2::expr::CSEAnalysisResult::new() -> Self
impl core::default::Default for numrs2::expr::CSEAnalysisResult
pub fn numrs2::expr::CSEAnalysisResult::default() -> Self
pub struct numrs2::expr::CSEExprBuilder<T: core::clone::Clone>
impl<T: core::clone::Clone> numrs2::expr::CSEExprBuilder<T>
pub fn numrs2::expr::CSEExprBuilder<T>::clear(&mut self)
pub fn numrs2::expr::CSEExprBuilder<T>::eval_array(&self, array: numrs2::shared_array::SharedArray<T>) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::CSEExprBuilder<T>::new() -> Self
pub fn numrs2::expr::CSEExprBuilder<T>::stats(&self) -> numrs2::expr::CSEStats
pub fn numrs2::expr::CSEExprBuilder<T>::wrap<E: numrs2::expr::SharedExpr<T>>(&mut self, expr: E, key: numrs2::expr::ExprKey) -> numrs2::expr::CachedExpr<T, E>
impl<T: core::clone::Clone> core::default::Default for numrs2::expr::CSEExprBuilder<T>
pub fn numrs2::expr::CSEExprBuilder<T>::default() -> Self
pub struct numrs2::expr::CSEOptimizer<T: core::clone::Clone>
impl<T: core::clone::Clone> numrs2::expr::CSEOptimizer<T>
pub fn numrs2::expr::CSEOptimizer<T>::cache(&self) -> &numrs2::expr::ExprCache<T>
pub fn numrs2::expr::CSEOptimizer<T>::cache_expr<E: numrs2::expr::SharedExpr<T>>(&self, expr: E, id: numrs2::expr::ExprId) -> numrs2::expr::CachedExpr<T, E>
pub fn numrs2::expr::CSEOptimizer<T>::clear(&mut self)
pub fn numrs2::expr::CSEOptimizer<T>::get_or_create_id(&mut self, key: &numrs2::expr::ExprKey) -> numrs2::expr::ExprId
pub fn numrs2::expr::CSEOptimizer<T>::new() -> Self
pub fn numrs2::expr::CSEOptimizer<T>::next_array_id(&mut self) -> u64
pub fn numrs2::expr::CSEOptimizer<T>::stats(&self) -> numrs2::expr::CSEStats
impl<T: core::clone::Clone> core::default::Default for numrs2::expr::CSEOptimizer<T>
pub fn numrs2::expr::CSEOptimizer<T>::default() -> Self
pub struct numrs2::expr::CSEStats
pub numrs2::expr::CSEStats::cached_results: usize
pub numrs2::expr::CSEStats::unique_expressions: usize
pub struct numrs2::expr::CachedExpr<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>>
impl<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>> numrs2::expr::CachedExpr<T, E>
pub fn numrs2::expr::CachedExpr<T, E>::cache(&self) -> &numrs2::expr::ExprCache<T>
pub fn numrs2::expr::CachedExpr<T, E>::id(&self) -> numrs2::expr::ExprId
pub fn numrs2::expr::CachedExpr<T, E>::invalidate(&self)
pub fn numrs2::expr::CachedExpr<T, E>::new(expr: E, cache: numrs2::expr::ExprCache<T>) -> Self
pub fn numrs2::expr::CachedExpr<T, E>::with_id(expr: E, id: numrs2::expr::ExprId, cache: numrs2::expr::ExprCache<T>) -> Self
impl<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExpr<T> for numrs2::expr::CachedExpr<T, E>
pub fn numrs2::expr::CachedExpr<T, E>::eval(&self) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::CachedExpr<T, E>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::CachedExpr<T, E>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::CachedExpr<T, E>::size(&self) -> usize
pub struct numrs2::expr::ClipExpr<T, E> where T: core::clone::Clone + core::cmp::PartialOrd, E: numrs2::expr::Expr<T>
impl<T, E> numrs2::expr::ClipExpr<T, E> where T: core::clone::Clone + core::cmp::PartialOrd, E: numrs2::expr::Expr<T>
pub fn numrs2::expr::ClipExpr<T, E>::new(expr: E, min_val: T, max_val: T) -> Self
impl<T, E> numrs2::expr::Expr<T> for numrs2::expr::ClipExpr<T, E> where T: core::clone::Clone + core::cmp::PartialOrd, E: numrs2::expr::Expr<T>
pub fn numrs2::expr::ClipExpr<T, E>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::ClipExpr<T, E>::shape(&self) -> &[usize]
pub fn numrs2::expr::ClipExpr<T, E>::size(&self) -> usize
pub struct numrs2::expr::ExprBuilder<T, E> where T: core::clone::Clone, E: numrs2::expr::Expr<T>
impl<'a, T: core::clone::Clone> numrs2::expr::ExprBuilder<T, numrs2::expr::ArrayExpr<'a, T>>
pub fn numrs2::expr::ExprBuilder<T, numrs2::expr::ArrayExpr<'a, T>>::from_array(array: &'a numrs2::array::Array<T>) -> Self
impl<E: numrs2::expr::Expr<f64>> numrs2::expr::ExprBuilder<f64, E>
pub fn numrs2::expr::ExprBuilder<f64, E>::abs(self) -> numrs2::expr::ExprBuilder<f64, numrs2::expr::UnaryExpr<f64, E, impl core::ops::function::Fn(f64) -> f64>>
pub fn numrs2::expr::ExprBuilder<f64, E>::cos(self) -> numrs2::expr::ExprBuilder<f64, numrs2::expr::UnaryExpr<f64, E, impl core::ops::function::Fn(f64) -> f64>>
pub fn numrs2::expr::ExprBuilder<f64, E>::exp(self) -> numrs2::expr::ExprBuilder<f64, numrs2::expr::UnaryExpr<f64, E, impl core::ops::function::Fn(f64) -> f64>>
pub fn numrs2::expr::ExprBuilder<f64, E>::ln(self) -> numrs2::expr::ExprBuilder<f64, numrs2::expr::UnaryExpr<f64, E, impl core::ops::function::Fn(f64) -> f64>>
pub fn numrs2::expr::ExprBuilder<f64, E>::max(self) -> f64
pub fn numrs2::expr::ExprBuilder<f64, E>::min(self) -> f64
pub fn numrs2::expr::ExprBuilder<f64, E>::prod(self) -> f64
pub fn numrs2::expr::ExprBuilder<f64, E>::sin(self) -> numrs2::expr::ExprBuilder<f64, numrs2::expr::UnaryExpr<f64, E, impl core::ops::function::Fn(f64) -> f64>>
pub fn numrs2::expr::ExprBuilder<f64, E>::sqrt(self) -> numrs2::expr::ExprBuilder<f64, numrs2::expr::UnaryExpr<f64, E, impl core::ops::function::Fn(f64) -> f64>>
pub fn numrs2::expr::ExprBuilder<f64, E>::sum(self) -> f64
impl<T, E> numrs2::expr::ExprBuilder<T, E> where T: core::clone::Clone, E: numrs2::expr::Expr<T>
pub fn numrs2::expr::ExprBuilder<T, E>::add_scalar(self, scalar: T) -> numrs2::expr::ExprBuilder<T, numrs2::expr::ScalarExpr<T, E, impl core::ops::function::Fn(T, T) -> T>> where T: core::ops::arith::Add<Output = T>
pub fn numrs2::expr::ExprBuilder<T, E>::build(self) -> E
pub fn numrs2::expr::ExprBuilder<T, E>::eval(self) -> numrs2::array::Array<T>
pub fn numrs2::expr::ExprBuilder<T, E>::map<F: core::ops::function::Fn(T) -> T>(self, op: F) -> numrs2::expr::ExprBuilder<T, numrs2::expr::UnaryExpr<T, E, F>>
pub fn numrs2::expr::ExprBuilder<T, E>::mul_scalar(self, scalar: T) -> numrs2::expr::ExprBuilder<T, numrs2::expr::ScalarExpr<T, E, impl core::ops::function::Fn(T, T) -> T>> where T: core::ops::arith::Mul<Output = T>
pub fn numrs2::expr::ExprBuilder<T, E>::scalar<F: core::ops::function::Fn(T, T) -> T>(self, scalar: T, op: F) -> numrs2::expr::ExprBuilder<T, numrs2::expr::ScalarExpr<T, E, F>>
pub fn numrs2::expr::ExprBuilder<T, E>::zip_with<E2, F>(self, other: E2, op: F) -> numrs2::Result<numrs2::expr::ExprBuilder<T, numrs2::expr::BinaryExpr<T, E, E2, F>>> where E2: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub struct numrs2::expr::ExprCache<T: core::clone::Clone>
impl<T: core::clone::Clone> numrs2::expr::ExprCache<T>
pub fn numrs2::expr::ExprCache<T>::clear(&self)
pub fn numrs2::expr::ExprCache<T>::contains(&self, id: &numrs2::expr::ExprId) -> bool
pub fn numrs2::expr::ExprCache<T>::get(&self, id: &numrs2::expr::ExprId) -> core::option::Option<numrs2::shared_array::SharedArray<T>>
pub fn numrs2::expr::ExprCache<T>::insert(&self, id: numrs2::expr::ExprId, value: numrs2::shared_array::SharedArray<T>)
pub fn numrs2::expr::ExprCache<T>::is_empty(&self) -> bool
pub fn numrs2::expr::ExprCache<T>::len(&self) -> usize
pub fn numrs2::expr::ExprCache<T>::new() -> Self
impl<T: core::clone::Clone> core::clone::Clone for numrs2::expr::ExprCache<T>
pub fn numrs2::expr::ExprCache<T>::clone(&self) -> Self
impl<T: core::clone::Clone> core::default::Default for numrs2::expr::ExprCache<T>
pub fn numrs2::expr::ExprCache<T>::default() -> Self
pub struct numrs2::expr::ExprId(_)
impl numrs2::expr::ExprId
pub fn numrs2::expr::ExprId::from_raw(id: u64) -> Self
pub fn numrs2::expr::ExprId::new() -> Self
pub fn numrs2::expr::ExprId::raw(&self) -> u64
impl core::default::Default for numrs2::expr::ExprId
pub fn numrs2::expr::ExprId::default() -> Self
pub struct numrs2::expr::OptimizedExprNode<T: core::clone::Clone>
impl<T: core::clone::Clone> numrs2::expr::OptimizedExprNode<T>
pub fn numrs2::expr::OptimizedExprNode<T>::get_or_compute<F>(&mut self, compute: F) -> numrs2::shared_array::SharedArray<T> where F: core::ops::function::FnOnce() -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::OptimizedExprNode<T>::id(&self) -> numrs2::expr::ExprId
pub fn numrs2::expr::OptimizedExprNode<T>::is_cached(&self) -> bool
pub fn numrs2::expr::OptimizedExprNode<T>::key(&self) -> &numrs2::expr::ExprKey
pub fn numrs2::expr::OptimizedExprNode<T>::new(id: numrs2::expr::ExprId, key: numrs2::expr::ExprKey, cache: numrs2::expr::ExprCache<T>) -> Self
pub struct numrs2::expr::ReductionExpr<T, E, F, R> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T, R: core::ops::function::Fn() -> T
impl<T, E, F, R> numrs2::expr::ReductionExpr<T, E, F, R> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T, R: core::ops::function::Fn() -> T
pub fn numrs2::expr::ReductionExpr<T, E, F, R>::new(expr: E, reduce_op: F, identity: R) -> Self
pub fn numrs2::expr::ReductionExpr<T, E, F, R>::reduce(&self) -> T
pub struct numrs2::expr::ScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
impl<T, E, F> numrs2::expr::ScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::expr::ScalarExpr<T, E, F>::new(expr: E, scalar: T, op: F) -> Self
impl<E, F> numrs2::expr::SimdEval<f64> for numrs2::expr::ScalarExpr<f64, E, F> where E: numrs2::expr::Expr<f64>, F: core::ops::function::Fn(f64, f64) -> f64
impl<T, E, F> numrs2::expr::Expr<T> for numrs2::expr::ScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::expr::ScalarExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::ScalarExpr<T, E, F>::shape(&self) -> &[usize]
pub fn numrs2::expr::ScalarExpr<T, E, F>::size(&self) -> usize
pub struct numrs2::expr::SharedArrayExpr<T: core::clone::Clone>
impl<T: core::clone::Clone> numrs2::expr::SharedArrayExpr<T>
pub fn numrs2::expr::SharedArrayExpr<T>::from_array(array: numrs2::array::Array<T>) -> Self
pub fn numrs2::expr::SharedArrayExpr<T>::new(array: numrs2::shared_array::SharedArray<T>) -> Self
impl<T: core::clone::Clone> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedArrayExpr<T>
pub fn numrs2::expr::SharedArrayExpr<T>::eval(&self) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::SharedArrayExpr<T>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedArrayExpr<T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedArrayExpr<T>::size(&self) -> usize
pub struct numrs2::expr::SharedBinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::SharedExpr<T>, R: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
impl<T, L, R, F> numrs2::expr::SharedBinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::SharedExpr<T>, R: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::new(left: L, right: R, op: F) -> numrs2::Result<Self>
impl<T, L, R, F> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedBinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::SharedExpr<T>, R: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::size(&self) -> usize
pub struct numrs2::expr::SharedExprBuilder<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>>
impl<T: core::clone::Clone + core::ops::arith::Add<Output = T>, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExprBuilder<T, E>
pub fn numrs2::expr::SharedExprBuilder<T, E>::add_scalar(self, scalar: T) -> numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedScalarExpr<T, E, fn(T, T) -> T>> where T: 'static
impl<T: core::clone::Clone + core::ops::arith::Div<Output = T>, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExprBuilder<T, E>
pub fn numrs2::expr::SharedExprBuilder<T, E>::div_scalar(self, scalar: T) -> numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedScalarExpr<T, E, fn(T, T) -> T>> where T: 'static
impl<T: core::clone::Clone + core::ops::arith::Mul<Output = T>, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExprBuilder<T, E>
pub fn numrs2::expr::SharedExprBuilder<T, E>::mul_scalar(self, scalar: T) -> numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedScalarExpr<T, E, fn(T, T) -> T>> where T: 'static
impl<T: core::clone::Clone + core::ops::arith::Sub<Output = T>, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExprBuilder<T, E>
pub fn numrs2::expr::SharedExprBuilder<T, E>::sub_scalar(self, scalar: T) -> numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedScalarExpr<T, E, fn(T, T) -> T>> where T: 'static
impl<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExprBuilder<T, E>
pub fn numrs2::expr::SharedExprBuilder<T, E>::eval(self) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::SharedExprBuilder<T, E>::into_expr(self) -> E
pub fn numrs2::expr::SharedExprBuilder<T, E>::map<F>(self, op: F) -> numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedUnaryExpr<T, E, F>> where F: core::ops::function::Fn(T) -> T + core::clone::Clone
impl<T: core::clone::Clone> numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedArrayExpr<T>>
pub fn numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedArrayExpr<T>>::from_array(array: numrs2::array::Array<T>) -> Self
pub fn numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedArrayExpr<T>>::from_shared_array(array: numrs2::shared_array::SharedArray<T>) -> Self
pub struct numrs2::expr::SharedScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
impl<T, E, F> numrs2::expr::SharedScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::new(expr: E, scalar: T, op: F) -> Self
impl<T, E, F> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::size(&self) -> usize
pub struct numrs2::expr::SharedUnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T) -> T + core::clone::Clone
impl<T, E, F> numrs2::expr::SharedUnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::new(expr: E, op: F) -> Self
impl<T, E, F> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedUnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::size(&self) -> usize
pub struct numrs2::expr::UnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T) -> T
impl<T, E, F> numrs2::expr::UnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T) -> T
pub fn numrs2::expr::UnaryExpr<T, E, F>::new(expr: E, op: F) -> Self
impl<E, F> numrs2::expr::SimdEval<f64> for numrs2::expr::UnaryExpr<f64, E, F> where E: numrs2::expr::Expr<f64>, F: core::ops::function::Fn(f64) -> f64
impl<T, E, F> numrs2::expr::Expr<T> for numrs2::expr::UnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T) -> T
pub fn numrs2::expr::UnaryExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::UnaryExpr<T, E, F>::shape(&self) -> &[usize]
pub fn numrs2::expr::UnaryExpr<T, E, F>::size(&self) -> usize
pub struct numrs2::expr::WhereExpr<T, C, Tr, Fa> where T: core::clone::Clone, C: numrs2::expr::Expr<bool>, Tr: numrs2::expr::Expr<T>, Fa: numrs2::expr::Expr<T>
impl<T, C, Tr, Fa> numrs2::expr::WhereExpr<T, C, Tr, Fa> where T: core::clone::Clone, C: numrs2::expr::Expr<bool>, Tr: numrs2::expr::Expr<T>, Fa: numrs2::expr::Expr<T>
pub fn numrs2::expr::WhereExpr<T, C, Tr, Fa>::new(condition: C, true_expr: Tr, false_expr: Fa) -> numrs2::Result<Self>
impl<T, C, Tr, Fa> numrs2::expr::Expr<T> for numrs2::expr::WhereExpr<T, C, Tr, Fa> where T: core::clone::Clone, C: numrs2::expr::Expr<bool>, Tr: numrs2::expr::Expr<T>, Fa: numrs2::expr::Expr<T>
pub fn numrs2::expr::WhereExpr<T, C, Tr, Fa>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::WhereExpr<T, C, Tr, Fa>::shape(&self) -> &[usize]
pub fn numrs2::expr::WhereExpr<T, C, Tr, Fa>::size(&self) -> usize
pub trait numrs2::expr::CSESupport<T: core::clone::Clone>: numrs2::expr::SharedExpr<T> + core::marker::Sized
pub fn numrs2::expr::CSESupport::with_cache(self, cache: numrs2::expr::ExprCache<T>) -> numrs2::expr::CachedExpr<T, Self>
pub fn numrs2::expr::CSESupport::with_cache_id(self, id: numrs2::expr::ExprId, cache: numrs2::expr::ExprCache<T>) -> numrs2::expr::CachedExpr<T, Self>
impl<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>> numrs2::expr::CSESupport<T> for E
pub trait numrs2::expr::Expr<T: core::clone::Clone>
pub fn numrs2::expr::Expr::can_fuse_with<E: numrs2::expr::Expr<T>>(&self, other: &E) -> bool
pub fn numrs2::expr::Expr::eval(&self) -> numrs2::array::Array<T>
pub fn numrs2::expr::Expr::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::Expr::shape(&self) -> &[usize]
pub fn numrs2::expr::Expr::size(&self) -> usize
impl<'a, T: core::clone::Clone> numrs2::expr::Expr<T> for numrs2::expr::ArrayExpr<'a, T>
pub fn numrs2::expr::ArrayExpr<'a, T>::eval(&self) -> numrs2::array::Array<T>
pub fn numrs2::expr::ArrayExpr<'a, T>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::ArrayExpr<'a, T>::shape(&self) -> &[usize]
pub fn numrs2::expr::ArrayExpr<'a, T>::size(&self) -> usize
impl<T, C, Tr, Fa> numrs2::expr::Expr<T> for numrs2::expr::WhereExpr<T, C, Tr, Fa> where T: core::clone::Clone, C: numrs2::expr::Expr<bool>, Tr: numrs2::expr::Expr<T>, Fa: numrs2::expr::Expr<T>
pub fn numrs2::expr::WhereExpr<T, C, Tr, Fa>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::WhereExpr<T, C, Tr, Fa>::shape(&self) -> &[usize]
pub fn numrs2::expr::WhereExpr<T, C, Tr, Fa>::size(&self) -> usize
impl<T, E, F> numrs2::expr::Expr<T> for numrs2::expr::ScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::expr::ScalarExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::ScalarExpr<T, E, F>::shape(&self) -> &[usize]
pub fn numrs2::expr::ScalarExpr<T, E, F>::size(&self) -> usize
impl<T, E, F> numrs2::expr::Expr<T> for numrs2::expr::UnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T) -> T
pub fn numrs2::expr::UnaryExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::UnaryExpr<T, E, F>::shape(&self) -> &[usize]
pub fn numrs2::expr::UnaryExpr<T, E, F>::size(&self) -> usize
impl<T, E> numrs2::expr::Expr<T> for numrs2::expr::ClipExpr<T, E> where T: core::clone::Clone + core::cmp::PartialOrd, E: numrs2::expr::Expr<T>
pub fn numrs2::expr::ClipExpr<T, E>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::ClipExpr<T, E>::shape(&self) -> &[usize]
pub fn numrs2::expr::ClipExpr<T, E>::size(&self) -> usize
impl<T, L, R, F> numrs2::expr::Expr<T> for numrs2::expr::BinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::Expr<T>, R: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::shape(&self) -> &[usize]
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::size(&self) -> usize
impl<T: core::clone::Clone> numrs2::expr::Expr<T> for numrs2::expr::BroadcastScalarExpr<T>
pub fn numrs2::expr::BroadcastScalarExpr<T>::eval_at(&self, _index: usize) -> T
pub fn numrs2::expr::BroadcastScalarExpr<T>::shape(&self) -> &[usize]
pub fn numrs2::expr::BroadcastScalarExpr<T>::size(&self) -> usize
pub trait numrs2::expr::LazyEval<T: core::clone::Clone>
pub fn numrs2::expr::LazyEval::lazy(&self) -> numrs2::expr::ArrayExpr<'_, T>
impl<T: core::clone::Clone> numrs2::expr::LazyEval<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::lazy(&self) -> numrs2::expr::ArrayExpr<'_, T>
pub trait numrs2::expr::SharedExpr<T: core::clone::Clone>: core::clone::Clone
pub fn numrs2::expr::SharedExpr::eval(&self) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::SharedExpr::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedExpr::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedExpr::size(&self) -> usize
impl<T, E, F> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::size(&self) -> usize
impl<T, E, F> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedUnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::size(&self) -> usize
impl<T, L, R, F> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedBinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::SharedExpr<T>, R: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::size(&self) -> usize
impl<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExpr<T> for numrs2::expr::CachedExpr<T, E>
pub fn numrs2::expr::CachedExpr<T, E>::eval(&self) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::CachedExpr<T, E>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::CachedExpr<T, E>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::CachedExpr<T, E>::size(&self) -> usize
impl<T: core::clone::Clone> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedArrayExpr<T>
pub fn numrs2::expr::SharedArrayExpr<T>::eval(&self) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::SharedArrayExpr<T>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedArrayExpr<T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedArrayExpr<T>::size(&self) -> usize
pub trait numrs2::expr::SimdEval<T: core::clone::Clone + core::marker::Copy>: numrs2::expr::Expr<T>
pub fn numrs2::expr::SimdEval::eval_batch(&self, start: usize, len: usize) -> alloc::vec::Vec<T>
pub fn numrs2::expr::SimdEval::eval_simd(&self) -> numrs2::array::Array<T>
impl<'a> numrs2::expr::SimdEval<f64> for numrs2::expr::ArrayExpr<'a, f64>
impl<E, F> numrs2::expr::SimdEval<f64> for numrs2::expr::ScalarExpr<f64, E, F> where E: numrs2::expr::Expr<f64>, F: core::ops::function::Fn(f64, f64) -> f64
impl<E, F> numrs2::expr::SimdEval<f64> for numrs2::expr::UnaryExpr<f64, E, F> where E: numrs2::expr::Expr<f64>, F: core::ops::function::Fn(f64) -> f64
impl<L, R, F> numrs2::expr::SimdEval<f64> for numrs2::expr::BinaryExpr<f64, L, R, F> where L: numrs2::expr::Expr<f64>, R: numrs2::expr::Expr<f64>, F: core::ops::function::Fn(f64, f64) -> f64
pub fn numrs2::expr::analyze_cse(keys: &[numrs2::expr::ExprKey]) -> numrs2::expr::CSEAnalysisResult
pub fn numrs2::expr::expr_prod<T, E>(expr: E) -> T where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + num_traits::identities::One, E: numrs2::expr::Expr<T>
pub fn numrs2::expr::expr_sum<T, E>(expr: E) -> T where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::default::Default, E: numrs2::expr::Expr<T>
pub fn numrs2::expr::fma<T, A, B, C>(a: A, b: B, c: C) -> numrs2::Result<impl numrs2::expr::Expr<T>> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>, A: numrs2::expr::Expr<T>, B: numrs2::expr::Expr<T>, C: numrs2::expr::Expr<T>
pub fn numrs2::expr::hash_f64(value: f64) -> u64
pub mod numrs2::fft
pub use numrs2::fft::<<scirs2_fft::*>>
pub mod numrs2::financial
pub struct numrs2::financial::AmortizationSchedule<T>
pub numrs2::financial::AmortizationSchedule::balances: alloc::vec::Vec<T>
pub numrs2::financial::AmortizationSchedule::interests: alloc::vec::Vec<T>
pub numrs2::financial::AmortizationSchedule::payments: alloc::vec::Vec<T>
pub numrs2::financial::AmortizationSchedule::periods: alloc::vec::Vec<usize>
pub numrs2::financial::AmortizationSchedule::principals: alloc::vec::Vec<T>
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::financial::AmortizationSchedule<T>
pub fn numrs2::financial::AmortizationSchedule<T>::total_interest(&self) -> T
pub fn numrs2::financial::AmortizationSchedule<T>::total_payments(&self) -> T
pub trait numrs2::financial::FinancialCalculation<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::FinancialCalculation::calculate(&self) -> numrs2::Result<T>
pub fn numrs2::financial::accrued_interest<T>(coupon_rate: T, face_value: T, days_since_last_coupon: T, days_in_coupon_period: T) -> T where T: num_traits::float::Float
pub fn numrs2::financial::amortization_schedule<T>(principal: T, rate: T, nper: usize) -> numrs2::Result<numrs2::financial::AmortizationSchedule<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::annuity_factor<T: num_traits::float::Float>(rate: T, nper: T) -> T
pub fn numrs2::financial::binomial_option_price<T>(spot_price: T, strike_price: T, time_to_expiry: T, risk_free_rate: T, volatility: T, steps: usize, option_type: &str, exercise_style: &str) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::black_scholes<T>(spot_price: T, strike_price: T, time_to_expiry: T, risk_free_rate: T, volatility: T, option_type: &str) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::financial::black_scholes_greeks<T>(spot_price: T, strike_price: T, time_to_expiry: T, risk_free_rate: T, volatility: T, option_type: &str) -> numrs2::Result<(T, T, T, T, T)> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::financial::bond_convexity<T>(cash_flows: &numrs2::array::Array<T>, periods: &numrs2::array::Array<T>, yield_rate: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::bond_duration<T>(cash_flows: &numrs2::array::Array<T>, periods: &numrs2::array::Array<T>, yield_rate: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::bond_equivalent_yield<T>(discount_rate: T, days_to_maturity: T) -> T where T: num_traits::float::Float
pub fn numrs2::financial::bond_price<T>(cash_flows: &numrs2::array::Array<T>, periods: &numrs2::array::Array<T>, yield_rate: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::bond_yield<T>(price: T, cash_flows: &numrs2::array::Array<T>, periods: &numrs2::array::Array<T>, initial_guess: core::option::Option<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::compound_factor<T: num_traits::float::Float>(rate: T, nper: T) -> T
pub fn numrs2::financial::cumipmt<T>(rate: T, nper: usize, pv: T, start_period: usize, end_period: usize, when: u8) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::cumprinc<T>(rate: T, nper: usize, pv: T, start_period: usize, end_period: usize, when: u8) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::db<T>(cost: T, salvage: T, life: usize, period: usize, month: usize) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::financial::ddb<T>(cost: T, salvage: T, life: usize, period: usize, factor: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::financial::effect<T>(nominal_rate: T, nper: usize) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::financial::fv<T>(rate: T, nper: T, pmt: T, pv: T, when: i32) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::fv_array<T>(rate: &numrs2::array::Array<T>, nper: &numrs2::array::Array<T>, pmt: &numrs2::array::Array<T>, pv: &numrs2::array::Array<T>, when: i32) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::implied_volatility<T>(market_price: T, spot_price: T, strike_price: T, time_to_expiry: T, risk_free_rate: T, option_type: &str, initial_vol: core::option::Option<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::financial::ipmt<T>(rate: T, per: usize, nper: usize, pv: T, fv: T, when: u8) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::irr<T>(values: &numrs2::array::Array<T>, guess: core::option::Option<T>, tol: core::option::Option<T>, maxiter: core::option::Option<usize>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::irr_multiple_series<T>(values_matrix: &numrs2::array::Array<T>, guess: core::option::Option<T>, tol: core::option::Option<T>, maxiter: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::mirr<T>(values: &numrs2::array::Array<T>, finance_rate: T, reinvest_rate: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::modified_duration<T>(macaulay_duration: T, yield_rate: T) -> T where T: num_traits::float::Float
pub fn numrs2::financial::nominal<T>(effective_rate: T, nper: usize) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::financial::nper<T>(rate: T, pmt: T, pv: T, fv: T, when: i32) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::nper_array<T>(rate: &numrs2::array::Array<T>, pmt: &numrs2::array::Array<T>, pv: &numrs2::array::Array<T>, fv: &numrs2::array::Array<T>, when: i32) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::npv<T>(rate: T, values: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::npv_multiple_series<T>(rate: T, values_matrix: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::npv_rates<T>(rates: &numrs2::array::Array<T>, values: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::pmt<T>(rate: T, nper: T, pv: T, fv: T, when: i32) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::pmt_array<T>(rate: &numrs2::array::Array<T>, nper: &numrs2::array::Array<T>, pv: &numrs2::array::Array<T>, fv: &numrs2::array::Array<T>, when: i32) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::ppmt<T>(rate: T, per: usize, nper: usize, pv: T, fv: T, when: u8) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::pv<T>(rate: T, nper: T, pmt: T, fv: T, when: i32) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::pv_array<T>(rate: &numrs2::array::Array<T>, nper: &numrs2::array::Array<T>, pmt: &numrs2::array::Array<T>, fv: &numrs2::array::Array<T>, when: i32) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::rate<T>(nper: T, pmt: T, pv: T, fv: T, when: i32, guess: core::option::Option<T>, tol: core::option::Option<T>, maxiter: core::option::Option<usize>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::rate_array<T>(nper: &numrs2::array::Array<T>, pmt: &numrs2::array::Array<T>, pv: &numrs2::array::Array<T>, fv: &numrs2::array::Array<T>, when: i32, guess: core::option::Option<T>, tol: core::option::Option<T>, maxiter: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::financial::sln<T>(cost: T, salvage: T, life: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::financial::syd<T>(cost: T, salvage: T, life: usize, per: usize) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::financial::validate_financial_params<T: num_traits::float::Float + core::fmt::Debug>(rate: T, nper: T, pmt: T, pv: T, fv: T) -> numrs2::Result<()>
pub mod numrs2::indexing
pub enum numrs2::indexing::IndexSpec
pub numrs2::indexing::IndexSpec::All
pub numrs2::indexing::IndexSpec::Ellipsis
pub numrs2::indexing::IndexSpec::Index(usize)
pub numrs2::indexing::IndexSpec::Indices(alloc::vec::Vec<usize>)
pub numrs2::indexing::IndexSpec::Mask(alloc::vec::Vec<bool>)
pub numrs2::indexing::IndexSpec::NewAxis
pub numrs2::indexing::IndexSpec::Slice(usize, core::option::Option<usize>, core::option::Option<usize>)
impl numrs2::indexing::IndexSpec
pub fn numrs2::indexing::IndexSpec::ellipsis() -> Self
pub fn numrs2::indexing::IndexSpec::from_indices(indices: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::indexing::IndexSpec::from_mask(mask: alloc::vec::Vec<bool>) -> Self
pub fn numrs2::indexing::IndexSpec::from_range(range: core::ops::range::Range<usize>) -> Self
pub fn numrs2::indexing::IndexSpec::newaxis() -> Self
pub fn numrs2::indexing::IndexSpec::slice(start: usize, end: core::option::Option<usize>, step: core::option::Option<usize>) -> Self
pub fn numrs2::indexing::diag_indices(n: usize, ndim: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>>
pub fn numrs2::indexing::diag_indices_from<T: core::clone::Clone>(arr: &numrs2::array::Array<T>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>>
pub fn numrs2::indexing::extract<T: core::clone::Clone + alloc::string::ToString, U: core::clone::Clone + alloc::string::ToString>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::indexing::indices_grid<T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + num_traits::cast::NumCast>(shape: &[usize]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::indexing::ix_<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::indexing::mask_indices<F>(shape: &[usize], mask_fn: F) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>> where F: core::ops::function::Fn(&[usize]) -> bool
pub fn numrs2::indexing::put<T: core::clone::Clone + alloc::string::ToString>(array: &mut numrs2::array::Array<T>, indices: &numrs2::array::Array<T>, values: &numrs2::array::Array<T>, mode: core::option::Option<&str>) -> numrs2::Result<()>
pub fn numrs2::indexing::put_along_axis<T: core::clone::Clone + alloc::string::ToString>(array: &mut numrs2::array::Array<T>, indices: &numrs2::array::Array<T>, values: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<()>
pub fn numrs2::indexing::putmask<T: core::clone::Clone + alloc::string::ToString, U: core::clone::Clone + alloc::string::ToString>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<U>, values: &numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::indexing::ravel_multi_index(multi_index: &[numrs2::array::Array<usize>], dims: &[usize], mode: &str) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::indexing::take<T: core::clone::Clone + alloc::string::ToString + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &numrs2::array::Array<T>, axis: core::option::Option<usize>, mode: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::indexing::take_along_axis<T: core::clone::Clone + alloc::string::ToString>(array: &numrs2::array::Array<T>, indices: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::indexing::tril_indices(n: usize, k: isize, m: core::option::Option<usize>) -> numrs2::Result<(numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::indexing::tril_indices_from<T: core::clone::Clone>(arr: &numrs2::array::Array<T>, k: core::option::Option<isize>) -> numrs2::Result<(numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::indexing::triu_indices(n: usize, k: isize, m: core::option::Option<usize>) -> numrs2::Result<(numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::indexing::triu_indices_from<T: core::clone::Clone>(arr: &numrs2::array::Array<T>, k: core::option::Option<isize>) -> numrs2::Result<(numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::indexing::unravel_index(indices: &numrs2::array::Array<usize>, dims: &[usize]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>>
pub mod numrs2::integrate
pub struct numrs2::integrate::IntegrationResult<T>
pub numrs2::integrate::IntegrationResult::error: T
pub numrs2::integrate::IntegrationResult::neval: usize
pub numrs2::integrate::IntegrationResult::success: bool
pub numrs2::integrate::IntegrationResult::value: T
pub struct numrs2::integrate::QuadConfig<T>
pub numrs2::integrate::QuadConfig::atol: T
pub numrs2::integrate::QuadConfig::max_depth: usize
pub numrs2::integrate::QuadConfig::max_subdivisions: usize
pub numrs2::integrate::QuadConfig::rtol: T
impl<T: num_traits::float::Float> core::default::Default for numrs2::integrate::QuadConfig<T>
pub fn numrs2::integrate::QuadConfig<T>::default() -> Self
pub fn numrs2::integrate::cumtrapz<T>(y: &[T], dx: T) -> alloc::vec::Vec<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::integrate::dblquad<T, F>(f: F, xa: T, xb: T, ya: T, yb: T, nx: usize, ny: usize) -> T where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::integrate::fixed_point_integral<T, F>(f: F, a: T, b: T, x0: T, max_iter: usize, tol: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::integrate::gauss_legendre<T, F>(f: F, a: T, b: T, n: usize) -> T where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(T) -> T
pub fn numrs2::integrate::monte_carlo<T, F>(f: F, a: T, b: T, n_samples: usize) -> numrs2::integrate::IntegrationResult<T> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(T) -> T
pub fn numrs2::integrate::monte_carlo_nd<T, F>(f: F, bounds: &[(T, T)], n_samples: usize) -> numrs2::integrate::IntegrationResult<T> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(&[T]) -> T
pub fn numrs2::integrate::quad<T, F>(f: F, a: T, b: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(T) -> T
pub fn numrs2::integrate::quad_adaptive<T, F>(f: &F, a: T, b: T, config: &numrs2::integrate::QuadConfig<T>) -> numrs2::Result<numrs2::integrate::IntegrationResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(T) -> T
pub fn numrs2::integrate::romberg<T, F>(f: F, a: T, b: T, max_order: usize) -> T where T: num_traits::float::Float + core::fmt::Debug, F: core::ops::function::Fn(T) -> T
pub fn numrs2::integrate::simps<T, F>(f: F, a: T, b: T, n: usize) -> T where T: num_traits::float::Float + core::fmt::Debug, F: core::ops::function::Fn(T) -> T
pub fn numrs2::integrate::trapz<T, F>(f: F, a: T, b: T, n: usize) -> T where T: num_traits::float::Float + core::fmt::Debug, F: core::ops::function::Fn(T) -> T
pub fn numrs2::integrate::trapz_array<T>(x: &[T], y: &[T]) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub mod numrs2::interop
pub mod numrs2::interop::ndarray_compat
pub fn numrs2::interop::ndarray_compat::from_ndarray<T, D>(ndarr: &ndarray::Array<T, D>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast, D: ndarray::dimension::dimension_trait::Dimension
pub fn numrs2::interop::ndarray_compat::to_ndarray<T>(arr: &numrs2::array::Array<T>) -> numrs2::Result<ndarray::aliases::ArrayD<T>> where T: core::clone::Clone + core::fmt::Debug
pub mod numrs2::interop::scirs_compat
pub fn numrs2::interop::scirs_compat::multivariate_normal_with_rotation<T>(mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>, rotation: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::interop::scirs_compat::noncentral_chisquare<T>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::interop::scirs_compat::noncentral_f<T>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::interop::scirs_compat::truncated_normal<T>(mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::interop::scirs_compat::vonmises<T>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub mod numrs2::interpolate
pub enum numrs2::interpolate::Interp1DKind
pub numrs2::interpolate::Interp1DKind::Cubic
pub numrs2::interpolate::Interp1DKind::Linear
pub numrs2::interpolate::Interp1DKind::Nearest
pub enum numrs2::interpolate::SplineBoundary<T>
pub numrs2::interpolate::SplineBoundary::Clamped(T, T)
pub numrs2::interpolate::SplineBoundary::Natural
pub numrs2::interpolate::SplineBoundary::NotAKnot
pub numrs2::interpolate::SplineBoundary::Periodic
pub struct numrs2::interpolate::BilinearInterp<T>
impl<T> numrs2::interpolate::BilinearInterp<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::interpolate::BilinearInterp<T>::evaluate(&self, x: T, y: T) -> numrs2::Result<T>
pub fn numrs2::interpolate::BilinearInterp<T>::new(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, z: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub struct numrs2::interpolate::CubicSplineInterp<T>
impl<T> numrs2::interpolate::CubicSplineInterp<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::interpolate::CubicSplineInterp<T>::clamped(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, dy0: T, dyn_: T) -> numrs2::Result<Self>
pub fn numrs2::interpolate::CubicSplineInterp<T>::derivative(&self, x: T) -> numrs2::Result<T>
pub fn numrs2::interpolate::CubicSplineInterp<T>::evaluate(&self, x: T) -> numrs2::Result<T>
pub fn numrs2::interpolate::CubicSplineInterp<T>::evaluate_array(&self, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::interpolate::CubicSplineInterp<T>::natural(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub fn numrs2::interpolate::CubicSplineInterp<T>::new(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, boundary: numrs2::interpolate::SplineBoundary<T>) -> numrs2::Result<Self>
pub fn numrs2::interpolate::CubicSplineInterp<T>::not_a_knot(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub struct numrs2::interpolate::Interp1D<T>
impl<T> numrs2::interpolate::Interp1D<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::interpolate::Interp1D<T>::cubic(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub fn numrs2::interpolate::Interp1D<T>::evaluate(&self, x: T) -> numrs2::Result<T>
pub fn numrs2::interpolate::Interp1D<T>::evaluate_array(&self, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::interpolate::Interp1D<T>::linear(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub fn numrs2::interpolate::Interp1D<T>::nearest(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub fn numrs2::interpolate::Interp1D<T>::new(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, kind: numrs2::interpolate::Interp1DKind) -> numrs2::Result<Self>
pub fn numrs2::interpolate::Interp1D<T>::x(&self) -> &[T]
pub fn numrs2::interpolate::Interp1D<T>::y(&self) -> &[T]
pub mod numrs2::io
pub mod numrs2::io::text
pub struct numrs2::io::text::GenFromTxtOptions
pub numrs2::io::text::GenFromTxtOptions::autostrip: bool
pub numrs2::io::text::GenFromTxtOptions::case_sensitive: bool
pub numrs2::io::text::GenFromTxtOptions::comments: alloc::string::String
pub numrs2::io::text::GenFromTxtOptions::converters: std::collections::hash::map::HashMap<usize, numrs2::io::ConverterFn>
pub numrs2::io::text::GenFromTxtOptions::default_missing: alloc::vec::Vec<alloc::string::String>
pub numrs2::io::text::GenFromTxtOptions::deletechars: alloc::string::String
pub numrs2::io::text::GenFromTxtOptions::delimiter: core::option::Option<alloc::string::String>
pub numrs2::io::text::GenFromTxtOptions::dtype: alloc::string::String
pub numrs2::io::text::GenFromTxtOptions::encoding: alloc::string::String
pub numrs2::io::text::GenFromTxtOptions::excludelist: core::option::Option<alloc::vec::Vec<alloc::string::String>>
pub numrs2::io::text::GenFromTxtOptions::filling_values: std::collections::hash::map::HashMap<usize, alloc::string::String>
pub numrs2::io::text::GenFromTxtOptions::max_rows: core::option::Option<usize>
pub numrs2::io::text::GenFromTxtOptions::missing_values: std::collections::hash::map::HashMap<usize, alloc::vec::Vec<alloc::string::String>>
pub numrs2::io::text::GenFromTxtOptions::names: core::option::Option<alloc::vec::Vec<alloc::string::String>>
pub numrs2::io::text::GenFromTxtOptions::replace_space: core::option::Option<char>
pub numrs2::io::text::GenFromTxtOptions::skip_footer: usize
pub numrs2::io::text::GenFromTxtOptions::skip_header: usize
pub numrs2::io::text::GenFromTxtOptions::usecols: core::option::Option<alloc::vec::Vec<usize>>
impl core::default::Default for numrs2::io::GenFromTxtOptions
pub fn numrs2::io::GenFromTxtOptions::default() -> Self
pub struct numrs2::io::text::LoadTxtOptions
pub numrs2::io::text::LoadTxtOptions::comments: alloc::string::String
pub numrs2::io::text::LoadTxtOptions::delimiter: core::option::Option<alloc::string::String>
pub numrs2::io::text::LoadTxtOptions::max_rows: core::option::Option<usize>
pub numrs2::io::text::LoadTxtOptions::ndmin: usize
pub numrs2::io::text::LoadTxtOptions::skiprows: usize
pub numrs2::io::text::LoadTxtOptions::usecols: core::option::Option<alloc::vec::Vec<usize>>
impl core::default::Default for numrs2::io::LoadTxtOptions
pub fn numrs2::io::LoadTxtOptions::default() -> Self
pub struct numrs2::io::text::SaveTxtOptions
pub numrs2::io::text::SaveTxtOptions::comments: alloc::string::String
pub numrs2::io::text::SaveTxtOptions::delimiter: alloc::string::String
pub numrs2::io::text::SaveTxtOptions::fmt: alloc::string::String
pub numrs2::io::text::SaveTxtOptions::footer: core::option::Option<alloc::string::String>
pub numrs2::io::text::SaveTxtOptions::header: core::option::Option<alloc::string::String>
pub numrs2::io::text::SaveTxtOptions::newline: alloc::string::String
impl core::default::Default for numrs2::io::SaveTxtOptions
pub fn numrs2::io::SaveTxtOptions::default() -> Self
pub fn numrs2::io::text::detect_delimiter(fname: &std::path::Path, sample_lines: core::option::Option<usize>) -> numrs2::Result<alloc::string::String>
pub fn numrs2::io::text::fromregex<T>(fname: &std::path::Path, regexp: &str, dtype: &str, encoding: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::default::Default + core::str::traits::FromStr + num_traits::identities::Zero, <T as core::str::traits::FromStr>::Err: core::fmt::Debug
pub fn numrs2::io::text::genfromtxt<T>(fname: &std::path::Path, options: numrs2::io::GenFromTxtOptions) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::default::Default + core::str::traits::FromStr + num_traits::identities::Zero + num_traits::Num, <T as core::str::traits::FromStr>::Err: core::fmt::Debug
pub fn numrs2::io::text::loadtxt<T>(fname: &std::path::Path, options: numrs2::io::LoadTxtOptions) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::default::Default + core::str::traits::FromStr + num_traits::identities::Zero, <T as core::str::traits::FromStr>::Err: core::fmt::Debug
pub fn numrs2::io::text::savetxt<T>(fname: &std::path::Path, X: &numrs2::array::Array<T>, options: numrs2::io::SaveTxtOptions) -> numrs2::Result<()> where T: core::clone::Clone + core::fmt::Display + num_traits::identities::Zero
pub fn numrs2::io::text::savez_compressed<T: core::clone::Clone + serde_core::ser::Serialize>(fname: &std::path::Path, arrays: &std::collections::hash::map::HashMap<alloc::string::String, numrs2::array::Array<T>>) -> numrs2::Result<()>
pub type numrs2::io::text::ConverterFn = alloc::boxed::Box<dyn core::ops::function::Fn(&str) -> numrs2::Result<alloc::string::String>>
pub enum numrs2::io::SerializeFormat
pub numrs2::io::SerializeFormat::Binary
pub numrs2::io::SerializeFormat::Csv
pub numrs2::io::SerializeFormat::Json
pub numrs2::io::SerializeFormat::Npy
pub numrs2::io::SerializeFormat::Npz
pub numrs2::io::SerializeFormat::Pickle
pub struct numrs2::io::GenFromTxtOptions
pub numrs2::io::GenFromTxtOptions::autostrip: bool
pub numrs2::io::GenFromTxtOptions::case_sensitive: bool
pub numrs2::io::GenFromTxtOptions::comments: alloc::string::String
pub numrs2::io::GenFromTxtOptions::converters: std::collections::hash::map::HashMap<usize, numrs2::io::ConverterFn>
pub numrs2::io::GenFromTxtOptions::default_missing: alloc::vec::Vec<alloc::string::String>
pub numrs2::io::GenFromTxtOptions::deletechars: alloc::string::String
pub numrs2::io::GenFromTxtOptions::delimiter: core::option::Option<alloc::string::String>
pub numrs2::io::GenFromTxtOptions::dtype: alloc::string::String
pub numrs2::io::GenFromTxtOptions::encoding: alloc::string::String
pub numrs2::io::GenFromTxtOptions::excludelist: core::option::Option<alloc::vec::Vec<alloc::string::String>>
pub numrs2::io::GenFromTxtOptions::filling_values: std::collections::hash::map::HashMap<usize, alloc::string::String>
pub numrs2::io::GenFromTxtOptions::max_rows: core::option::Option<usize>
pub numrs2::io::GenFromTxtOptions::missing_values: std::collections::hash::map::HashMap<usize, alloc::vec::Vec<alloc::string::String>>
pub numrs2::io::GenFromTxtOptions::names: core::option::Option<alloc::vec::Vec<alloc::string::String>>
pub numrs2::io::GenFromTxtOptions::replace_space: core::option::Option<char>
pub numrs2::io::GenFromTxtOptions::skip_footer: usize
pub numrs2::io::GenFromTxtOptions::skip_header: usize
pub numrs2::io::GenFromTxtOptions::usecols: core::option::Option<alloc::vec::Vec<usize>>
impl core::default::Default for numrs2::io::GenFromTxtOptions
pub fn numrs2::io::GenFromTxtOptions::default() -> Self
pub struct numrs2::io::LoadTxtOptions
pub numrs2::io::LoadTxtOptions::comments: alloc::string::String
pub numrs2::io::LoadTxtOptions::delimiter: core::option::Option<alloc::string::String>
pub numrs2::io::LoadTxtOptions::max_rows: core::option::Option<usize>
pub numrs2::io::LoadTxtOptions::ndmin: usize
pub numrs2::io::LoadTxtOptions::skiprows: usize
pub numrs2::io::LoadTxtOptions::usecols: core::option::Option<alloc::vec::Vec<usize>>
impl core::default::Default for numrs2::io::LoadTxtOptions
pub fn numrs2::io::LoadTxtOptions::default() -> Self
pub struct numrs2::io::SaveTxtOptions
pub numrs2::io::SaveTxtOptions::comments: alloc::string::String
pub numrs2::io::SaveTxtOptions::delimiter: alloc::string::String
pub numrs2::io::SaveTxtOptions::fmt: alloc::string::String
pub numrs2::io::SaveTxtOptions::footer: core::option::Option<alloc::string::String>
pub numrs2::io::SaveTxtOptions::header: core::option::Option<alloc::string::String>
pub numrs2::io::SaveTxtOptions::newline: alloc::string::String
impl core::default::Default for numrs2::io::SaveTxtOptions
pub fn numrs2::io::SaveTxtOptions::default() -> Self
pub fn numrs2::io::array_to_vec2d<T: core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<T>>>
pub fn numrs2::io::deserialize_from_file<T: core::clone::Clone, R: std::io::Read + std::io::Seek>(reader: R, format: numrs2::io::SerializeFormat) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::io::detect_delimiter(fname: &std::path::Path, sample_lines: core::option::Option<usize>) -> numrs2::Result<alloc::string::String>
pub fn numrs2::io::fromregex<T>(fname: &std::path::Path, regexp: &str, dtype: &str, encoding: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::default::Default + core::str::traits::FromStr + num_traits::identities::Zero, <T as core::str::traits::FromStr>::Err: core::fmt::Debug
pub fn numrs2::io::genfromtxt<T>(fname: &std::path::Path, options: numrs2::io::GenFromTxtOptions) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::default::Default + core::str::traits::FromStr + num_traits::identities::Zero + num_traits::Num, <T as core::str::traits::FromStr>::Err: core::fmt::Debug
pub fn numrs2::io::list_npz_arrays<R: std::io::Read + std::io::Seek>(reader: R) -> numrs2::Result<alloc::vec::Vec<alloc::string::String>>
pub fn numrs2::io::load_all_npz_arrays<T: core::clone::Clone, R: std::io::Read + std::io::Seek>(reader: R) -> numrs2::Result<std::collections::hash::map::HashMap<alloc::string::String, numrs2::array::Array<T>>>
pub fn numrs2::io::load_npz_array<T: core::clone::Clone, R: std::io::Read + std::io::Seek>(reader: R, array_name: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::io::loadtxt<T>(fname: &std::path::Path, options: numrs2::io::LoadTxtOptions) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::default::Default + core::str::traits::FromStr + num_traits::identities::Zero, <T as core::str::traits::FromStr>::Err: core::fmt::Debug
pub fn numrs2::io::save_npz_arrays<T: core::clone::Clone, W: std::io::Write + std::io::Seek>(arrays: &std::collections::hash::map::HashMap<alloc::string::String, numrs2::array::Array<T>>, writer: W, compressed: bool) -> numrs2::Result<()>
pub fn numrs2::io::savetxt<T>(fname: &std::path::Path, X: &numrs2::array::Array<T>, options: numrs2::io::SaveTxtOptions) -> numrs2::Result<()> where T: core::clone::Clone + core::fmt::Display + num_traits::identities::Zero
pub fn numrs2::io::savez_compressed<T: core::clone::Clone + serde_core::ser::Serialize>(fname: &std::path::Path, arrays: &std::collections::hash::map::HashMap<alloc::string::String, numrs2::array::Array<T>>) -> numrs2::Result<()>
pub fn numrs2::io::serialize_to_file<T: core::clone::Clone, W: std::io::Write + std::io::Seek>(array: &numrs2::array::Array<T>, writer: &mut W, format: numrs2::io::SerializeFormat) -> numrs2::Result<()>
pub fn numrs2::io::vec2d_to_array<T: core::clone::Clone>(vec: alloc::vec::Vec<alloc::vec::Vec<T>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::io::vec_to_array<T: core::clone::Clone>(vec: alloc::vec::Vec<T>, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub type numrs2::io::ConverterFn = alloc::boxed::Box<dyn core::ops::function::Fn(&str) -> numrs2::Result<alloc::string::String>>
pub mod numrs2::linalg
pub mod numrs2::linalg::decomposition
pub mod numrs2::linalg::iterative_solvers
pub struct numrs2::linalg::iterative_solvers::CustomPreconditioner<T, F> where F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T, F> numrs2::linalg::iterative_solvers::CustomPreconditioner<T, F> where F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::iterative_solvers::CustomPreconditioner<T, F>::new(apply_fn: F) -> Self
impl<T: num_traits::float::Float + core::clone::Clone, F> numrs2::linalg::iterative_solvers::Preconditioner<T> for numrs2::linalg::iterative_solvers::CustomPreconditioner<T, F> where F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::iterative_solvers::CustomPreconditioner<T, F>::apply(&self, r: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub struct numrs2::linalg::iterative_solvers::IdentityPreconditioner
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::linalg::iterative_solvers::Preconditioner<T> for numrs2::linalg::iterative_solvers::IdentityPreconditioner
pub fn numrs2::linalg::iterative_solvers::IdentityPreconditioner::apply(&self, r: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub struct numrs2::linalg::iterative_solvers::IncompleteCholeskyPreconditioner<T: core::clone::Clone>
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::linalg::iterative_solvers::IncompleteCholeskyPreconditioner<T>
pub fn numrs2::linalg::iterative_solvers::IncompleteCholeskyPreconditioner<T>::new(a: &numrs2::array::Array<T>) -> numrs2::Result<Self>
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::linalg::iterative_solvers::Preconditioner<T> for numrs2::linalg::iterative_solvers::IncompleteCholeskyPreconditioner<T>
pub fn numrs2::linalg::iterative_solvers::IncompleteCholeskyPreconditioner<T>::apply(&self, r: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub struct numrs2::linalg::iterative_solvers::JacobiPreconditioner<T>
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::linalg::iterative_solvers::JacobiPreconditioner<T>
pub fn numrs2::linalg::iterative_solvers::JacobiPreconditioner<T>::new(a: &numrs2::array::Array<T>) -> numrs2::Result<Self>
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::linalg::iterative_solvers::Preconditioner<T> for numrs2::linalg::iterative_solvers::JacobiPreconditioner<T>
pub fn numrs2::linalg::iterative_solvers::JacobiPreconditioner<T>::apply(&self, r: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub struct numrs2::linalg::iterative_solvers::RefinementConfig<T: num_traits::float::Float>
pub numrs2::linalg::iterative_solvers::RefinementConfig::max_iter: usize
pub numrs2::linalg::iterative_solvers::RefinementConfig::min_improvement: T
pub numrs2::linalg::iterative_solvers::RefinementConfig::tol: T
impl<T: num_traits::float::Float> core::default::Default for numrs2::linalg::iterative_solvers::RefinementConfig<T>
pub fn numrs2::linalg::iterative_solvers::RefinementConfig<T>::default() -> Self
pub struct numrs2::linalg::iterative_solvers::RefinementResult<T: core::clone::Clone>
pub numrs2::linalg::iterative_solvers::RefinementResult::converged: bool
pub numrs2::linalg::iterative_solvers::RefinementResult::final_residual: T
pub numrs2::linalg::iterative_solvers::RefinementResult::improvement_factor: T
pub numrs2::linalg::iterative_solvers::RefinementResult::initial_residual: T
pub numrs2::linalg::iterative_solvers::RefinementResult::iterations: usize
pub numrs2::linalg::iterative_solvers::RefinementResult::solution: numrs2::array::Array<T>
pub struct numrs2::linalg::iterative_solvers::SSORPreconditioner<T: core::clone::Clone>
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::linalg::iterative_solvers::SSORPreconditioner<T>
pub fn numrs2::linalg::iterative_solvers::SSORPreconditioner<T>::new(a: &numrs2::array::Array<T>, omega: T) -> numrs2::Result<Self>
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::linalg::iterative_solvers::Preconditioner<T> for numrs2::linalg::iterative_solvers::SSORPreconditioner<T>
pub fn numrs2::linalg::iterative_solvers::SSORPreconditioner<T>::apply(&self, r: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub struct numrs2::linalg::iterative_solvers::SolverConfig<T: num_traits::float::Float>
pub numrs2::linalg::iterative_solvers::SolverConfig::max_iter: usize
pub numrs2::linalg::iterative_solvers::SolverConfig::restart: core::option::Option<usize>
pub numrs2::linalg::iterative_solvers::SolverConfig::tol: T
pub numrs2::linalg::iterative_solvers::SolverConfig::use_preconditioner: bool
impl<T: num_traits::float::Float> core::default::Default for numrs2::linalg::iterative_solvers::SolverConfig<T>
pub fn numrs2::linalg::iterative_solvers::SolverConfig<T>::default() -> Self
pub struct numrs2::linalg::iterative_solvers::SolverResult<T: core::clone::Clone>
pub numrs2::linalg::iterative_solvers::SolverResult::converged: bool
pub numrs2::linalg::iterative_solvers::SolverResult::iterations: usize
pub numrs2::linalg::iterative_solvers::SolverResult::residual_norm: T
pub numrs2::linalg::iterative_solvers::SolverResult::solution: numrs2::array::Array<T>
pub trait numrs2::linalg::iterative_solvers::Preconditioner<T: num_traits::float::Float + core::clone::Clone>
pub fn numrs2::linalg::iterative_solvers::Preconditioner::apply(&self, r: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: num_traits::float::Float + core::clone::Clone, F> numrs2::linalg::iterative_solvers::Preconditioner<T> for numrs2::linalg::iterative_solvers::CustomPreconditioner<T, F> where F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::iterative_solvers::CustomPreconditioner<T, F>::apply(&self, r: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::linalg::iterative_solvers::Preconditioner<T> for numrs2::linalg::iterative_solvers::IdentityPreconditioner
pub fn numrs2::linalg::iterative_solvers::IdentityPreconditioner::apply(&self, r: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::linalg::iterative_solvers::Preconditioner<T> for numrs2::linalg::iterative_solvers::IncompleteCholeskyPreconditioner<T>
pub fn numrs2::linalg::iterative_solvers::IncompleteCholeskyPreconditioner<T>::apply(&self, r: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::linalg::iterative_solvers::Preconditioner<T> for numrs2::linalg::iterative_solvers::JacobiPreconditioner<T>
pub fn numrs2::linalg::iterative_solvers::JacobiPreconditioner<T>::apply(&self, r: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::linalg::iterative_solvers::Preconditioner<T> for numrs2::linalg::iterative_solvers::SSORPreconditioner<T>
pub fn numrs2::linalg::iterative_solvers::SSORPreconditioner<T>::apply(&self, r: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::iterative_solvers::bicgstab<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::SolverResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::linalg::iterative_solvers::conjugate_gradient<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::SolverResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::linalg::iterative_solvers::fgmres<T, F>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, preconditioner: F, x0: core::option::Option<&numrs2::array::Array<T>>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>, restart: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::SolverResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::iterative_solvers::fgmres_jacobi<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>, restart: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::SolverResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::linalg::iterative_solvers::gmres<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>, restart: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::SolverResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::linalg::iterative_solvers::gmres_jacobi<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>, restart: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::SolverResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::linalg::iterative_solvers::gmres_precond<T, P>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, preconditioner: &P, x0: core::option::Option<&numrs2::array::Array<T>>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>, restart: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::SolverResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero, P: numrs2::linalg::iterative_solvers::Preconditioner<T>
pub fn numrs2::linalg::iterative_solvers::iterative_refinement<T, F>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x0: &numrs2::array::Array<T>, solver: F, config: core::option::Option<numrs2::linalg::iterative_solvers::RefinementConfig<T>>) -> numrs2::Result<numrs2::linalg::iterative_solvers::RefinementResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + core::fmt::Debug + core::ops::arith::AddAssign, F: core::ops::function::Fn(&numrs2::array::Array<T>, &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::iterative_solvers::iterative_refinement_bicgstab<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x0: &numrs2::array::Array<T>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::RefinementResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + core::fmt::Debug + core::ops::arith::AddAssign
pub fn numrs2::linalg::iterative_solvers::iterative_refinement_cg<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x0: &numrs2::array::Array<T>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::RefinementResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + core::fmt::Debug + core::ops::arith::AddAssign
pub fn numrs2::linalg::iterative_solvers::minres<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::SolverResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::linalg::iterative_solvers::pcg<T, P>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, preconditioner: &P, x0: core::option::Option<&numrs2::array::Array<T>>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::SolverResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero, P: numrs2::linalg::iterative_solvers::Preconditioner<T>
pub fn numrs2::linalg::iterative_solvers::pcg_ichol<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::SolverResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::linalg::iterative_solvers::pcg_jacobi<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::SolverResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::linalg::iterative_solvers::pcg_ssor<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, omega: T, x0: core::option::Option<&numrs2::array::Array<T>>, tol: core::option::Option<T>, max_iter: core::option::Option<usize>) -> numrs2::Result<numrs2::linalg::iterative_solvers::SolverResult<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero
pub mod numrs2::linalg::matrix_ops
pub mod numrs2::linalg::randomized
pub enum numrs2::linalg::randomized::ProjectionType
pub numrs2::linalg::randomized::ProjectionType::Gaussian
pub numrs2::linalg::randomized::ProjectionType::Rademacher
pub numrs2::linalg::randomized::ProjectionType::Sparse
pub fn numrs2::linalg::randomized::random_projection<T>(a: &numrs2::array::Array<T>, target_dim: usize, projection_type: numrs2::linalg::randomized::ProjectionType) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::default::Default + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T>
pub fn numrs2::linalg::randomized::randomized_low_rank_approximation<T>(a: &numrs2::array::Array<T>, rank: usize, n_iter: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::default::Default + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T>
pub fn numrs2::linalg::randomized::randomized_range_finder<T>(a: &numrs2::array::Array<T>, rank: usize, n_iter: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::default::Default + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T>
pub fn numrs2::linalg::randomized::randomized_svd<T>(a: &numrs2::array::Array<T>, rank: usize, n_oversamples: core::option::Option<usize>, n_iter: usize) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + core::clone::Clone + core::default::Default + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T>
pub mod numrs2::linalg::solve
pub mod numrs2::linalg::tensor_decomp
pub struct numrs2::linalg::tensor_decomp::CpResult<T: core::clone::Clone>
pub numrs2::linalg::tensor_decomp::CpResult::error: T
pub numrs2::linalg::tensor_decomp::CpResult::factors: alloc::vec::Vec<numrs2::array::Array<T>>
pub numrs2::linalg::tensor_decomp::CpResult::iterations: usize
pub numrs2::linalg::tensor_decomp::CpResult::rank: usize
pub numrs2::linalg::tensor_decomp::CpResult::weights: alloc::vec::Vec<T>
pub struct numrs2::linalg::tensor_decomp::DecompConfig
pub numrs2::linalg::tensor_decomp::DecompConfig::max_iterations: usize
pub numrs2::linalg::tensor_decomp::DecompConfig::normalize: bool
pub numrs2::linalg::tensor_decomp::DecompConfig::tolerance: f64
impl core::default::Default for numrs2::linalg::tensor_decomp::DecompConfig
pub fn numrs2::linalg::tensor_decomp::DecompConfig::default() -> Self
pub struct numrs2::linalg::tensor_decomp::TuckerResult<T: core::clone::Clone>
pub numrs2::linalg::tensor_decomp::TuckerResult::core: numrs2::array::Array<T>
pub numrs2::linalg::tensor_decomp::TuckerResult::factors: alloc::vec::Vec<numrs2::array::Array<T>>
pub numrs2::linalg::tensor_decomp::TuckerResult::original_shape: alloc::vec::Vec<usize>
pub numrs2::linalg::tensor_decomp::TuckerResult::ranks: alloc::vec::Vec<usize>
pub fn numrs2::linalg::tensor_decomp::cp_als<T>(tensor: &numrs2::array::Array<T>, rank: usize, max_iter: usize, tolerance: T) -> numrs2::Result<numrs2::linalg::tensor_decomp::CpResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::default::Default + core::marker::Send + core::marker::Sync + core::iter::traits::accum::Sum
pub fn numrs2::linalg::tensor_decomp::cp_als_with_config<T>(tensor: &numrs2::array::Array<T>, rank: usize, config: &numrs2::linalg::tensor_decomp::DecompConfig) -> numrs2::Result<numrs2::linalg::tensor_decomp::CpResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::default::Default + core::marker::Send + core::marker::Sync + core::iter::traits::accum::Sum
pub fn numrs2::linalg::tensor_decomp::cp_reconstruct<T>(result: &numrs2::linalg::tensor_decomp::CpResult<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::default::Default + core::marker::Send + core::marker::Sync + core::iter::traits::accum::Sum
pub fn numrs2::linalg::tensor_decomp::nonnegative_cp_als<T>(tensor: &numrs2::array::Array<T>, rank: usize, max_iter: usize, tolerance: T) -> numrs2::Result<numrs2::linalg::tensor_decomp::CpResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::default::Default + core::marker::Send + core::marker::Sync + core::iter::traits::accum::Sum
pub fn numrs2::linalg::tensor_decomp::tucker_decomposition<T>(tensor: &numrs2::array::Array<T>, ranks: &[usize]) -> numrs2::Result<numrs2::linalg::tensor_decomp::TuckerResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::default::Default + core::marker::Send + core::marker::Sync + core::iter::traits::accum::Sum
pub fn numrs2::linalg::tensor_decomp::tucker_reconstruct<T>(result: &numrs2::linalg::tensor_decomp::TuckerResult<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::default::Default + core::marker::Send + core::marker::Sync + core::iter::traits::accum::Sum
pub mod numrs2::linalg::tensor_ops
pub fn numrs2::linalg::tensor_ops::einsum<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::ops::arith::AddAssign + 'static>(subscripts: &str, operands: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::tensor_ops::kron<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::tensor_ops::tensordot<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, axes: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::linalg::vector_ops
pub trait numrs2::linalg::vector_ops::ComplexVectorDotProduct<T>
pub fn numrs2::linalg::vector_ops::ComplexVectorDotProduct::vdot(&self, other: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<num_complex::Complex<T>>
impl<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug> numrs2::linalg::vector_ops::ComplexVectorDotProduct<T> for numrs2::array::Array<num_complex::Complex<T>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::vdot(&self, other: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<num_complex::Complex<T>>
pub trait numrs2::linalg::vector_ops::RealVectorDotProduct<T>
pub fn numrs2::linalg::vector_ops::RealVectorDotProduct::vdot(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<T>
impl<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + 'static> numrs2::linalg::vector_ops::RealVectorDotProduct<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::vdot(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<T>
pub fn numrs2::linalg::vector_ops::complex_vdot<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug>(a: &numrs2::array::Array<num_complex::Complex<T>>, b: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<num_complex::Complex<T>>
pub fn numrs2::linalg::vector_ops::cross<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::vector_ops::inner<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + 'static>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<T>
pub fn numrs2::linalg::vector_ops::norm<T: num_traits::float::Float + core::clone::Clone + core::fmt::Display + core::ops::arith::AddAssign + 'static>(a: &numrs2::array::Array<T>, ord: core::option::Option<T>) -> numrs2::Result<T>
pub fn numrs2::linalg::vector_ops::outer<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::vector_ops::trace<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::ops::arith::AddAssign>(a: &numrs2::array::Array<T>) -> numrs2::Result<T>
pub fn numrs2::linalg::vector_ops::vdot<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + 'static>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<T>
pub enum numrs2::linalg::ProjectionType
pub numrs2::linalg::ProjectionType::Gaussian
pub numrs2::linalg::ProjectionType::Rademacher
pub numrs2::linalg::ProjectionType::Sparse
pub struct numrs2::linalg::CpResult<T: core::clone::Clone>
pub numrs2::linalg::CpResult::error: T
pub numrs2::linalg::CpResult::factors: alloc::vec::Vec<numrs2::array::Array<T>>
pub numrs2::linalg::CpResult::iterations: usize
pub numrs2::linalg::CpResult::rank: usize
pub numrs2::linalg::CpResult::weights: alloc::vec::Vec<T>
pub struct numrs2::linalg::DecompConfig
pub numrs2::linalg::DecompConfig::max_iterations: usize
pub numrs2::linalg::DecompConfig::normalize: bool
pub numrs2::linalg::DecompConfig::tolerance: f64
impl core::default::Default for numrs2::linalg::tensor_decomp::DecompConfig
pub fn numrs2::linalg::tensor_decomp::DecompConfig::default() -> Self
pub struct numrs2::linalg::TuckerResult<T: core::clone::Clone>
pub numrs2::linalg::TuckerResult::core: numrs2::array::Array<T>
pub numrs2::linalg::TuckerResult::factors: alloc::vec::Vec<numrs2::array::Array<T>>
pub numrs2::linalg::TuckerResult::original_shape: alloc::vec::Vec<usize>
pub numrs2::linalg::TuckerResult::ranks: alloc::vec::Vec<usize>
pub fn numrs2::linalg::complex_vdot<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug>(a: &numrs2::array::Array<num_complex::Complex<T>>, b: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<num_complex::Complex<T>>
pub fn numrs2::linalg::cp_als<T>(tensor: &numrs2::array::Array<T>, rank: usize, max_iter: usize, tolerance: T) -> numrs2::Result<numrs2::linalg::tensor_decomp::CpResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::default::Default + core::marker::Send + core::marker::Sync + core::iter::traits::accum::Sum
pub fn numrs2::linalg::cp_als_with_config<T>(tensor: &numrs2::array::Array<T>, rank: usize, config: &numrs2::linalg::tensor_decomp::DecompConfig) -> numrs2::Result<numrs2::linalg::tensor_decomp::CpResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::default::Default + core::marker::Send + core::marker::Sync + core::iter::traits::accum::Sum
pub fn numrs2::linalg::cp_reconstruct<T>(result: &numrs2::linalg::tensor_decomp::CpResult<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::default::Default + core::marker::Send + core::marker::Sync + core::iter::traits::accum::Sum
pub fn numrs2::linalg::einsum<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::ops::arith::AddAssign + 'static>(subscripts: &str, operands: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::inner<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + 'static>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<T>
pub fn numrs2::linalg::kron<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::nonnegative_cp_als<T>(tensor: &numrs2::array::Array<T>, rank: usize, max_iter: usize, tolerance: T) -> numrs2::Result<numrs2::linalg::tensor_decomp::CpResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::default::Default + core::marker::Send + core::marker::Sync + core::iter::traits::accum::Sum
pub fn numrs2::linalg::norm<T: num_traits::float::Float + core::clone::Clone + core::fmt::Display + core::ops::arith::AddAssign + 'static>(a: &numrs2::array::Array<T>, ord: core::option::Option<T>) -> numrs2::Result<T>
pub fn numrs2::linalg::outer<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::random_projection<T>(a: &numrs2::array::Array<T>, target_dim: usize, projection_type: numrs2::linalg::randomized::ProjectionType) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::default::Default + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T>
pub fn numrs2::linalg::randomized_low_rank_approximation<T>(a: &numrs2::array::Array<T>, rank: usize, n_iter: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::default::Default + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T>
pub fn numrs2::linalg::randomized_range_finder<T>(a: &numrs2::array::Array<T>, rank: usize, n_iter: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::default::Default + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T>
pub fn numrs2::linalg::randomized_svd<T>(a: &numrs2::array::Array<T>, rank: usize, n_oversamples: core::option::Option<usize>, n_iter: usize) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + core::clone::Clone + core::default::Default + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T>
pub fn numrs2::linalg::set_lapack_threads(threads: usize)
pub fn numrs2::linalg::tensordot<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, axes: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::linalg::trace<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::ops::arith::AddAssign>(a: &numrs2::array::Array<T>) -> numrs2::Result<T>
pub fn numrs2::linalg::tucker_decomposition<T>(tensor: &numrs2::array::Array<T>, ranks: &[usize]) -> numrs2::Result<numrs2::linalg::tensor_decomp::TuckerResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::default::Default + core::marker::Send + core::marker::Sync + core::iter::traits::accum::Sum
pub fn numrs2::linalg::tucker_reconstruct<T>(result: &numrs2::linalg::tensor_decomp::TuckerResult<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::default::Default + core::marker::Send + core::marker::Sync + core::iter::traits::accum::Sum
pub fn numrs2::linalg::vdot<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + 'static>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<T>
pub mod numrs2::linalg_accelerated
pub use numrs2::linalg_accelerated::LinalgError
pub struct numrs2::linalg_accelerated::AcceleratedBlas
impl numrs2::linalg_accelerated::AcceleratedBlas
pub fn numrs2::linalg_accelerated::AcceleratedBlas::dot<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_accelerated::AcceleratedBlas::gemm<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, c: &mut numrs2::array::Array<T>, alpha: T, beta: T, _trans_a: bool, _trans_b: bool) -> numrs2::Result<()> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_accelerated::AcceleratedBlas::gemv<T>(a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &mut numrs2::array::Array<T>, alpha: T, beta: T, _trans: bool) -> numrs2::Result<()> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_accelerated::cholesky<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::linalg_accelerated::det<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::linalg_accelerated::dot<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_accelerated::eig<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::linalg_accelerated::ComplexEigResult<T>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::linalg_accelerated::eigh<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::linalg_accelerated::eigvals<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::linalg_accelerated::eigvalsh<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::linalg_accelerated::gemm<T>(alpha: T, a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, beta: T, c: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_accelerated::gemv<T>(alpha: T, a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, beta: T, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_accelerated::inv<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::linalg_accelerated::lstsq<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + num_traits::identities::One + 'static
pub fn numrs2::linalg_accelerated::lu<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::linalg_accelerated::matmul<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_accelerated::matvec<T>(a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_accelerated::norm<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_accelerated::qr<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::linalg_accelerated::solve<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + num_traits::identities::One + 'static
pub fn numrs2::linalg_accelerated::svd<T>(a: &numrs2::array::Array<T>, full_matrices: bool) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub type numrs2::linalg_accelerated::ComplexEigResult<T> = (numrs2::array::Array<num_complex::Complex<T>>, numrs2::array::Array<num_complex::Complex<T>>)
pub type numrs2::linalg_accelerated::LinalgResult<T> = core::result::Result<T, scirs2_linalg::error::LinalgError>
pub mod numrs2::linalg_extended
pub mod numrs2::linalg_extended::decomposition
pub mod numrs2::linalg_extended::decomposition::utils
pub mod numrs2::linalg_extended::eigenvalue
pub type numrs2::linalg_extended::eigenvalue::EigResult<T> = (numrs2::array::Array<num_complex::Complex<T>>, numrs2::array::Array<num_complex::Complex<T>>)
pub mod numrs2::linalg_extended::utils
pub type numrs2::linalg_extended::EigResult<T> = (numrs2::array::Array<num_complex::Complex<T>>, numrs2::array::Array<num_complex::Complex<T>>)
pub mod numrs2::linalg_optimized
pub struct numrs2::linalg_optimized::OptimizedBlas
impl numrs2::linalg_optimized::OptimizedBlas
pub fn numrs2::linalg_optimized::OptimizedBlas::dot<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_optimized::OptimizedBlas::gemm<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, c: &mut numrs2::array::Array<T>, alpha: T, beta: T, trans_a: bool, trans_b: bool) -> numrs2::Result<()> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_optimized::OptimizedBlas::gemv<T>(a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &mut numrs2::array::Array<T>, alpha: T, beta: T, trans: bool) -> numrs2::Result<()> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_optimized::lu_optimized<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<usize>)> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::linalg_optimized::matmul_optimized<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_optimized::matvec_optimized<T>(a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_optimized::transpose_optimized<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub mod numrs2::linalg_parallel
pub struct numrs2::linalg_parallel::ParallelLinAlg
impl numrs2::linalg_parallel::ParallelLinAlg
pub fn numrs2::linalg_parallel::ParallelLinAlg::compute_load_balance_strategy<T>(a: &numrs2::array::Array<T>, operation: &str, num_threads: usize) -> alloc::string::String where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::linalg_parallel::ParallelLinAlg::optimal_block_size(m: usize, n: usize, num_threads: usize) -> (usize, usize)
pub fn numrs2::linalg_parallel::ParallelLinAlg::parallel_gemm<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, c: &mut numrs2::array::Array<T>, alpha: T, beta: T, trans_a: bool, trans_b: bool, num_threads: core::option::Option<usize>) -> numrs2::Result<()> where T: num_traits::float::Float + num_traits::NumAssign + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::linalg_parallel::ParallelLinAlg::parallel_lu<T>(a: &numrs2::array::Array<T>, num_threads: core::option::Option<usize>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<usize>)> where T: num_traits::float::Float + num_traits::NumAssign + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::linalg_parallel::ParallelLinAlg::parallel_matvec<T>(a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &mut numrs2::array::Array<T>, alpha: T, beta: T, trans: bool, num_threads: core::option::Option<usize>) -> numrs2::Result<()> where T: num_traits::float::Float + num_traits::NumAssign + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::linalg_parallel::ParallelLinAlg::parallel_qr<T>(a: &numrs2::array::Array<T>, num_threads: core::option::Option<usize>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::marker::Send + core::marker::Sync + 'static
pub mod numrs2::linalg_stable
pub struct numrs2::linalg_stable::CholeskyStableResult<T: core::clone::Clone>
pub numrs2::linalg_stable::CholeskyStableResult::condition_number: T
pub numrs2::linalg_stable::CholeskyStableResult::d: core::option::Option<numrs2::array::Array<T>>
pub numrs2::linalg_stable::CholeskyStableResult::is_positive_definite: bool
pub numrs2::linalg_stable::CholeskyStableResult::l: numrs2::array::Array<T>
pub numrs2::linalg_stable::CholeskyStableResult::p: core::option::Option<numrs2::array::Array<f64>>
pub numrs2::linalg_stable::CholeskyStableResult::pivoting_used: bool
pub struct numrs2::linalg_stable::QRPivotedResult<T: core::clone::Clone>
pub numrs2::linalg_stable::QRPivotedResult::condition_number: T
pub numrs2::linalg_stable::QRPivotedResult::p: numrs2::array::Array<f64>
pub numrs2::linalg_stable::QRPivotedResult::q: numrs2::array::Array<T>
pub numrs2::linalg_stable::QRPivotedResult::r: numrs2::array::Array<T>
pub numrs2::linalg_stable::QRPivotedResult::rank: usize
pub struct numrs2::linalg_stable::SVDStableResult<T: core::clone::Clone>
pub numrs2::linalg_stable::SVDStableResult::condition_number: T
pub numrs2::linalg_stable::SVDStableResult::rank: usize
pub numrs2::linalg_stable::SVDStableResult::s: numrs2::array::Array<T>
pub numrs2::linalg_stable::SVDStableResult::u: numrs2::array::Array<T>
pub numrs2::linalg_stable::SVDStableResult::vt: numrs2::array::Array<T>
pub struct numrs2::linalg_stable::StableDecompositions
impl numrs2::linalg_stable::StableDecompositions
pub fn numrs2::linalg_stable::StableDecompositions::cholesky_stable<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::linalg_stable::CholeskyStableResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::linalg_stable::StableDecompositions::qr_pivoted<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::linalg_stable::QRPivotedResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::linalg_stable::StableDecompositions::svd_stable<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::linalg_stable::SVDStableResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::linalg_stable::StableDecompositions::symmetric_eigendecomposition<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<(alloc::vec::Vec<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub mod numrs2::masked
pub struct numrs2::masked::MaskedArray<T>
impl<T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::identities::Zero + core::convert::From<f64> + core::convert::Into<f64>> numrs2::masked::MaskedArray<T>
pub fn numrs2::masked::MaskedArray<T>::max(&self) -> core::option::Option<T> where T: core::cmp::PartialOrd
pub fn numrs2::masked::MaskedArray<T>::mean(&self) -> core::option::Option<T>
pub fn numrs2::masked::MaskedArray<T>::min(&self) -> core::option::Option<T> where T: core::cmp::PartialOrd
pub fn numrs2::masked::MaskedArray<T>::sum(&self) -> core::option::Option<T>
impl<T: core::clone::Clone> numrs2::masked::MaskedArray<T>
pub fn numrs2::masked::MaskedArray<T>::compressed(&self) -> numrs2::array::Array<T> where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::count_masked(&self) -> usize
pub fn numrs2::masked::MaskedArray<T>::count_valid(&self) -> usize
pub fn numrs2::masked::MaskedArray<T>::filled(&self, fill_value: core::option::Option<T>) -> numrs2::array::Array<T> where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::get(&self, indices: &[usize]) -> numrs2::Result<T> where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::get_data(&self) -> &numrs2::array::Array<T>
pub fn numrs2::masked::MaskedArray<T>::get_fill_value(&self) -> T
pub fn numrs2::masked::MaskedArray<T>::get_mask(&self) -> &numrs2::array::Array<bool>
pub fn numrs2::masked::MaskedArray<T>::harden_mask(&self) -> Self where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::masked_all(data: numrs2::array::Array<T>, fill_value: core::option::Option<T>) -> numrs2::Result<Self> where T: core::clone::Clone + core::default::Default
pub fn numrs2::masked::MaskedArray<T>::masked_invalid(data: numrs2::array::Array<f64>, fill_value: core::option::Option<f64>) -> numrs2::Result<numrs2::masked::MaskedArray<f64>>
pub fn numrs2::masked::MaskedArray<T>::masked_values(data: numrs2::array::Array<T>, value: T, fill_value: core::option::Option<T>) -> numrs2::Result<Self> where T: core::clone::Clone + core::default::Default + core::cmp::PartialEq
pub fn numrs2::masked::MaskedArray<T>::masked_where(data: numrs2::array::Array<T>, condition: numrs2::array::Array<bool>, fill_value: core::option::Option<T>) -> numrs2::Result<Self> where T: core::clone::Clone + core::default::Default
pub fn numrs2::masked::MaskedArray<T>::ndim(&self) -> usize
pub fn numrs2::masked::MaskedArray<T>::new(data: numrs2::array::Array<T>, mask: core::option::Option<numrs2::array::Array<bool>>, fill_value: core::option::Option<T>) -> numrs2::Result<Self> where T: core::clone::Clone + core::default::Default
pub fn numrs2::masked::MaskedArray<T>::reshape(&self, shape: &[usize]) -> Self where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::set(&mut self, indices: &[usize], value: T, mask: core::option::Option<bool>) -> numrs2::Result<()> where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::set_fill_value(&mut self, value: T)
pub fn numrs2::masked::MaskedArray<T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::masked::MaskedArray<T>::size(&self) -> usize
pub fn numrs2::masked::MaskedArray<T>::soften_mask(&self) -> Self where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::transpose(&self) -> Self where T: core::clone::Clone
impl<T: core::clone::Clone + core::fmt::Debug> core::fmt::Debug for numrs2::masked::MaskedArray<T>
pub fn numrs2::masked::MaskedArray<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::clone::Clone + core::fmt::Display + core::fmt::Debug> core::fmt::Display for numrs2::masked::MaskedArray<T>
pub fn numrs2::masked::MaskedArray<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::clone::Clone + core::ops::arith::Add<Output = T>> core::ops::arith::Add for &numrs2::masked::MaskedArray<T>
pub type &numrs2::masked::MaskedArray<T>::Output = numrs2::masked::MaskedArray<T>
pub fn &numrs2::masked::MaskedArray<T>::add(self, other: &numrs2::masked::MaskedArray<T>) -> numrs2::masked::MaskedArray<T>
impl<T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + num_traits::identities::Zero> core::ops::arith::Div for &numrs2::masked::MaskedArray<T>
pub type &numrs2::masked::MaskedArray<T>::Output = numrs2::masked::MaskedArray<T>
pub fn &numrs2::masked::MaskedArray<T>::div(self, other: &numrs2::masked::MaskedArray<T>) -> numrs2::masked::MaskedArray<T>
impl<T: core::clone::Clone + core::ops::arith::Mul<Output = T>> core::ops::arith::Mul for &numrs2::masked::MaskedArray<T>
pub type &numrs2::masked::MaskedArray<T>::Output = numrs2::masked::MaskedArray<T>
pub fn &numrs2::masked::MaskedArray<T>::mul(self, other: &numrs2::masked::MaskedArray<T>) -> numrs2::masked::MaskedArray<T>
impl<T: core::clone::Clone + core::ops::arith::Sub<Output = T>> core::ops::arith::Sub for &numrs2::masked::MaskedArray<T>
pub type &numrs2::masked::MaskedArray<T>::Output = numrs2::masked::MaskedArray<T>
pub fn &numrs2::masked::MaskedArray<T>::sub(self, other: &numrs2::masked::MaskedArray<T>) -> numrs2::masked::MaskedArray<T>
pub mod numrs2::math
pub enum numrs2::math::GradientSpacing<T>
pub numrs2::math::GradientSpacing::PerAxis(alloc::vec::Vec<T>)
pub numrs2::math::GradientSpacing::Uniform(T)
pub trait numrs2::math::ElementWiseMath<T>
pub fn numrs2::math::ElementWiseMath::abs(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::acos(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::acosh(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::asin(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::asinh(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::atan(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::atan2(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::atanh(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::cbrt(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::ceil(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::clip(&self, min: T, max: T) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::cos(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::cosh(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::degrees(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::exp(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::expm1(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::floor(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::hypot(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::log(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::log10(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::log1p(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::log2(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::logaddexp(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::logaddexp2(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::pow(&self, n: T) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::radians(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::round(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::safe_atan2(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math::ElementWiseMath::safe_hypot(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math::ElementWiseMath::safe_logaddexp(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math::ElementWiseMath::safe_logaddexp2(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math::ElementWiseMath::sign(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::sin(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::sinh(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::sqrt(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::tan(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::tanh(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::ElementWiseMath::trunc(&self) -> numrs2::array::Array<T>
impl<T: num_traits::float::Float + core::clone::Clone + 'static> numrs2::math::ElementWiseMath<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::abs(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::acos(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::acosh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::asin(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::asinh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::atan(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::atan2(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::atanh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cbrt(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::ceil(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::clip(&self, min: T, max: T) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cos(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cosh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::degrees(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::exp(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::expm1(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::floor(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::hypot(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log10(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log1p(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log2(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::logaddexp(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::logaddexp2(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::pow(&self, n: T) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::radians(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::round(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::safe_atan2(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::safe_hypot(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::safe_logaddexp(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::safe_logaddexp2(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::sign(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sin(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sinh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sqrt(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::tan(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::tanh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::trunc(&self) -> numrs2::array::Array<T>
pub fn numrs2::math::amax<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math::amin<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math::angle<T: num_traits::float::Float + core::clone::Clone>(complex_array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::math::arange<T>(start: T, stop: T, step: T) -> numrs2::array::Array<T> where T: core::clone::Clone + core::cmp::PartialOrd + num_traits::cast::NumCast + core::ops::arith::Add<Output = T> + num_traits::identities::Zero + 'static
pub fn numrs2::math::argmax<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math::argmin<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math::argpartition<T>(array: &numrs2::array::Array<T>, kth: usize, axis: core::option::Option<isize>, _kind: core::option::Option<&str>, _order: core::option::Option<&[&str]>) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math::argsort<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, _kind: core::option::Option<&str>, _order: core::option::Option<&[&str]>) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math::around<T>(array: &numrs2::array::Array<T>, decimals: core::option::Option<i32>, out: core::option::Option<&mut numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::bartlett(m: usize) -> numrs2::array::Array<f64>
pub fn numrs2::math::bincount(array: &numrs2::array::Array<usize>, minlength: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::math::blackman(m: usize) -> numrs2::array::Array<f64>
pub fn numrs2::math::clip<T>(array: &numrs2::array::Array<T>, min: core::option::Option<T>, max: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::cmp::PartialOrd + core::clone::Clone
pub fn numrs2::math::complex_abs<T: num_traits::float::Float + core::clone::Clone>(complex_array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::math::conj<T: num_traits::float::Float + core::clone::Clone>(complex_array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<num_complex::Complex<T>>
pub fn numrs2::math::copysign<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::count_nonzero<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::math::cumprod<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, _out: core::option::Option<&mut numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Send + core::marker::Sync
pub fn numrs2::math::cumsum<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, _out: core::option::Option<&mut numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::math::cumulative_prod<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, _out: core::option::Option<&mut numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Send + core::marker::Sync
pub fn numrs2::math::cumulative_sum<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, _out: core::option::Option<&mut numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::math::deg2rad<T: num_traits::float::Float + core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::diff<T>(array: &numrs2::array::Array<T>, n: usize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Sub<Output = T> + 'static
pub fn numrs2::math::diff_extended<T>(array: &numrs2::array::Array<T>, n: usize, axis: core::option::Option<usize>, prepend: core::option::Option<&numrs2::array::Array<T>>, append: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Sub<Output = T> + core::ops::arith::Add<Output = T> + 'static
pub fn numrs2::math::digitize<T>(array: &numrs2::array::Array<T>, bins: &numrs2::array::Array<T>, right: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::math::divmod<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::ediff1d<T>(array: &numrs2::array::Array<T>, to_end: core::option::Option<&numrs2::array::Array<T>>, to_begin: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::arith::Sub<Output = T>
pub fn numrs2::math::empty<T: core::default::Default + core::clone::Clone>(shape: &[usize]) -> numrs2::array::Array<T>
pub fn numrs2::math::exp2<T: num_traits::float::Float + core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::fix<T: num_traits::float::Float + core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::flatnonzero<T>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::math::floor_divide<T: num_traits::float::Float + core::clone::Clone>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math::fmax<T: num_traits::float::Float + core::clone::Clone>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math::fmin<T: num_traits::float::Float + core::clone::Clone>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math::fmod<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::frexp<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<i32>) where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::gcd<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq + core::ops::arith::Rem<Output = T> + core::marker::Copy
pub fn numrs2::math::geomspace<T: num_traits::float::Float + core::clone::Clone + 'static>(start: T, stop: T, num: usize) -> numrs2::array::Array<T>
pub fn numrs2::math::gradient<T>(f: &numrs2::array::Array<T>, varargs: core::option::Option<numrs2::math::GradientSpacing<T>>, axis: core::option::Option<alloc::vec::Vec<usize>>, edge_order: usize) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: num_traits::float::Float + core::clone::Clone + 'static
pub fn numrs2::math::hamming(m: usize) -> numrs2::array::Array<f64>
pub fn numrs2::math::hanning(m: usize) -> numrs2::array::Array<f64>
pub fn numrs2::math::heaviside<T>(x: &numrs2::array::Array<T>, h0: core::option::Option<T>) -> numrs2::array::Array<T> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::hypot<T: num_traits::float::Float + core::clone::Clone>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math::i0<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::imag<T: num_traits::float::Float + core::clone::Clone>(complex_array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::math::interp<T>(x: &numrs2::array::Array<T>, xp: &numrs2::array::Array<T>, fp: &numrs2::array::Array<T>, left: core::option::Option<T>, right: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::iscomplex<T>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<bool> where T: num_traits::float::Float
pub fn numrs2::math::isfinite<T>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<bool> where T: num_traits::float::Float
pub fn numrs2::math::isinf<T>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<bool> where T: num_traits::float::Float
pub fn numrs2::math::isnan<T>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<bool> where T: num_traits::float::Float
pub fn numrs2::math::isneginf<T>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<bool> where T: num_traits::float::Float
pub fn numrs2::math::isnormal<T>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<bool> where T: num_traits::float::Float
pub fn numrs2::math::isposinf<T>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<bool> where T: num_traits::float::Float
pub fn numrs2::math::isreal<T>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<bool> where T: num_traits::float::Float
pub fn numrs2::math::kaiser(m: usize, beta: f64) -> numrs2::array::Array<f64>
pub fn numrs2::math::lcm<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq + core::ops::arith::Rem<Output = T> + core::ops::arith::Div<Output = T> + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub fn numrs2::math::ldexp<T, I>(x: &numrs2::array::Array<T>, exp: &numrs2::array::Array<I>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone, I: core::clone::Clone + num_traits::cast::NumCast
pub fn numrs2::math::linspace<T: num_traits::float::Float + core::clone::Clone + 'static>(start: T, stop: T, num: usize) -> numrs2::array::Array<T>
pub fn numrs2::math::logspace<T: num_traits::float::Float + core::clone::Clone + 'static>(start: T, stop: T, num: usize, base: core::option::Option<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::max<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math::mean<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::cast::NumCast
pub fn numrs2::math::median<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::math::meshgrid<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>], indexing: core::option::Option<&str>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::math::meshgrid2d<T: core::clone::Clone>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>)>
pub fn numrs2::math::mgrid<T: core::clone::Clone + num_traits::cast::NumCast + num_traits::identities::Zero>(ranges: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::math::min<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math::modf<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::nan_to_num<T>(array: &numrs2::array::Array<T>, nan: core::option::Option<T>, posinf: core::option::Option<T>, neginf: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math::nanargmax<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math::nanargmin<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math::nancumprod<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Mul<Output = T> + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::math::nancumsum<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero
pub fn numrs2::math::nanmax<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::math::nanmean<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::identities::Zero
pub fn numrs2::math::nanmin<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::math::nanpercentile<T>(array: &numrs2::array::Array<T>, q: T, axis: core::option::Option<isize>, method: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Display
pub fn numrs2::math::nanprod<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::math::nanquantile<T>(array: &numrs2::array::Array<T>, q: &numrs2::array::Array<T>, axis: core::option::Option<isize>, method: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Display
pub fn numrs2::math::nanstd<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, ddof: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + num_traits::identities::Zero
pub fn numrs2::math::nansum<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero
pub fn numrs2::math::nanvar<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, ddof: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + num_traits::identities::Zero
pub fn numrs2::math::negative<T: core::clone::Clone + core::ops::arith::Neg<Output = T>>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::nextafter<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::nonzero<T>(array: &numrs2::array::Array<T>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::math::ogrid<T: core::clone::Clone + num_traits::cast::NumCast + num_traits::identities::Zero>(ranges: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::math::ones<T: num_traits::identities::One + core::clone::Clone>(shape: &[usize]) -> numrs2::array::Array<T>
pub fn numrs2::math::partition<T>(array: &numrs2::array::Array<T>, kth: usize, axis: core::option::Option<isize>, _kind: core::option::Option<&str>, _order: core::option::Option<&[&str]>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::math::positive<T: core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::prod<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool, initial: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Mul<Output = T>
pub fn numrs2::math::rad2deg<T: num_traits::float::Float + core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::real<T: num_traits::float::Float + core::clone::Clone>(complex_array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::math::real_if_close<T>(a: &numrs2::array::Array<num_complex::Complex<T>>, tol: core::option::Option<T>) -> numrs2::array::Array<T> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::reciprocal<T: num_traits::float::Float + core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::remainder<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::resize<T>(array: &numrs2::array::Array<T>, new_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math::rint<T: num_traits::float::Float + core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::round<T>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::searchsorted<T>(sorted_array: &numrs2::array::Array<T>, values: &numrs2::array::Array<T>, side: &str) -> numrs2::Result<numrs2::array::Array<usize>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::math::sign<T: num_traits::float::Float + core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::signbit<T: num_traits::float::Float + core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<bool>
pub fn numrs2::math::sinc<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::sort<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, _kind: core::option::Option<&str>, _order: core::option::Option<&[&str]>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math::spacing<T: num_traits::float::Float + core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::std<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, ddof: usize, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + num_traits::cast::NumCast
pub fn numrs2::math::sum<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero
pub fn numrs2::math::trapz<T>(y: &numrs2::array::Array<T>, x: core::option::Option<&numrs2::array::Array<T>>, dx: T, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::math::true_divide<T: num_traits::float::Float + core::clone::Clone>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math::unwrap<T: num_traits::float::Float + core::clone::Clone>(phase_array: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::math::var<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, ddof: usize, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + num_traits::cast::NumCast
pub fn numrs2::math::zeros<T: num_traits::identities::Zero + core::clone::Clone>(shape: &[usize]) -> numrs2::array::Array<T>
pub mod numrs2::math_extended
pub mod numrs2::math_extended::polynomial
pub struct numrs2::math_extended::polynomial::CubicSpline<T>
impl<T> numrs2::math_extended::CubicSpline<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialOrd + core::fmt::Debug + num_traits::float::Float
pub fn numrs2::math_extended::CubicSpline<T>::evaluate(&self, x: T) -> numrs2::Result<T>
pub fn numrs2::math_extended::CubicSpline<T>::evaluate_array(&self, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math_extended::CubicSpline<T>::new(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub struct numrs2::math_extended::polynomial::OrthogonalPolynomials
impl numrs2::math_extended::OrthogonalPolynomials
pub fn numrs2::math_extended::OrthogonalPolynomials::chebyshev_t<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::OrthogonalPolynomials::chebyshev_u<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::OrthogonalPolynomials::hermite<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::OrthogonalPolynomials::laguerre<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::OrthogonalPolynomials::legendre<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub struct numrs2::math_extended::polynomial::Polynomial<T>
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::math_extended::Polynomial<T>::coefficients(&self) -> &[T]
pub fn numrs2::math_extended::Polynomial<T>::degree(&self) -> usize
pub fn numrs2::math_extended::Polynomial<T>::new(coefficients: alloc::vec::Vec<T>) -> Self
pub fn numrs2::math_extended::Polynomial<T>::to_array(&self) -> numrs2::array::Array<T>
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::Polynomial<T>::evaluate(&self, x: T) -> T
pub fn numrs2::math_extended::Polynomial<T>::evaluate_array(&self, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math_extended::Polynomial<T>::monomial(degree: usize) -> Self
pub fn numrs2::math_extended::Polynomial<T>::one() -> Self
pub fn numrs2::math_extended::Polynomial<T>::zero() -> Self
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::Polynomial<T>::definite_integral(&self, a: T, b: T) -> T
pub fn numrs2::math_extended::Polynomial<T>::derivative(&self) -> Self
pub fn numrs2::math_extended::Polynomial<T>::integral(&self) -> Self
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::Polynomial<T>::divide(&self, divisor: &Self) -> numrs2::Result<(Self, Self)>
impl<T> core::ops::arith::Add for numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::cmp::PartialEq
pub type numrs2::math_extended::Polynomial<T>::Output = numrs2::math_extended::Polynomial<T>
pub fn numrs2::math_extended::Polynomial<T>::add(self, other: numrs2::math_extended::Polynomial<T>) -> numrs2::math_extended::Polynomial<T>
impl<T> core::ops::arith::Mul for numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub type numrs2::math_extended::Polynomial<T>::Output = numrs2::math_extended::Polynomial<T>
pub fn numrs2::math_extended::Polynomial<T>::mul(self, other: numrs2::math_extended::Polynomial<T>) -> numrs2::math_extended::Polynomial<T>
impl<T> core::ops::arith::Sub for numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Sub<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub type numrs2::math_extended::Polynomial<T>::Output = numrs2::math_extended::Polynomial<T>
pub fn numrs2::math_extended::Polynomial<T>::sub(self, other: numrs2::math_extended::Polynomial<T>) -> numrs2::math_extended::Polynomial<T>
pub struct numrs2::math_extended::polynomial::PolynomialInterpolation
impl numrs2::math_extended::PolynomialInterpolation
pub fn numrs2::math_extended::PolynomialInterpolation::lagrange<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::PolynomialInterpolation::newton<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polynomial::poly<T>(roots: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polynomial::polyadd<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polynomial::polychebyshev<T>(degree: usize, kind: u8) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polynomial::polycompanion<T>(c: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Neg<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polynomial::polycompose<T>(p: &numrs2::array::Array<T>, q: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polynomial::polyder<T>(c: &numrs2::array::Array<T>, m: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polynomial::polydiv<T>(u: &numrs2::array::Array<T>, v: &numrs2::array::Array<T>) -> numrs2::Result<(numrs2::math_extended::Polynomial<T>, numrs2::math_extended::Polynomial<T>)> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polynomial::polyextrap<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, new_x: &numrs2::array::Array<T>, degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::math_extended::polynomial::polyfit<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, degree: usize) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::math_extended::polynomial::polyfit_weighted<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, degree: usize, weights: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::math_extended::polynomial::polyfromroots<T>(roots: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polynomial::polygcd<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + num_traits::float::Float
pub fn numrs2::math_extended::polynomial::polygrid2d<T>(c: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polynomial::polyhermite<T>(degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polynomial::polyint<T>(c: &numrs2::array::Array<T>, m: usize, k: core::option::Option<&[T]>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polynomial::polyjacobi<T>(degree: usize, alpha: T, beta: T) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::math_extended::polynomial::polylaguerre<T>(degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polynomial::polylegendre<T>(degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polynomial::polymul<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polynomial::polymulx<T>(c: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math_extended::polynomial::polypower<T>(c: &numrs2::array::Array<T>, pow: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polynomial::polyresidual<T>(c: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polynomial::polyscale<T>(c: &numrs2::array::Array<T>, domain: &numrs2::array::Array<T>, window: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + num_traits::float::Float
pub fn numrs2::math_extended::polynomial::polysub<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Sub<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polynomial::polytrim<T>(c: &numrs2::array::Array<T>, tol: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialOrd + num_traits::float::Float
pub fn numrs2::math_extended::polynomial::polyval<T>(p: &numrs2::math_extended::Polynomial<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polynomial::polyval2d<T>(c: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::math_extended::polynomial::polyvander<T>(x: &numrs2::array::Array<T>, deg: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Mul<Output = T>
pub fn numrs2::math_extended::polynomial::polyvander2d<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, deg: (usize, usize)) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Mul<Output = T>
pub fn numrs2::math_extended::polynomial::roots<T>(p: &numrs2::math_extended::Polynomial<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub mod numrs2::math_extended::special
pub fn numrs2::math_extended::special::airy_ai<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::airy_bi<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::associated_legendre_p<T>(l: i32, m: i32, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::bessel_i<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::bessel_j<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::bessel_k<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::bessel_y<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::beta<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::betainc<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::digamma<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::ellipe<T>(m: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::ellipeinc<T>(phi: &numrs2::array::Array<T>, m: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::ellipf<T>(phi: &numrs2::array::Array<T>, m: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::ellipk<T>(m: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::erf<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::erfc<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::erfcinv<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::erfinv<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::exp1<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::expi<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::fresnel<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::gamma<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::gammainc<T>(a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::gammaln<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::jacobi_elliptic<T>(u: &numrs2::array::Array<T>, m: T) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::lambertw<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::lambertwm1<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::legendre_p<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::polylog<T>(s: T, z: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::shichi<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::sici<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::spherical_harmonic<T>(l: i32, m: i32, theta: &numrs2::array::Array<T>, phi: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::struve_h<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::special::zeta<T>(s: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub struct numrs2::math_extended::CubicSpline<T>
impl<T> numrs2::math_extended::CubicSpline<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialOrd + core::fmt::Debug + num_traits::float::Float
pub fn numrs2::math_extended::CubicSpline<T>::evaluate(&self, x: T) -> numrs2::Result<T>
pub fn numrs2::math_extended::CubicSpline<T>::evaluate_array(&self, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math_extended::CubicSpline<T>::new(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub struct numrs2::math_extended::OrthogonalPolynomials
impl numrs2::math_extended::OrthogonalPolynomials
pub fn numrs2::math_extended::OrthogonalPolynomials::chebyshev_t<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::OrthogonalPolynomials::chebyshev_u<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::OrthogonalPolynomials::hermite<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::OrthogonalPolynomials::laguerre<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::OrthogonalPolynomials::legendre<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub struct numrs2::math_extended::Polynomial<T>
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::math_extended::Polynomial<T>::coefficients(&self) -> &[T]
pub fn numrs2::math_extended::Polynomial<T>::degree(&self) -> usize
pub fn numrs2::math_extended::Polynomial<T>::new(coefficients: alloc::vec::Vec<T>) -> Self
pub fn numrs2::math_extended::Polynomial<T>::to_array(&self) -> numrs2::array::Array<T>
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::Polynomial<T>::evaluate(&self, x: T) -> T
pub fn numrs2::math_extended::Polynomial<T>::evaluate_array(&self, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math_extended::Polynomial<T>::monomial(degree: usize) -> Self
pub fn numrs2::math_extended::Polynomial<T>::one() -> Self
pub fn numrs2::math_extended::Polynomial<T>::zero() -> Self
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::Polynomial<T>::definite_integral(&self, a: T, b: T) -> T
pub fn numrs2::math_extended::Polynomial<T>::derivative(&self) -> Self
pub fn numrs2::math_extended::Polynomial<T>::integral(&self) -> Self
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::Polynomial<T>::divide(&self, divisor: &Self) -> numrs2::Result<(Self, Self)>
impl<T> core::ops::arith::Add for numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::cmp::PartialEq
pub type numrs2::math_extended::Polynomial<T>::Output = numrs2::math_extended::Polynomial<T>
pub fn numrs2::math_extended::Polynomial<T>::add(self, other: numrs2::math_extended::Polynomial<T>) -> numrs2::math_extended::Polynomial<T>
impl<T> core::ops::arith::Mul for numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub type numrs2::math_extended::Polynomial<T>::Output = numrs2::math_extended::Polynomial<T>
pub fn numrs2::math_extended::Polynomial<T>::mul(self, other: numrs2::math_extended::Polynomial<T>) -> numrs2::math_extended::Polynomial<T>
impl<T> core::ops::arith::Sub for numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Sub<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub type numrs2::math_extended::Polynomial<T>::Output = numrs2::math_extended::Polynomial<T>
pub fn numrs2::math_extended::Polynomial<T>::sub(self, other: numrs2::math_extended::Polynomial<T>) -> numrs2::math_extended::Polynomial<T>
pub struct numrs2::math_extended::PolynomialInterpolation
impl numrs2::math_extended::PolynomialInterpolation
pub fn numrs2::math_extended::PolynomialInterpolation::lagrange<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::PolynomialInterpolation::newton<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::airy_ai<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::airy_bi<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::associated_legendre_p<T>(l: i32, m: i32, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::bessel_i<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::bessel_j<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::bessel_k<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::bessel_y<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::beta<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::betainc<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::digamma<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::ellipe<T>(m: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::ellipeinc<T>(phi: &numrs2::array::Array<T>, m: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::ellipf<T>(phi: &numrs2::array::Array<T>, m: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::ellipk<T>(m: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::erf<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::erfc<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::erfcinv<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::erfinv<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::exp1<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::expi<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::fresnel<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::gamma<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::gammainc<T>(a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::gammaln<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::jacobi_elliptic<T>(u: &numrs2::array::Array<T>, m: T) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::lambertw<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::lambertwm1<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::legendre_p<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::poly<T>(roots: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polyadd<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polychebyshev<T>(degree: usize, kind: u8) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polycompanion<T>(c: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Neg<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polycompose<T>(p: &numrs2::array::Array<T>, q: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polyder<T>(c: &numrs2::array::Array<T>, m: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polydiv<T>(u: &numrs2::array::Array<T>, v: &numrs2::array::Array<T>) -> numrs2::Result<(numrs2::math_extended::Polynomial<T>, numrs2::math_extended::Polynomial<T>)> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polyextrap<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, new_x: &numrs2::array::Array<T>, degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::math_extended::polyfit<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, degree: usize) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::math_extended::polyfit_weighted<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, degree: usize, weights: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::math_extended::polyfromroots<T>(roots: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polygcd<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + num_traits::float::Float
pub fn numrs2::math_extended::polygrid2d<T>(c: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polyhermite<T>(degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polyint<T>(c: &numrs2::array::Array<T>, m: usize, k: core::option::Option<&[T]>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polyjacobi<T>(degree: usize, alpha: T, beta: T) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::math_extended::polylaguerre<T>(degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polylegendre<T>(degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polylog<T>(s: T, z: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::polymul<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polymulx<T>(c: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::math_extended::polypower<T>(c: &numrs2::array::Array<T>, pow: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polyresidual<T>(c: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polyscale<T>(c: &numrs2::array::Array<T>, domain: &numrs2::array::Array<T>, window: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + num_traits::float::Float
pub fn numrs2::math_extended::polysub<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Sub<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::polytrim<T>(c: &numrs2::array::Array<T>, tol: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialOrd + num_traits::float::Float
pub fn numrs2::math_extended::polyval<T>(p: &numrs2::math_extended::Polynomial<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::polyval2d<T>(c: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::math_extended::polyvander<T>(x: &numrs2::array::Array<T>, deg: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Mul<Output = T>
pub fn numrs2::math_extended::polyvander2d<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, deg: (usize, usize)) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Mul<Output = T>
pub fn numrs2::math_extended::roots<T>(p: &numrs2::math_extended::Polynomial<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::math_extended::shichi<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::sici<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::spherical_harmonic<T>(l: i32, m: i32, theta: &numrs2::array::Array<T>, phi: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::struve_h<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::math_extended::zeta<T>(s: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub mod numrs2::matrix
pub mod numrs2::matrix::special
pub fn numrs2::matrix::special::circulant(first_row: alloc::vec::Vec<f64>) -> numrs2::matrix::Matrix<f64>
pub fn numrs2::matrix::special::companion(coefficients: alloc::vec::Vec<f64>) -> numrs2::Result<numrs2::matrix::Matrix<f64>>
pub fn numrs2::matrix::special::hadamard(n: usize) -> numrs2::Result<numrs2::matrix::Matrix<f64>>
pub fn numrs2::matrix::special::hankel(c: alloc::vec::Vec<f64>, r: core::option::Option<alloc::vec::Vec<f64>>) -> numrs2::Result<numrs2::matrix::Matrix<f64>>
pub fn numrs2::matrix::special::hilbert(n: usize) -> numrs2::matrix::Matrix<f64>
pub fn numrs2::matrix::special::leslie(f: alloc::vec::Vec<f64>, s: alloc::vec::Vec<f64>) -> numrs2::Result<numrs2::matrix::Matrix<f64>>
pub fn numrs2::matrix::special::toeplitz(c: alloc::vec::Vec<f64>, r: core::option::Option<alloc::vec::Vec<f64>>) -> numrs2::Result<numrs2::matrix::Matrix<f64>>
pub fn numrs2::matrix::special::vandermonde(x: alloc::vec::Vec<f64>, n: core::option::Option<usize>) -> numrs2::matrix::Matrix<f64>
pub struct numrs2::matrix::BandedMatrix<T>
impl<T> numrs2::matrix::BandedMatrix<T> where T: core::clone::Clone + core::default::Default + num_traits::identities::Zero + core::cmp::PartialEq + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::matrix::BandedMatrix<T>::matvec(&self, vec: &[T]) -> numrs2::Result<alloc::vec::Vec<T>>
impl<T> numrs2::matrix::BandedMatrix<T> where T: core::clone::Clone + core::default::Default + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::matrix::BandedMatrix<T>::band_width(&self) -> usize
pub fn numrs2::matrix::BandedMatrix<T>::diagonal(&self) -> alloc::vec::Vec<T>
pub fn numrs2::matrix::BandedMatrix<T>::from_array(array: &numrs2::array::Array<T>, sub_diagonals: usize, super_diagonals: usize) -> numrs2::Result<Self>
pub fn numrs2::matrix::BandedMatrix<T>::get(&self, i: usize, j: usize) -> numrs2::Result<T>
pub fn numrs2::matrix::BandedMatrix<T>::is_in_band(&self, i: usize, j: usize) -> bool
pub fn numrs2::matrix::BandedMatrix<T>::is_square(&self) -> bool
pub fn numrs2::matrix::BandedMatrix<T>::ncols(&self) -> usize
pub fn numrs2::matrix::BandedMatrix<T>::new(rows: usize, cols: usize, sub_diagonals: usize, super_diagonals: usize) -> Self
pub fn numrs2::matrix::BandedMatrix<T>::nrows(&self) -> usize
pub fn numrs2::matrix::BandedMatrix<T>::set(&mut self, i: usize, j: usize, value: T) -> numrs2::Result<()>
pub fn numrs2::matrix::BandedMatrix<T>::sub_diagonals(&self) -> usize
pub fn numrs2::matrix::BandedMatrix<T>::super_diagonals(&self) -> usize
pub fn numrs2::matrix::BandedMatrix<T>::to_array(&self) -> numrs2::array::Array<T>
impl<T> core::fmt::Display for numrs2::matrix::BandedMatrix<T> where T: core::clone::Clone + core::fmt::Display + core::default::Default + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::matrix::BandedMatrix<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::matrix::Matrix<T>
impl<T> numrs2::matrix::Matrix<T> where T: core::clone::Clone + core::default::Default + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::cmp::PartialOrd
pub fn numrs2::matrix::Matrix<T>::dot(&self, other: &numrs2::matrix::Matrix<T>) -> numrs2::Result<numrs2::matrix::Matrix<T>>
impl<T> numrs2::matrix::Matrix<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::matrix::Matrix<T>::array(&self) -> &numrs2::array::Array<T>
pub fn numrs2::matrix::Matrix<T>::column(&self, j: usize) -> numrs2::Result<Self>
pub fn numrs2::matrix::Matrix<T>::diagonal(&self) -> Self
pub fn numrs2::matrix::Matrix<T>::eye(n: usize) -> Self where T: core::convert::From<u8> + core::clone::Clone + core::default::Default
pub fn numrs2::matrix::Matrix<T>::from_nested_vec(nested_vec: alloc::vec::Vec<alloc::vec::Vec<T>>) -> numrs2::Result<Self>
pub fn numrs2::matrix::Matrix<T>::from_vec(vec: alloc::vec::Vec<T>) -> Self
pub fn numrs2::matrix::Matrix<T>::get(&self, i: usize, j: usize) -> numrs2::Result<T>
pub fn numrs2::matrix::Matrix<T>::is_square(&self) -> bool
pub fn numrs2::matrix::Matrix<T>::is_symmetric(&self) -> bool where T: core::cmp::PartialEq
pub fn numrs2::matrix::Matrix<T>::ncols(&self) -> usize
pub fn numrs2::matrix::Matrix<T>::new(array: numrs2::array::Array<T>) -> numrs2::Result<Self>
pub fn numrs2::matrix::Matrix<T>::nrows(&self) -> usize
pub fn numrs2::matrix::Matrix<T>::ones(rows: usize, cols: usize) -> Self where T: core::convert::From<u8> + core::clone::Clone
pub fn numrs2::matrix::Matrix<T>::row(&self, i: usize) -> numrs2::Result<Self>
pub fn numrs2::matrix::Matrix<T>::set(&mut self, i: usize, j: usize, value: T) -> numrs2::Result<()>
pub fn numrs2::matrix::Matrix<T>::shape(&self) -> (usize, usize)
pub fn numrs2::matrix::Matrix<T>::size(&self) -> usize
pub fn numrs2::matrix::Matrix<T>::to_array(&self) -> numrs2::array::Array<T>
pub fn numrs2::matrix::Matrix<T>::to_nested_vec(&self) -> alloc::vec::Vec<alloc::vec::Vec<T>>
pub fn numrs2::matrix::Matrix<T>::transpose(&self) -> Self
pub fn numrs2::matrix::Matrix<T>::zeros(rows: usize, cols: usize) -> Self where T: core::default::Default + core::clone::Clone
impl<T: core::clone::Clone + core::default::Default + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::cmp::PartialOrd> core::ops::arith::Mul for &numrs2::matrix::Matrix<T>
pub type &numrs2::matrix::Matrix<T>::Output = numrs2::matrix::Matrix<T>
pub fn &numrs2::matrix::Matrix<T>::mul(self, other: &numrs2::matrix::Matrix<T>) -> numrs2::matrix::Matrix<T>
impl<T> core::convert::TryFrom<numrs2::array::Array<T>> for numrs2::matrix::Matrix<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub type numrs2::matrix::Matrix<T>::Error = numrs2::NumRs2Error
pub fn numrs2::matrix::Matrix<T>::try_from(array: numrs2::array::Array<T>) -> numrs2::Result<Self>
impl<T> core::fmt::Display for numrs2::matrix::Matrix<T> where T: core::clone::Clone + core::fmt::Display + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::matrix::Matrix<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T> core::ops::arith::Add for &numrs2::matrix::Matrix<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub type &numrs2::matrix::Matrix<T>::Output = numrs2::matrix::Matrix<T>
pub fn &numrs2::matrix::Matrix<T>::add(self, other: &numrs2::matrix::Matrix<T>) -> numrs2::matrix::Matrix<T>
impl<T> core::ops::arith::Div<T> for &numrs2::matrix::Matrix<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub type &numrs2::matrix::Matrix<T>::Output = numrs2::matrix::Matrix<T>
pub fn &numrs2::matrix::Matrix<T>::div(self, scalar: T) -> numrs2::matrix::Matrix<T>
impl<T> core::ops::arith::Sub for &numrs2::matrix::Matrix<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub type &numrs2::matrix::Matrix<T>::Output = numrs2::matrix::Matrix<T>
pub fn &numrs2::matrix::Matrix<T>::sub(self, other: &numrs2::matrix::Matrix<T>) -> numrs2::matrix::Matrix<T>
pub fn numrs2::matrix::asmatrix<T>(data: numrs2::array::Array<T>) -> numrs2::Result<numrs2::matrix::Matrix<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::matrix::asmatrix_from_nested<T>(nested_vec: alloc::vec::Vec<alloc::vec::Vec<T>>) -> numrs2::Result<numrs2::matrix::Matrix<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::matrix::circulant(first_row: alloc::vec::Vec<f64>) -> numrs2::matrix::Matrix<f64>
pub fn numrs2::matrix::companion(coefficients: alloc::vec::Vec<f64>) -> numrs2::Result<numrs2::matrix::Matrix<f64>>
pub fn numrs2::matrix::hadamard(n: usize) -> numrs2::Result<numrs2::matrix::Matrix<f64>>
pub fn numrs2::matrix::hankel(c: alloc::vec::Vec<f64>, r: core::option::Option<alloc::vec::Vec<f64>>) -> numrs2::Result<numrs2::matrix::Matrix<f64>>
pub fn numrs2::matrix::hilbert(n: usize) -> numrs2::matrix::Matrix<f64>
pub fn numrs2::matrix::leslie(f: alloc::vec::Vec<f64>, s: alloc::vec::Vec<f64>) -> numrs2::Result<numrs2::matrix::Matrix<f64>>
pub fn numrs2::matrix::matrix<T>(data: numrs2::array::Array<T>) -> numrs2::Result<numrs2::matrix::Matrix<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::matrix::matrix_from_nested<T>(nested_vec: alloc::vec::Vec<alloc::vec::Vec<T>>) -> numrs2::Result<numrs2::matrix::Matrix<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::matrix::matrix_from_scalar<T>(scalar: T) -> numrs2::matrix::Matrix<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::matrix::toeplitz(c: alloc::vec::Vec<f64>, r: core::option::Option<alloc::vec::Vec<f64>>) -> numrs2::Result<numrs2::matrix::Matrix<f64>>
pub fn numrs2::matrix::vandermonde(x: alloc::vec::Vec<f64>, n: core::option::Option<usize>) -> numrs2::matrix::Matrix<f64>
pub mod numrs2::memory_alloc
pub mod numrs2::memory_alloc::aligned
pub struct numrs2::memory_alloc::aligned::AlignedAllocator
impl numrs2::memory_alloc::aligned::AlignedAllocator
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::alignment(&self) -> usize
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate_array<T>(&self, count: usize) -> core::option::Option<core::ptr::non_null::NonNull<T>>
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate_for_type<T>(&self) -> core::option::Option<core::ptr::non_null::NonNull<T>>
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::as_mut_slice<T>(&mut self, ptr: core::ptr::non_null::NonNull<T>, count: usize) -> &mut [T]
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::as_slice<T>(&self, ptr: core::ptr::non_null::NonNull<T>, count: usize) -> &[T]
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::create_array<T: core::marker::Copy>(&self, values: &[T]) -> core::option::Option<core::ptr::non_null::NonNull<T>>
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, size: usize)
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::deallocate_array<T>(&self, ptr: core::ptr::non_null::NonNull<T>, count: usize)
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::is_zero_initialized(&self) -> bool
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::new(config: numrs2::memory_alloc::aligned::AlignmentConfig) -> Self
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::aligned::AlignedAllocator
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
pub struct numrs2::memory_alloc::aligned::AlignedBox<T>
impl<T> numrs2::memory_alloc::aligned::AlignedBox<T>
pub fn numrs2::memory_alloc::aligned::AlignedBox<T>::alignment(&self) -> usize
pub fn numrs2::memory_alloc::aligned::AlignedBox<T>::get(&self) -> &T
pub fn numrs2::memory_alloc::aligned::AlignedBox<T>::get_mut(&mut self) -> &mut T
pub fn numrs2::memory_alloc::aligned::AlignedBox<T>::into_inner(self) -> T
pub fn numrs2::memory_alloc::aligned::AlignedBox<T>::new(value: T, alignment: usize) -> core::option::Option<Self>
impl<T: core::clone::Clone> core::clone::Clone for numrs2::memory_alloc::aligned::AlignedBox<T>
pub fn numrs2::memory_alloc::aligned::AlignedBox<T>::clone(&self) -> Self
impl<T> core::ops::drop::Drop for numrs2::memory_alloc::aligned::AlignedBox<T>
pub fn numrs2::memory_alloc::aligned::AlignedBox<T>::drop(&mut self)
pub struct numrs2::memory_alloc::aligned::AlignedVec<T>
impl<T> numrs2::memory_alloc::aligned::AlignedVec<T>
pub fn numrs2::memory_alloc::aligned::AlignedVec<T>::alignment(&self) -> usize
pub fn numrs2::memory_alloc::aligned::AlignedVec<T>::as_mut_slice(&mut self) -> &mut [T]
pub fn numrs2::memory_alloc::aligned::AlignedVec<T>::as_slice(&self) -> &[T]
pub fn numrs2::memory_alloc::aligned::AlignedVec<T>::capacity(&self) -> usize
pub fn numrs2::memory_alloc::aligned::AlignedVec<T>::is_empty(&self) -> bool
pub fn numrs2::memory_alloc::aligned::AlignedVec<T>::len(&self) -> usize
pub fn numrs2::memory_alloc::aligned::AlignedVec<T>::push(&mut self, value: T) -> bool
pub fn numrs2::memory_alloc::aligned::AlignedVec<T>::with_capacity(capacity: usize, alignment: usize) -> core::option::Option<Self>
pub fn numrs2::memory_alloc::aligned::AlignedVec<T>::with_capacity_zeroed(capacity: usize, alignment: usize) -> core::option::Option<Self> where T: core::marker::Copy + core::default::Default
impl<T> core::ops::drop::Drop for numrs2::memory_alloc::aligned::AlignedVec<T>
pub fn numrs2::memory_alloc::aligned::AlignedVec<T>::drop(&mut self)
pub struct numrs2::memory_alloc::aligned::AlignmentConfig
pub numrs2::memory_alloc::aligned::AlignmentConfig::alignment: usize
pub numrs2::memory_alloc::aligned::AlignmentConfig::zero_init: bool
impl numrs2::memory_alloc::aligned::AlignmentConfig
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::cache_line() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::new(alignment: usize, zero_init: bool) -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::page() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::simd_128() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::simd_256() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::simd_512() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::zeroed(self) -> Self
impl core::default::Default for numrs2::memory_alloc::aligned::AlignmentConfig
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::default() -> Self
pub mod numrs2::memory_alloc::arena
pub struct numrs2::memory_alloc::arena::ArenaAllocator
impl numrs2::memory_alloc::arena::ArenaAllocator
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate_aligned(&self, size: usize, alignment: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate_object<T>(&self) -> core::option::Option<core::ptr::non_null::NonNull<T>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::available_size(&self) -> usize
pub fn numrs2::memory_alloc::arena::ArenaAllocator::get_alignment(&self) -> usize
pub fn numrs2::memory_alloc::arena::ArenaAllocator::new(config: numrs2::memory_alloc::arena::ArenaConfig) -> Self
pub fn numrs2::memory_alloc::arena::ArenaAllocator::reset(&self)
pub fn numrs2::memory_alloc::arena::ArenaAllocator::scoped(&self) -> numrs2::memory_alloc::arena::ScopedArena
pub fn numrs2::memory_alloc::arena::ArenaAllocator::total_size(&self) -> usize
impl core::clone::Clone for numrs2::memory_alloc::arena::ArenaAllocator
pub fn numrs2::memory_alloc::arena::ArenaAllocator::clone(&self) -> Self
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::arena::ArenaAllocator
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::arena::ArenaAllocator::deallocate(&self, _ptr: core::ptr::non_null::NonNull<u8>, _layout: core::alloc::layout::Layout)
pub struct numrs2::memory_alloc::arena::ArenaConfig
pub numrs2::memory_alloc::arena::ArenaConfig::alignment: usize
pub numrs2::memory_alloc::arena::ArenaConfig::allow_growth: bool
pub numrs2::memory_alloc::arena::ArenaConfig::growth_factor: f64
pub numrs2::memory_alloc::arena::ArenaConfig::initial_size: usize
impl core::default::Default for numrs2::memory_alloc::arena::ArenaConfig
pub fn numrs2::memory_alloc::arena::ArenaConfig::default() -> Self
pub struct numrs2::memory_alloc::arena::ArenaVec<'a, T>
impl<'a, T: core::clone::Clone> numrs2::memory_alloc::arena::ArenaVec<'a, T>
pub fn numrs2::memory_alloc::arena::ArenaVec<'a, T>::from_slice(slice: &[T], arena: &'a numrs2::memory_alloc::arena::ArenaAllocator) -> Self
impl<'a, T> numrs2::memory_alloc::arena::ArenaVec<'a, T>
pub fn numrs2::memory_alloc::arena::ArenaVec<'a, T>::as_mut_slice(&mut self) -> &mut [T]
pub fn numrs2::memory_alloc::arena::ArenaVec<'a, T>::as_slice(&self) -> &[T]
pub fn numrs2::memory_alloc::arena::ArenaVec<'a, T>::capacity(&self) -> usize
pub fn numrs2::memory_alloc::arena::ArenaVec<'a, T>::clear(&mut self)
pub fn numrs2::memory_alloc::arena::ArenaVec<'a, T>::get(&self, index: usize) -> core::option::Option<&T>
pub fn numrs2::memory_alloc::arena::ArenaVec<'a, T>::get_mut(&mut self, index: usize) -> core::option::Option<&mut T>
pub fn numrs2::memory_alloc::arena::ArenaVec<'a, T>::is_empty(&self) -> bool
pub fn numrs2::memory_alloc::arena::ArenaVec<'a, T>::len(&self) -> usize
pub fn numrs2::memory_alloc::arena::ArenaVec<'a, T>::push(&mut self, value: T) -> bool
pub fn numrs2::memory_alloc::arena::ArenaVec<'a, T>::reserve(&mut self, additional: usize) -> bool
pub fn numrs2::memory_alloc::arena::ArenaVec<'a, T>::with_capacity(capacity: usize, arena: &'a numrs2::memory_alloc::arena::ArenaAllocator) -> Self
impl<T> core::ops::drop::Drop for numrs2::memory_alloc::arena::ArenaVec<'_, T>
pub fn numrs2::memory_alloc::arena::ArenaVec<'_, T>::drop(&mut self)
pub struct numrs2::memory_alloc::arena::ScopedArena
impl numrs2::memory_alloc::arena::ScopedArena
pub fn numrs2::memory_alloc::arena::ScopedArena::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ScopedArena::allocate_aligned(&self, size: usize, alignment: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ScopedArena::allocate_object<T>(&self) -> core::option::Option<core::ptr::non_null::NonNull<T>>
impl core::ops::drop::Drop for numrs2::memory_alloc::arena::ScopedArena
pub fn numrs2::memory_alloc::arena::ScopedArena::drop(&mut self)
pub mod numrs2::memory_alloc::benchmark_configs
pub fn numrs2::memory_alloc::benchmark_configs::high_pressure() -> numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub fn numrs2::memory_alloc::benchmark_configs::large_matrices() -> numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub fn numrs2::memory_alloc::benchmark_configs::mixed_workload() -> numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub fn numrs2::memory_alloc::benchmark_configs::simd_aligned() -> numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub fn numrs2::memory_alloc::benchmark_configs::small_frequent() -> numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub mod numrs2::memory_alloc::benchmarking
pub mod numrs2::memory_alloc::benchmarking::benchmark_configs
pub fn numrs2::memory_alloc::benchmarking::benchmark_configs::high_pressure() -> numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub fn numrs2::memory_alloc::benchmarking::benchmark_configs::large_matrices() -> numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub fn numrs2::memory_alloc::benchmarking::benchmark_configs::mixed_workload() -> numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub fn numrs2::memory_alloc::benchmarking::benchmark_configs::simd_aligned() -> numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub fn numrs2::memory_alloc::benchmarking::benchmark_configs::small_frequent() -> numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub struct numrs2::memory_alloc::benchmarking::AllocatorBenchmark
impl numrs2::memory_alloc::benchmarking::AllocatorBenchmark
pub fn numrs2::memory_alloc::benchmarking::AllocatorBenchmark::benchmark_allocator<A>(&mut self, allocator: &A, name: &str) -> numrs2::Result<numrs2::memory_alloc::benchmarking::BenchmarkResults> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error> + ?core::marker::Sized
pub fn numrs2::memory_alloc::benchmarking::AllocatorBenchmark::compare_allocators(&mut self, allocators: alloc::vec::Vec<(alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>, alloc::string::String)>) -> numrs2::Result<alloc::vec::Vec<numrs2::memory_alloc::benchmarking::BenchmarkResults>>
pub fn numrs2::memory_alloc::benchmarking::AllocatorBenchmark::generate_comparison_report(results: &[numrs2::memory_alloc::benchmarking::BenchmarkResults]) -> alloc::string::String
pub fn numrs2::memory_alloc::benchmarking::AllocatorBenchmark::new(config: numrs2::memory_alloc::benchmarking::BenchmarkConfig) -> Self
impl core::default::Default for numrs2::memory_alloc::benchmarking::AllocatorBenchmark
pub fn numrs2::memory_alloc::benchmarking::AllocatorBenchmark::default() -> Self
pub struct numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub numrs2::memory_alloc::benchmarking::BenchmarkConfig::concurrent_allocations: usize
pub numrs2::memory_alloc::benchmarking::BenchmarkConfig::enable_fragmentation: bool
pub numrs2::memory_alloc::benchmarking::BenchmarkConfig::iterations: usize
pub numrs2::memory_alloc::benchmarking::BenchmarkConfig::max_size: usize
pub numrs2::memory_alloc::benchmarking::BenchmarkConfig::memory_pressure: f64
pub numrs2::memory_alloc::benchmarking::BenchmarkConfig::min_size: usize
pub numrs2::memory_alloc::benchmarking::BenchmarkConfig::randomize_order: bool
pub numrs2::memory_alloc::benchmarking::BenchmarkConfig::randomize_sizes: bool
impl core::default::Default for numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub fn numrs2::memory_alloc::benchmarking::BenchmarkConfig::default() -> Self
pub struct numrs2::memory_alloc::benchmarking::BenchmarkResults
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::allocation_efficiency: f64
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::allocation_throughput: f64
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::allocation_time: core::time::Duration
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::allocator_name: alloc::string::String
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::avg_allocation_time: core::time::Duration
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::avg_deallocation_time: core::time::Duration
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::bytes_per_second: f64
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::config: numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::deallocation_time: core::time::Duration
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::failed_allocations: usize
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::fragmentation_level: f64
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::latency_percentiles: (core::time::Duration, core::time::Duration, core::time::Duration, core::time::Duration)
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::peak_memory_usage: usize
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::size_distribution: std::collections::hash::map::HashMap<usize, usize>
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::successful_allocations: usize
pub numrs2::memory_alloc::benchmarking::BenchmarkResults::total_bytes_allocated: usize
impl core::fmt::Display for numrs2::memory_alloc::benchmarking::BenchmarkResults
pub fn numrs2::memory_alloc::benchmarking::BenchmarkResults::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub mod numrs2::memory_alloc::cache_constants
pub const numrs2::memory_alloc::cache_constants::CACHE_LINE_SIZE: usize
pub const numrs2::memory_alloc::cache_constants::L1_CACHE_SIZE: usize
pub const numrs2::memory_alloc::cache_constants::L2_CACHE_SIZE: usize
pub const numrs2::memory_alloc::cache_constants::L3_CACHE_SIZE: usize
pub const numrs2::memory_alloc::cache_constants::PAGE_SIZE: usize
pub const numrs2::memory_alloc::cache_constants::PREFETCH_DISTANCE: usize
pub mod numrs2::memory_alloc::cache_optimization
pub mod numrs2::memory_alloc::cache_optimization::cache_constants
pub const numrs2::memory_alloc::cache_optimization::cache_constants::CACHE_LINE_SIZE: usize
pub const numrs2::memory_alloc::cache_optimization::cache_constants::L1_CACHE_SIZE: usize
pub const numrs2::memory_alloc::cache_optimization::cache_constants::L2_CACHE_SIZE: usize
pub const numrs2::memory_alloc::cache_optimization::cache_constants::L3_CACHE_SIZE: usize
pub const numrs2::memory_alloc::cache_optimization::cache_constants::PAGE_SIZE: usize
pub const numrs2::memory_alloc::cache_optimization::cache_constants::PREFETCH_DISTANCE: usize
pub enum numrs2::memory_alloc::cache_optimization::AccessType
pub numrs2::memory_alloc::cache_optimization::AccessType::Read
pub numrs2::memory_alloc::cache_optimization::AccessType::ReadWrite
pub numrs2::memory_alloc::cache_optimization::AccessType::Write
pub enum numrs2::memory_alloc::cache_optimization::CacheLevel
pub numrs2::memory_alloc::cache_optimization::CacheLevel::L1
pub numrs2::memory_alloc::cache_optimization::CacheLevel::L2
pub numrs2::memory_alloc::cache_optimization::CacheLevel::L3
pub enum numrs2::memory_alloc::cache_optimization::CacheOptimizationType
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationType::AlignDataStructures
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationType::EliminateFalseSharing
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationType::EnablePrefetch
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationType::ImproveLocality
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationType::OptimizeStride
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationType::ReduceWorkingSet
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationType::UseBlocking
pub struct numrs2::memory_alloc::cache_optimization::CacheBlockedMatrix<T>
impl<T: core::clone::Clone> numrs2::memory_alloc::cache_optimization::CacheBlockedMatrix<T>
pub fn numrs2::memory_alloc::cache_optimization::CacheBlockedMatrix<T>::get(&self, row: usize, col: usize) -> core::option::Option<&T>
pub fn numrs2::memory_alloc::cache_optimization::CacheBlockedMatrix<T>::multiply_blocked(&self, other: &Self) -> core::option::Option<Self> where T: core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::marker::Copy + core::default::Default
pub fn numrs2::memory_alloc::cache_optimization::CacheBlockedMatrix<T>::new(rows: usize, cols: usize, cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub fn numrs2::memory_alloc::cache_optimization::CacheBlockedMatrix<T>::set(&mut self, row: usize, col: usize, value: T) -> bool
pub fn numrs2::memory_alloc::cache_optimization::CacheBlockedMatrix<T>::transpose_blocked(&self) -> Self where T: core::marker::Copy + core::default::Default
pub struct numrs2::memory_alloc::cache_optimization::CacheConfig
pub numrs2::memory_alloc::cache_optimization::CacheConfig::cache_line_size: usize
pub numrs2::memory_alloc::cache_optimization::CacheConfig::enable_blocking: bool
pub numrs2::memory_alloc::cache_optimization::CacheConfig::enable_cache_padding: bool
pub numrs2::memory_alloc::cache_optimization::CacheConfig::enable_prefetch: bool
pub numrs2::memory_alloc::cache_optimization::CacheConfig::l1_cache_size: usize
pub numrs2::memory_alloc::cache_optimization::CacheConfig::l2_cache_size: usize
pub numrs2::memory_alloc::cache_optimization::CacheConfig::l3_cache_size: usize
pub numrs2::memory_alloc::cache_optimization::CacheConfig::optimize_access_patterns: bool
impl core::default::Default for numrs2::memory_alloc::cache_optimization::CacheConfig
pub fn numrs2::memory_alloc::cache_optimization::CacheConfig::default() -> Self
pub struct numrs2::memory_alloc::cache_optimization::CacheMetrics
pub numrs2::memory_alloc::cache_optimization::CacheMetrics::avg_latency_ns: f64
pub numrs2::memory_alloc::cache_optimization::CacheMetrics::cache_efficiency: f64
pub numrs2::memory_alloc::cache_optimization::CacheMetrics::l1_hits: u64
pub numrs2::memory_alloc::cache_optimization::CacheMetrics::l1_misses: u64
pub numrs2::memory_alloc::cache_optimization::CacheMetrics::l2_hits: u64
pub numrs2::memory_alloc::cache_optimization::CacheMetrics::l2_misses: u64
pub numrs2::memory_alloc::cache_optimization::CacheMetrics::last_updated: core::option::Option<std::time::Instant>
pub numrs2::memory_alloc::cache_optimization::CacheMetrics::total_accesses: u64
impl numrs2::memory_alloc::cache_optimization::CacheMetrics
pub fn numrs2::memory_alloc::cache_optimization::CacheMetrics::l1_hit_ratio(&self) -> f64
pub fn numrs2::memory_alloc::cache_optimization::CacheMetrics::l2_hit_ratio(&self) -> f64
pub fn numrs2::memory_alloc::cache_optimization::CacheMetrics::overall_efficiency(&self) -> f64
pub struct numrs2::memory_alloc::cache_optimization::CacheOptimizationParams
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationParams::block_size: usize
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationParams::enable_blocking: bool
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationParams::enable_prefetch: bool
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationParams::target_cache_level: numrs2::memory_alloc::cache_optimization::CacheLevel
pub struct numrs2::memory_alloc::cache_optimization::CacheOptimizationRecommendation
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationRecommendation::complexity: u8
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationRecommendation::description: alloc::string::String
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationRecommendation::estimated_improvement: f64
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationRecommendation::optimization_type: numrs2::memory_alloc::cache_optimization::CacheOptimizationType
pub numrs2::memory_alloc::cache_optimization::CacheOptimizationRecommendation::target_cache_level: numrs2::memory_alloc::cache_optimization::CacheLevel
pub struct numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
impl numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::analyze_cache_performance(&self) -> alloc::vec::Vec<numrs2::memory_alloc::cache_optimization::CacheOptimizationRecommendation>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::fits_in_cache(&self, size: usize, cache_level: numrs2::memory_alloc::cache_optimization::CacheLevel) -> bool
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::get_cache_metrics(&self) -> numrs2::memory_alloc::cache_optimization::CacheMetrics
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::new(config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::optimal_block_size(&self, element_size: usize, cache_level: numrs2::memory_alloc::cache_optimization::CacheLevel) -> usize
impl core::default::Default for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::default() -> Self
impl core::fmt::Debug for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl numrs2::traits::MemoryAllocator for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub type numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::memory_alloc::cache_optimization::CacheOptimizedBuilder
impl numrs2::memory_alloc::cache_optimization::CacheOptimizedBuilder
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedBuilder::build_allocator(&self) -> numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedBuilder::build_matrix<T: core::clone::Clone>(&self, rows: usize, cols: usize) -> numrs2::memory_alloc::cache_optimization::CacheBlockedMatrix<T>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedBuilder::new(config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedBuilder::optimize_for_size(&self, total_elements: usize, element_size: usize) -> numrs2::memory_alloc::cache_optimization::CacheOptimizationParams
pub mod numrs2::memory_alloc::enhanced_traits
pub struct numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T: numrs2::memory_alloc::strategy::MemoryAllocator>
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::new(allocator: T) -> Self
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::traits::MemoryAllocator for numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub type numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::supports_layout(&self, _layout: core::alloc::layout::Layout) -> bool
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy
impl numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::new() -> Self
impl core::default::Default for numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::default() -> Self
impl numrs2::traits::AllocationStrategy for numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::select_allocator(&self, requirements: &numrs2::traits::AllocationRequirements) -> alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::strategy_stats(&self) -> numrs2::traits::StrategyStats
pub struct numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
impl numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::new() -> Self
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::with_alignment(alignment: usize) -> Self
impl core::default::Default for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::default() -> Self
impl numrs2::traits::ArrayAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub type numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate_array<T>(&self, len: usize) -> core::result::Result<core::ptr::non_null::NonNull<T>, Self::Error>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate_simd_aligned<T>(&self, len: usize, alignment: usize) -> core::result::Result<core::ptr::non_null::NonNull<T>, Self::Error>
impl numrs2::traits::MemoryAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub type numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocation_error(&self, msg: &str) -> Self::Error
pub mod numrs2::memory_alloc::large_scale
pub struct numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>
impl<'a, T> numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>
pub fn numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>::new(data: &'a [T], chunk_size: usize) -> Self
impl<'a, T> core::iter::traits::iterator::Iterator for numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>
pub type numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>::Item = &'a [T]
pub fn numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>::next(&mut self) -> core::option::Option<Self::Item>
pub struct numrs2::memory_alloc::large_scale::LargeScaleConfig
pub numrs2::memory_alloc::large_scale::LargeScaleConfig::background_cleanup: bool
pub numrs2::memory_alloc::large_scale::LargeScaleConfig::chunk_size: usize
pub numrs2::memory_alloc::large_scale::LargeScaleConfig::enable_stats: bool
pub numrs2::memory_alloc::large_scale::LargeScaleConfig::max_memory_usage: usize
pub numrs2::memory_alloc::large_scale::LargeScaleConfig::monitor_interval_ms: u64
pub numrs2::memory_alloc::large_scale::LargeScaleConfig::spill_threshold: f64
pub numrs2::memory_alloc::large_scale::LargeScaleConfig::temp_dir: std::path::PathBuf
impl core::default::Default for numrs2::memory_alloc::large_scale::LargeScaleConfig
pub fn numrs2::memory_alloc::large_scale::LargeScaleConfig::default() -> Self
pub struct numrs2::memory_alloc::large_scale::LargeScaleManager
impl numrs2::memory_alloc::large_scale::LargeScaleManager
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::chunk_iterator<'a, T>(&self, data: &'a [T], chunk_size: core::option::Option<usize>) -> numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::cleanup_spilled_data(&self, max_age_seconds: u64) -> usize
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::config(&self) -> &numrs2::memory_alloc::large_scale::LargeScaleConfig
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::force_cleanup_all(&self)
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::get_memory_stats(&self) -> numrs2::memory_alloc::large_scale::MemoryStats
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::get_spill_stats(&self) -> numrs2::memory_alloc::large_scale::SpillStats
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::list_spilled_data(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::load_spilled_data(&self, spill_id: &str) -> numrs2::Result<alloc::vec::Vec<u8>>
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::new(config: numrs2::memory_alloc::large_scale::LargeScaleConfig) -> numrs2::Result<Self>
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::remove_spilled_data(&self, spill_id: &str) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::should_spill(&self) -> bool
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::spill_data(&self, data: &[u8], id: core::option::Option<alloc::string::String>) -> numrs2::Result<alloc::string::String>
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::tracker(&self) -> &alloc::sync::Arc<numrs2::memory_alloc::large_scale::MemoryTracker>
impl core::ops::drop::Drop for numrs2::memory_alloc::large_scale::LargeScaleManager
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::drop(&mut self)
pub struct numrs2::memory_alloc::large_scale::MemoryStats
pub numrs2::memory_alloc::large_scale::MemoryStats::active_allocations: usize
pub numrs2::memory_alloc::large_scale::MemoryStats::current_usage: usize
pub numrs2::memory_alloc::large_scale::MemoryStats::peak_usage: usize
pub numrs2::memory_alloc::large_scale::MemoryStats::total_allocations: usize
pub numrs2::memory_alloc::large_scale::MemoryStats::total_deallocations: usize
pub struct numrs2::memory_alloc::large_scale::MemoryTracker
impl numrs2::memory_alloc::large_scale::MemoryTracker
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::active_allocations(&self) -> usize
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::current_usage(&self) -> usize
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::get_stats(&self) -> numrs2::memory_alloc::large_scale::MemoryStats
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::new() -> Self
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::peak_usage(&self) -> usize
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::record_allocation(&self, size: usize)
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::record_deallocation(&self, size: usize)
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::reset_stats(&self)
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::set_enabled(&self, enabled: bool)
impl core::default::Default for numrs2::memory_alloc::large_scale::MemoryTracker
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::default() -> Self
pub struct numrs2::memory_alloc::large_scale::SpillStats
pub numrs2::memory_alloc::large_scale::SpillStats::spilled_count: usize
pub numrs2::memory_alloc::large_scale::SpillStats::temp_dir: std::path::PathBuf
pub numrs2::memory_alloc::large_scale::SpillStats::total_spilled_size: usize
pub struct numrs2::memory_alloc::large_scale::SpilledData
impl numrs2::memory_alloc::large_scale::SpilledData
pub fn numrs2::memory_alloc::large_scale::SpilledData::is_eligible_for_cleanup(&self, max_age_seconds: u64) -> bool
pub fn numrs2::memory_alloc::large_scale::SpilledData::load(&mut self) -> numrs2::Result<alloc::vec::Vec<u8>>
pub fn numrs2::memory_alloc::large_scale::SpilledData::mark_for_cleanup(&mut self)
pub fn numrs2::memory_alloc::large_scale::SpilledData::new(path: std::path::PathBuf, size: usize) -> Self
pub fn numrs2::memory_alloc::large_scale::SpilledData::path(&self) -> &std::path::Path
pub fn numrs2::memory_alloc::large_scale::SpilledData::size(&self) -> usize
pub fn numrs2::memory_alloc::large_scale::SpilledData::touch(&mut self)
impl core::ops::drop::Drop for numrs2::memory_alloc::large_scale::SpilledData
pub fn numrs2::memory_alloc::large_scale::SpilledData::drop(&mut self)
pub fn numrs2::memory_alloc::large_scale::get_global_memory_stats() -> numrs2::Result<numrs2::memory_alloc::large_scale::MemoryStats>
pub fn numrs2::memory_alloc::large_scale::get_global_spill_stats() -> numrs2::Result<numrs2::memory_alloc::large_scale::SpillStats>
pub fn numrs2::memory_alloc::large_scale::init_global_manager(config: numrs2::memory_alloc::large_scale::LargeScaleConfig) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::large_scale::load_spilled_data_globally(spill_id: &str) -> numrs2::Result<alloc::vec::Vec<u8>>
pub fn numrs2::memory_alloc::large_scale::should_spill_globally() -> bool
pub fn numrs2::memory_alloc::large_scale::spill_data_globally(data: &[u8], id: core::option::Option<alloc::string::String>) -> numrs2::Result<alloc::string::String>
pub fn numrs2::memory_alloc::large_scale::with_global_manager<F, R>(f: F) -> numrs2::Result<R> where F: core::ops::function::FnOnce(&numrs2::memory_alloc::large_scale::LargeScaleManager) -> R
pub fn numrs2::memory_alloc::large_scale::with_global_manager_mut<F, R>(f: F) -> numrs2::Result<R> where F: core::ops::function::FnOnce(&mut numrs2::memory_alloc::large_scale::LargeScaleManager) -> numrs2::Result<R>
pub mod numrs2::memory_alloc::monitored_allocator
pub mod numrs2::memory_alloc::monitored_allocator::presets
pub fn numrs2::memory_alloc::monitored_allocator::presets::matrix_allocator(_typical_matrix_size: usize) -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator>
pub fn numrs2::memory_alloc::monitored_allocator::presets::numerical_computing_allocator() -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator>
pub fn numrs2::memory_alloc::monitored_allocator::presets::temporary_object_allocator() -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator>
pub struct numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>
impl<A> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::generate_performance_report(&self) -> alloc::string::String
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::get_optimization_recommendations(&self) -> alloc::vec::Vec<numrs2::memory_alloc::performance_tuning::OptimizationRecommendation>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::get_performance_metrics(&self) -> numrs2::memory_alloc::performance_tuning::PerformanceMetrics
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::new(inner: A, monitoring_config: numrs2::memory_alloc::monitored_allocator::MonitoringConfig, tuning_config: numrs2::memory_alloc::performance_tuning::TuningConfig) -> Self
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::reset_metrics(&self)
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::set_auto_optimization(&mut self, enabled: bool)
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::take_performance_snapshot(&self)
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::with_defaults(inner: A) -> Self
impl<A: core::fmt::Debug> core::fmt::Debug for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A> numrs2::traits::AllocationStrategy for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error> + numrs2::traits::AllocationStrategy
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::select_allocator(&self, _requirements: &numrs2::traits::AllocationRequirements) -> alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::strategy_stats(&self) -> numrs2::traits::StrategyStats
impl<A> numrs2::traits::MemoryAllocator for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
pub type numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl<A> numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory
impl numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory::create_monitored_enhanced<T>(&self, inner: T) -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>> where T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory::create_monitored_numerical(&self) -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory::create_monitored_simd_optimized(&self) -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory::new(monitoring_config: numrs2::memory_alloc::monitored_allocator::MonitoringConfig, tuning_config: numrs2::memory_alloc::performance_tuning::TuningConfig) -> Self
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory::wrap<A>(&self, allocator: A) -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
impl core::default::Default for numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory::default() -> Self
pub struct numrs2::memory_alloc::monitored_allocator::MonitoringConfig
pub numrs2::memory_alloc::monitored_allocator::MonitoringConfig::auto_optimization: bool
pub numrs2::memory_alloc::monitored_allocator::MonitoringConfig::detailed_timing: bool
pub numrs2::memory_alloc::monitored_allocator::MonitoringConfig::max_tracked_allocations: usize
pub numrs2::memory_alloc::monitored_allocator::MonitoringConfig::min_monitored_size: usize
pub numrs2::memory_alloc::monitored_allocator::MonitoringConfig::report_frequency: u64
impl core::default::Default for numrs2::memory_alloc::monitored_allocator::MonitoringConfig
pub fn numrs2::memory_alloc::monitored_allocator::MonitoringConfig::default() -> Self
pub mod numrs2::memory_alloc::out_of_core
pub enum numrs2::memory_alloc::out_of_core::CacheStrategy
pub numrs2::memory_alloc::out_of_core::CacheStrategy::FIFO
pub numrs2::memory_alloc::out_of_core::CacheStrategy::LFU
pub numrs2::memory_alloc::out_of_core::CacheStrategy::LRU
pub struct numrs2::memory_alloc::out_of_core::CacheStats
pub numrs2::memory_alloc::out_of_core::CacheStats::cache_limit: usize
pub numrs2::memory_alloc::out_of_core::CacheStats::chunks_in_memory: usize
pub numrs2::memory_alloc::out_of_core::CacheStats::chunks_on_disk: usize
pub numrs2::memory_alloc::out_of_core::CacheStats::dirty_chunks: usize
pub numrs2::memory_alloc::out_of_core::CacheStats::total_chunks: usize
pub struct numrs2::memory_alloc::out_of_core::OutOfCoreArray<T: core::marker::Copy + core::marker::Send + core::marker::Sync + core::default::Default + 'static>
impl<T: core::marker::Copy + core::marker::Send + core::marker::Sync + core::default::Default + 'static> numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::from_data(data: alloc::vec::Vec<T>, shape: alloc::vec::Vec<usize>, config: numrs2::memory_alloc::out_of_core::OutOfCoreConfig) -> numrs2::Result<Self>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::get(&self, indices: &[usize]) -> numrs2::Result<T>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::get_cache_stats(&self) -> numrs2::memory_alloc::out_of_core::CacheStats
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::get_linear(&self, linear_index: usize) -> numrs2::Result<T>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::get_memory_stats(&self) -> numrs2::memory_alloc::large_scale::MemoryStats
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::is_empty(&self) -> bool
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::len(&self) -> usize
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::new(shape: alloc::vec::Vec<usize>, config: numrs2::memory_alloc::out_of_core::OutOfCoreConfig) -> numrs2::Result<Self>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::num_chunks(&self) -> usize
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::set_linear(&mut self, linear_index: usize, value: T) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::shape(&self) -> &[usize]
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::sync_all(&self) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::to_array(&self) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: core::marker::Copy + core::marker::Send + core::marker::Sync + core::default::Default + 'static> core::ops::drop::Drop for numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::drop(&mut self)
pub struct numrs2::memory_alloc::out_of_core::OutOfCoreConfig
pub numrs2::memory_alloc::out_of_core::OutOfCoreConfig::cache_strategy: numrs2::memory_alloc::out_of_core::CacheStrategy
pub numrs2::memory_alloc::out_of_core::OutOfCoreConfig::chunk_size: usize
pub numrs2::memory_alloc::out_of_core::OutOfCoreConfig::enable_prefetch: bool
pub numrs2::memory_alloc::out_of_core::OutOfCoreConfig::max_chunks_in_memory: usize
pub numrs2::memory_alloc::out_of_core::OutOfCoreConfig::prefetch_count: usize
pub numrs2::memory_alloc::out_of_core::OutOfCoreConfig::storage_path: std::path::PathBuf
pub numrs2::memory_alloc::out_of_core::OutOfCoreConfig::use_compression: bool
impl core::default::Default for numrs2::memory_alloc::out_of_core::OutOfCoreConfig
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreConfig::default() -> Self
pub mod numrs2::memory_alloc::performance_tuning
pub enum numrs2::memory_alloc::performance_tuning::OptimizationType
pub numrs2::memory_alloc::performance_tuning::OptimizationType::DecreaseBlockSize
pub numrs2::memory_alloc::performance_tuning::OptimizationType::EnablePreallocation
pub numrs2::memory_alloc::performance_tuning::OptimizationType::IncreaseBlockSize
pub numrs2::memory_alloc::performance_tuning::OptimizationType::OptimizeAlignment
pub numrs2::memory_alloc::performance_tuning::OptimizationType::OptimizeConcurrency
pub numrs2::memory_alloc::performance_tuning::OptimizationType::ReduceOverhead
pub numrs2::memory_alloc::performance_tuning::OptimizationType::UseArenaAllocation
pub numrs2::memory_alloc::performance_tuning::OptimizationType::UsePoolAllocation
pub struct numrs2::memory_alloc::performance_tuning::OptimizationRecommendation
pub numrs2::memory_alloc::performance_tuning::OptimizationRecommendation::description: alloc::string::String
pub numrs2::memory_alloc::performance_tuning::OptimizationRecommendation::difficulty: u8
pub numrs2::memory_alloc::performance_tuning::OptimizationRecommendation::estimated_improvement: f64
pub numrs2::memory_alloc::performance_tuning::OptimizationRecommendation::optimization_type: numrs2::memory_alloc::performance_tuning::OptimizationType
pub numrs2::memory_alloc::performance_tuning::OptimizationRecommendation::parameters: std::collections::hash::map::HashMap<alloc::string::String, alloc::string::String>
pub struct numrs2::memory_alloc::performance_tuning::PerformanceMetrics
pub numrs2::memory_alloc::performance_tuning::PerformanceMetrics::allocation_failures: u64
pub numrs2::memory_alloc::performance_tuning::PerformanceMetrics::avg_allocation_time_ns: u64
pub numrs2::memory_alloc::performance_tuning::PerformanceMetrics::avg_deallocation_time_ns: u64
pub numrs2::memory_alloc::performance_tuning::PerformanceMetrics::current_memory_usage: u64
pub numrs2::memory_alloc::performance_tuning::PerformanceMetrics::last_updated: std::time::Instant
pub numrs2::memory_alloc::performance_tuning::PerformanceMetrics::peak_memory_usage: u64
pub numrs2::memory_alloc::performance_tuning::PerformanceMetrics::total_allocations: u64
pub numrs2::memory_alloc::performance_tuning::PerformanceMetrics::total_bytes_allocated: u64
pub numrs2::memory_alloc::performance_tuning::PerformanceMetrics::total_bytes_deallocated: u64
pub numrs2::memory_alloc::performance_tuning::PerformanceMetrics::total_deallocations: u64
impl core::default::Default for numrs2::memory_alloc::performance_tuning::PerformanceMetrics
pub fn numrs2::memory_alloc::performance_tuning::PerformanceMetrics::default() -> Self
pub struct numrs2::memory_alloc::performance_tuning::PerformanceTuner
impl numrs2::memory_alloc::performance_tuning::PerformanceTuner
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::analyze_performance(&self) -> alloc::vec::Vec<numrs2::memory_alloc::performance_tuning::OptimizationRecommendation>
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::apply_optimization(&self, recommendation: &numrs2::memory_alloc::performance_tuning::OptimizationRecommendation) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::benchmark_allocator<A>(&mut self, allocator: &A, name: &str, config: numrs2::memory_alloc::benchmarking::BenchmarkConfig) -> numrs2::Result<numrs2::memory_alloc::benchmarking::BenchmarkResults> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::generate_performance_report(&self) -> alloc::string::String
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::get_current_metrics(&self) -> numrs2::memory_alloc::performance_tuning::PerformanceMetrics
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::new(config: numrs2::memory_alloc::performance_tuning::TuningConfig) -> Self
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::record_allocation(&self, size: usize, duration: core::time::Duration)
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::record_allocation_failure(&self)
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::record_deallocation(&self, size: usize, duration: core::time::Duration)
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::reset(&mut self)
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::take_snapshot(&mut self)
impl core::default::Default for numrs2::memory_alloc::performance_tuning::PerformanceTuner
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::default() -> Self
pub struct numrs2::memory_alloc::performance_tuning::TuningConfig
pub numrs2::memory_alloc::performance_tuning::TuningConfig::auto_tuning_enabled: bool
pub numrs2::memory_alloc::performance_tuning::TuningConfig::collection_interval_ms: u64
pub numrs2::memory_alloc::performance_tuning::TuningConfig::improvement_threshold: f64
pub numrs2::memory_alloc::performance_tuning::TuningConfig::max_history_size: usize
pub numrs2::memory_alloc::performance_tuning::TuningConfig::min_sample_size: u64
impl core::default::Default for numrs2::memory_alloc::performance_tuning::TuningConfig
pub fn numrs2::memory_alloc::performance_tuning::TuningConfig::default() -> Self
pub fn numrs2::memory_alloc::performance_tuning::init_global_tuner(config: numrs2::memory_alloc::performance_tuning::TuningConfig)
pub fn numrs2::memory_alloc::performance_tuning::with_global_tuner<F, R>(f: F) -> core::option::Option<R> where F: core::ops::function::FnOnce(&numrs2::memory_alloc::performance_tuning::PerformanceTuner) -> R
pub fn numrs2::memory_alloc::performance_tuning::with_global_tuner_mut<F, R>(f: F) -> core::option::Option<R> where F: core::ops::function::FnOnce(&mut numrs2::memory_alloc::performance_tuning::PerformanceTuner) -> R
pub mod numrs2::memory_alloc::pool
pub struct numrs2::memory_alloc::pool::PoolAllocator
impl numrs2::memory_alloc::pool::PoolAllocator
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate(&self) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::pool::PoolAllocator::available_blocks(&self) -> usize
pub fn numrs2::memory_alloc::pool::PoolAllocator::block_size(&self) -> usize
pub unsafe fn numrs2::memory_alloc::pool::PoolAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>)
pub fn numrs2::memory_alloc::pool::PoolAllocator::new(config: numrs2::memory_alloc::pool::PoolConfig) -> Self
pub fn numrs2::memory_alloc::pool::PoolAllocator::reset(&self)
pub fn numrs2::memory_alloc::pool::PoolAllocator::total_blocks(&self) -> usize
pub fn numrs2::memory_alloc::pool::PoolAllocator::used_blocks(&self) -> usize
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::pool::PoolAllocator
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::pool::PoolAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, _layout: core::alloc::layout::Layout)
pub struct numrs2::memory_alloc::pool::PoolConfig
pub numrs2::memory_alloc::pool::PoolConfig::auto_resize: bool
pub numrs2::memory_alloc::pool::PoolConfig::block_size: usize
pub numrs2::memory_alloc::pool::PoolConfig::growth_factor: f64
pub numrs2::memory_alloc::pool::PoolConfig::initial_blocks: usize
pub numrs2::memory_alloc::pool::PoolConfig::max_blocks: core::option::Option<usize>
impl core::default::Default for numrs2::memory_alloc::pool::PoolConfig
pub fn numrs2::memory_alloc::pool::PoolConfig::default() -> Self
pub mod numrs2::memory_alloc::presets
pub fn numrs2::memory_alloc::presets::matrix_allocator(_typical_matrix_size: usize) -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator>
pub fn numrs2::memory_alloc::presets::numerical_computing_allocator() -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator>
pub fn numrs2::memory_alloc::presets::temporary_object_allocator() -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator>
pub mod numrs2::memory_alloc::strategy
pub enum numrs2::memory_alloc::strategy::AllocFrequency
pub numrs2::memory_alloc::strategy::AllocFrequency::High
pub numrs2::memory_alloc::strategy::AllocFrequency::Low
pub numrs2::memory_alloc::strategy::AllocFrequency::Medium
pub numrs2::memory_alloc::strategy::AllocFrequency::VeryHigh
pub enum numrs2::memory_alloc::strategy::AllocStrategy
pub numrs2::memory_alloc::strategy::AllocStrategy::Aligned
pub numrs2::memory_alloc::strategy::AllocStrategy::Arena
pub numrs2::memory_alloc::strategy::AllocStrategy::Auto
pub numrs2::memory_alloc::strategy::AllocStrategy::Pool
pub numrs2::memory_alloc::strategy::AllocStrategy::Standard
pub struct numrs2::memory_alloc::strategy::AutoAllocator
impl numrs2::memory_alloc::strategy::AutoAllocator
pub fn numrs2::memory_alloc::strategy::AutoAllocator::new() -> Self
impl core::default::Default for numrs2::memory_alloc::strategy::AutoAllocator
pub fn numrs2::memory_alloc::strategy::AutoAllocator::default() -> Self
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::strategy::AutoAllocator
pub fn numrs2::memory_alloc::strategy::AutoAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::strategy::AutoAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::strategy::AutoAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
pub struct numrs2::memory_alloc::strategy::StandardAllocator
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::strategy::StandardAllocator
pub fn numrs2::memory_alloc::strategy::StandardAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::strategy::StandardAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::strategy::StandardAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
pub trait numrs2::memory_alloc::strategy::MemoryAllocator: core::marker::Send + core::marker::Sync
pub fn numrs2::memory_alloc::strategy::MemoryAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::strategy::MemoryAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::strategy::MemoryAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::aligned::AlignedAllocator
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::arena::ArenaAllocator
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::arena::ArenaAllocator::deallocate(&self, _ptr: core::ptr::non_null::NonNull<u8>, _layout: core::alloc::layout::Layout)
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::pool::PoolAllocator
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::pool::PoolAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, _layout: core::alloc::layout::Layout)
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::strategy::AutoAllocator
pub fn numrs2::memory_alloc::strategy::AutoAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::strategy::AutoAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::strategy::AutoAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::strategy::StandardAllocator
pub fn numrs2::memory_alloc::strategy::StandardAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::strategy::StandardAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::strategy::StandardAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
pub fn numrs2::memory_alloc::strategy::get_default_allocator() -> alloc::boxed::Box<dyn numrs2::memory_alloc::strategy::MemoryAllocator>
pub fn numrs2::memory_alloc::strategy::get_global_allocator_strategy() -> numrs2::memory_alloc::strategy::AllocStrategy
pub fn numrs2::memory_alloc::strategy::recommend_strategy(alloc_size: usize, alloc_frequency: numrs2::memory_alloc::strategy::AllocFrequency, simd_usage: bool) -> numrs2::memory_alloc::strategy::AllocStrategy
pub fn numrs2::memory_alloc::strategy::reset_global_allocator()
pub fn numrs2::memory_alloc::strategy::set_global_allocator(strategy: numrs2::memory_alloc::strategy::AllocStrategy)
pub enum numrs2::memory_alloc::AllocStrategy
pub numrs2::memory_alloc::AllocStrategy::Aligned
pub numrs2::memory_alloc::AllocStrategy::Arena
pub numrs2::memory_alloc::AllocStrategy::Auto
pub numrs2::memory_alloc::AllocStrategy::Pool
pub numrs2::memory_alloc::AllocStrategy::Standard
pub enum numrs2::memory_alloc::CacheLevel
pub numrs2::memory_alloc::CacheLevel::L1
pub numrs2::memory_alloc::CacheLevel::L2
pub numrs2::memory_alloc::CacheLevel::L3
pub enum numrs2::memory_alloc::CacheOptimizationType
pub numrs2::memory_alloc::CacheOptimizationType::AlignDataStructures
pub numrs2::memory_alloc::CacheOptimizationType::EliminateFalseSharing
pub numrs2::memory_alloc::CacheOptimizationType::EnablePrefetch
pub numrs2::memory_alloc::CacheOptimizationType::ImproveLocality
pub numrs2::memory_alloc::CacheOptimizationType::OptimizeStride
pub numrs2::memory_alloc::CacheOptimizationType::ReduceWorkingSet
pub numrs2::memory_alloc::CacheOptimizationType::UseBlocking
pub enum numrs2::memory_alloc::CacheStrategy
pub numrs2::memory_alloc::CacheStrategy::FIFO
pub numrs2::memory_alloc::CacheStrategy::LFU
pub numrs2::memory_alloc::CacheStrategy::LRU
pub enum numrs2::memory_alloc::OptimizationType
pub numrs2::memory_alloc::OptimizationType::DecreaseBlockSize
pub numrs2::memory_alloc::OptimizationType::EnablePreallocation
pub numrs2::memory_alloc::OptimizationType::IncreaseBlockSize
pub numrs2::memory_alloc::OptimizationType::OptimizeAlignment
pub numrs2::memory_alloc::OptimizationType::OptimizeConcurrency
pub numrs2::memory_alloc::OptimizationType::ReduceOverhead
pub numrs2::memory_alloc::OptimizationType::UseArenaAllocation
pub numrs2::memory_alloc::OptimizationType::UsePoolAllocation
pub struct numrs2::memory_alloc::AlignedAllocator
impl numrs2::memory_alloc::aligned::AlignedAllocator
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::alignment(&self) -> usize
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate_array<T>(&self, count: usize) -> core::option::Option<core::ptr::non_null::NonNull<T>>
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate_for_type<T>(&self) -> core::option::Option<core::ptr::non_null::NonNull<T>>
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::as_mut_slice<T>(&mut self, ptr: core::ptr::non_null::NonNull<T>, count: usize) -> &mut [T]
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::as_slice<T>(&self, ptr: core::ptr::non_null::NonNull<T>, count: usize) -> &[T]
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::create_array<T: core::marker::Copy>(&self, values: &[T]) -> core::option::Option<core::ptr::non_null::NonNull<T>>
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, size: usize)
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::deallocate_array<T>(&self, ptr: core::ptr::non_null::NonNull<T>, count: usize)
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::is_zero_initialized(&self) -> bool
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::new(config: numrs2::memory_alloc::aligned::AlignmentConfig) -> Self
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::aligned::AlignedAllocator
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
pub struct numrs2::memory_alloc::AlignmentConfig
pub numrs2::memory_alloc::AlignmentConfig::alignment: usize
pub numrs2::memory_alloc::AlignmentConfig::zero_init: bool
impl numrs2::memory_alloc::aligned::AlignmentConfig
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::cache_line() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::new(alignment: usize, zero_init: bool) -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::page() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::simd_128() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::simd_256() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::simd_512() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::zeroed(self) -> Self
impl core::default::Default for numrs2::memory_alloc::aligned::AlignmentConfig
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::default() -> Self
pub struct numrs2::memory_alloc::AllocatorBenchmark
impl numrs2::memory_alloc::benchmarking::AllocatorBenchmark
pub fn numrs2::memory_alloc::benchmarking::AllocatorBenchmark::benchmark_allocator<A>(&mut self, allocator: &A, name: &str) -> numrs2::Result<numrs2::memory_alloc::benchmarking::BenchmarkResults> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error> + ?core::marker::Sized
pub fn numrs2::memory_alloc::benchmarking::AllocatorBenchmark::compare_allocators(&mut self, allocators: alloc::vec::Vec<(alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>, alloc::string::String)>) -> numrs2::Result<alloc::vec::Vec<numrs2::memory_alloc::benchmarking::BenchmarkResults>>
pub fn numrs2::memory_alloc::benchmarking::AllocatorBenchmark::generate_comparison_report(results: &[numrs2::memory_alloc::benchmarking::BenchmarkResults]) -> alloc::string::String
pub fn numrs2::memory_alloc::benchmarking::AllocatorBenchmark::new(config: numrs2::memory_alloc::benchmarking::BenchmarkConfig) -> Self
impl core::default::Default for numrs2::memory_alloc::benchmarking::AllocatorBenchmark
pub fn numrs2::memory_alloc::benchmarking::AllocatorBenchmark::default() -> Self
pub struct numrs2::memory_alloc::ArenaAllocator
impl numrs2::memory_alloc::arena::ArenaAllocator
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate_aligned(&self, size: usize, alignment: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate_object<T>(&self) -> core::option::Option<core::ptr::non_null::NonNull<T>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::available_size(&self) -> usize
pub fn numrs2::memory_alloc::arena::ArenaAllocator::get_alignment(&self) -> usize
pub fn numrs2::memory_alloc::arena::ArenaAllocator::new(config: numrs2::memory_alloc::arena::ArenaConfig) -> Self
pub fn numrs2::memory_alloc::arena::ArenaAllocator::reset(&self)
pub fn numrs2::memory_alloc::arena::ArenaAllocator::scoped(&self) -> numrs2::memory_alloc::arena::ScopedArena
pub fn numrs2::memory_alloc::arena::ArenaAllocator::total_size(&self) -> usize
impl core::clone::Clone for numrs2::memory_alloc::arena::ArenaAllocator
pub fn numrs2::memory_alloc::arena::ArenaAllocator::clone(&self) -> Self
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::arena::ArenaAllocator
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::arena::ArenaAllocator::deallocate(&self, _ptr: core::ptr::non_null::NonNull<u8>, _layout: core::alloc::layout::Layout)
pub struct numrs2::memory_alloc::ArenaConfig
pub numrs2::memory_alloc::ArenaConfig::alignment: usize
pub numrs2::memory_alloc::ArenaConfig::allow_growth: bool
pub numrs2::memory_alloc::ArenaConfig::growth_factor: f64
pub numrs2::memory_alloc::ArenaConfig::initial_size: usize
impl core::default::Default for numrs2::memory_alloc::arena::ArenaConfig
pub fn numrs2::memory_alloc::arena::ArenaConfig::default() -> Self
pub struct numrs2::memory_alloc::BenchmarkConfig
pub numrs2::memory_alloc::BenchmarkConfig::concurrent_allocations: usize
pub numrs2::memory_alloc::BenchmarkConfig::enable_fragmentation: bool
pub numrs2::memory_alloc::BenchmarkConfig::iterations: usize
pub numrs2::memory_alloc::BenchmarkConfig::max_size: usize
pub numrs2::memory_alloc::BenchmarkConfig::memory_pressure: f64
pub numrs2::memory_alloc::BenchmarkConfig::min_size: usize
pub numrs2::memory_alloc::BenchmarkConfig::randomize_order: bool
pub numrs2::memory_alloc::BenchmarkConfig::randomize_sizes: bool
impl core::default::Default for numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub fn numrs2::memory_alloc::benchmarking::BenchmarkConfig::default() -> Self
pub struct numrs2::memory_alloc::BenchmarkResults
pub numrs2::memory_alloc::BenchmarkResults::allocation_efficiency: f64
pub numrs2::memory_alloc::BenchmarkResults::allocation_throughput: f64
pub numrs2::memory_alloc::BenchmarkResults::allocation_time: core::time::Duration
pub numrs2::memory_alloc::BenchmarkResults::allocator_name: alloc::string::String
pub numrs2::memory_alloc::BenchmarkResults::avg_allocation_time: core::time::Duration
pub numrs2::memory_alloc::BenchmarkResults::avg_deallocation_time: core::time::Duration
pub numrs2::memory_alloc::BenchmarkResults::bytes_per_second: f64
pub numrs2::memory_alloc::BenchmarkResults::config: numrs2::memory_alloc::benchmarking::BenchmarkConfig
pub numrs2::memory_alloc::BenchmarkResults::deallocation_time: core::time::Duration
pub numrs2::memory_alloc::BenchmarkResults::failed_allocations: usize
pub numrs2::memory_alloc::BenchmarkResults::fragmentation_level: f64
pub numrs2::memory_alloc::BenchmarkResults::latency_percentiles: (core::time::Duration, core::time::Duration, core::time::Duration, core::time::Duration)
pub numrs2::memory_alloc::BenchmarkResults::peak_memory_usage: usize
pub numrs2::memory_alloc::BenchmarkResults::size_distribution: std::collections::hash::map::HashMap<usize, usize>
pub numrs2::memory_alloc::BenchmarkResults::successful_allocations: usize
pub numrs2::memory_alloc::BenchmarkResults::total_bytes_allocated: usize
impl core::fmt::Display for numrs2::memory_alloc::benchmarking::BenchmarkResults
pub fn numrs2::memory_alloc::benchmarking::BenchmarkResults::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::memory_alloc::CacheConfig
pub numrs2::memory_alloc::CacheConfig::cache_line_size: usize
pub numrs2::memory_alloc::CacheConfig::enable_blocking: bool
pub numrs2::memory_alloc::CacheConfig::enable_cache_padding: bool
pub numrs2::memory_alloc::CacheConfig::enable_prefetch: bool
pub numrs2::memory_alloc::CacheConfig::l1_cache_size: usize
pub numrs2::memory_alloc::CacheConfig::l2_cache_size: usize
pub numrs2::memory_alloc::CacheConfig::l3_cache_size: usize
pub numrs2::memory_alloc::CacheConfig::optimize_access_patterns: bool
impl core::default::Default for numrs2::memory_alloc::cache_optimization::CacheConfig
pub fn numrs2::memory_alloc::cache_optimization::CacheConfig::default() -> Self
pub struct numrs2::memory_alloc::CacheMetrics
pub numrs2::memory_alloc::CacheMetrics::avg_latency_ns: f64
pub numrs2::memory_alloc::CacheMetrics::cache_efficiency: f64
pub numrs2::memory_alloc::CacheMetrics::l1_hits: u64
pub numrs2::memory_alloc::CacheMetrics::l1_misses: u64
pub numrs2::memory_alloc::CacheMetrics::l2_hits: u64
pub numrs2::memory_alloc::CacheMetrics::l2_misses: u64
pub numrs2::memory_alloc::CacheMetrics::last_updated: core::option::Option<std::time::Instant>
pub numrs2::memory_alloc::CacheMetrics::total_accesses: u64
impl numrs2::memory_alloc::cache_optimization::CacheMetrics
pub fn numrs2::memory_alloc::cache_optimization::CacheMetrics::l1_hit_ratio(&self) -> f64
pub fn numrs2::memory_alloc::cache_optimization::CacheMetrics::l2_hit_ratio(&self) -> f64
pub fn numrs2::memory_alloc::cache_optimization::CacheMetrics::overall_efficiency(&self) -> f64
pub struct numrs2::memory_alloc::CacheOptimizationRecommendation
pub numrs2::memory_alloc::CacheOptimizationRecommendation::complexity: u8
pub numrs2::memory_alloc::CacheOptimizationRecommendation::description: alloc::string::String
pub numrs2::memory_alloc::CacheOptimizationRecommendation::estimated_improvement: f64
pub numrs2::memory_alloc::CacheOptimizationRecommendation::optimization_type: numrs2::memory_alloc::cache_optimization::CacheOptimizationType
pub numrs2::memory_alloc::CacheOptimizationRecommendation::target_cache_level: numrs2::memory_alloc::cache_optimization::CacheLevel
pub struct numrs2::memory_alloc::CacheOptimizedAllocator
impl numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::analyze_cache_performance(&self) -> alloc::vec::Vec<numrs2::memory_alloc::cache_optimization::CacheOptimizationRecommendation>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::fits_in_cache(&self, size: usize, cache_level: numrs2::memory_alloc::cache_optimization::CacheLevel) -> bool
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::get_cache_metrics(&self) -> numrs2::memory_alloc::cache_optimization::CacheMetrics
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::new(config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::optimal_block_size(&self, element_size: usize, cache_level: numrs2::memory_alloc::cache_optimization::CacheLevel) -> usize
impl core::default::Default for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::default() -> Self
impl core::fmt::Debug for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl numrs2::traits::MemoryAllocator for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub type numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::memory_alloc::CacheStats
pub numrs2::memory_alloc::CacheStats::cache_limit: usize
pub numrs2::memory_alloc::CacheStats::chunks_in_memory: usize
pub numrs2::memory_alloc::CacheStats::chunks_on_disk: usize
pub numrs2::memory_alloc::CacheStats::dirty_chunks: usize
pub numrs2::memory_alloc::CacheStats::total_chunks: usize
pub struct numrs2::memory_alloc::ChunkIterator<'a, T>
impl<'a, T> numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>
pub fn numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>::new(data: &'a [T], chunk_size: usize) -> Self
impl<'a, T> core::iter::traits::iterator::Iterator for numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>
pub type numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>::Item = &'a [T]
pub fn numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>::next(&mut self) -> core::option::Option<Self::Item>
pub struct numrs2::memory_alloc::EnhancedAllocatorBridge<T: numrs2::memory_alloc::strategy::MemoryAllocator>
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::new(allocator: T) -> Self
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::traits::MemoryAllocator for numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub type numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::supports_layout(&self, _layout: core::alloc::layout::Layout) -> bool
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::memory_alloc::IntelligentAllocationStrategy
impl numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::new() -> Self
impl core::default::Default for numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::default() -> Self
impl numrs2::traits::AllocationStrategy for numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::select_allocator(&self, requirements: &numrs2::traits::AllocationRequirements) -> alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::strategy_stats(&self) -> numrs2::traits::StrategyStats
pub struct numrs2::memory_alloc::LargeScaleConfig
pub numrs2::memory_alloc::LargeScaleConfig::background_cleanup: bool
pub numrs2::memory_alloc::LargeScaleConfig::chunk_size: usize
pub numrs2::memory_alloc::LargeScaleConfig::enable_stats: bool
pub numrs2::memory_alloc::LargeScaleConfig::max_memory_usage: usize
pub numrs2::memory_alloc::LargeScaleConfig::monitor_interval_ms: u64
pub numrs2::memory_alloc::LargeScaleConfig::spill_threshold: f64
pub numrs2::memory_alloc::LargeScaleConfig::temp_dir: std::path::PathBuf
impl core::default::Default for numrs2::memory_alloc::large_scale::LargeScaleConfig
pub fn numrs2::memory_alloc::large_scale::LargeScaleConfig::default() -> Self
pub struct numrs2::memory_alloc::LargeScaleManager
impl numrs2::memory_alloc::large_scale::LargeScaleManager
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::chunk_iterator<'a, T>(&self, data: &'a [T], chunk_size: core::option::Option<usize>) -> numrs2::memory_alloc::large_scale::ChunkIterator<'a, T>
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::cleanup_spilled_data(&self, max_age_seconds: u64) -> usize
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::config(&self) -> &numrs2::memory_alloc::large_scale::LargeScaleConfig
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::force_cleanup_all(&self)
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::get_memory_stats(&self) -> numrs2::memory_alloc::large_scale::MemoryStats
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::get_spill_stats(&self) -> numrs2::memory_alloc::large_scale::SpillStats
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::list_spilled_data(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::load_spilled_data(&self, spill_id: &str) -> numrs2::Result<alloc::vec::Vec<u8>>
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::new(config: numrs2::memory_alloc::large_scale::LargeScaleConfig) -> numrs2::Result<Self>
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::remove_spilled_data(&self, spill_id: &str) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::should_spill(&self) -> bool
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::spill_data(&self, data: &[u8], id: core::option::Option<alloc::string::String>) -> numrs2::Result<alloc::string::String>
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::tracker(&self) -> &alloc::sync::Arc<numrs2::memory_alloc::large_scale::MemoryTracker>
impl core::ops::drop::Drop for numrs2::memory_alloc::large_scale::LargeScaleManager
pub fn numrs2::memory_alloc::large_scale::LargeScaleManager::drop(&mut self)
pub struct numrs2::memory_alloc::MemoryStats
pub numrs2::memory_alloc::MemoryStats::active_allocations: usize
pub numrs2::memory_alloc::MemoryStats::current_usage: usize
pub numrs2::memory_alloc::MemoryStats::peak_usage: usize
pub numrs2::memory_alloc::MemoryStats::total_allocations: usize
pub numrs2::memory_alloc::MemoryStats::total_deallocations: usize
pub struct numrs2::memory_alloc::MemoryTracker
impl numrs2::memory_alloc::large_scale::MemoryTracker
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::active_allocations(&self) -> usize
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::current_usage(&self) -> usize
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::get_stats(&self) -> numrs2::memory_alloc::large_scale::MemoryStats
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::new() -> Self
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::peak_usage(&self) -> usize
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::record_allocation(&self, size: usize)
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::record_deallocation(&self, size: usize)
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::reset_stats(&self)
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::set_enabled(&self, enabled: bool)
impl core::default::Default for numrs2::memory_alloc::large_scale::MemoryTracker
pub fn numrs2::memory_alloc::large_scale::MemoryTracker::default() -> Self
pub struct numrs2::memory_alloc::MonitoredAllocator<A>
impl<A> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::generate_performance_report(&self) -> alloc::string::String
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::get_optimization_recommendations(&self) -> alloc::vec::Vec<numrs2::memory_alloc::performance_tuning::OptimizationRecommendation>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::get_performance_metrics(&self) -> numrs2::memory_alloc::performance_tuning::PerformanceMetrics
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::new(inner: A, monitoring_config: numrs2::memory_alloc::monitored_allocator::MonitoringConfig, tuning_config: numrs2::memory_alloc::performance_tuning::TuningConfig) -> Self
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::reset_metrics(&self)
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::set_auto_optimization(&mut self, enabled: bool)
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::take_performance_snapshot(&self)
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::with_defaults(inner: A) -> Self
impl<A: core::fmt::Debug> core::fmt::Debug for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A> numrs2::traits::AllocationStrategy for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error> + numrs2::traits::AllocationStrategy
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::select_allocator(&self, _requirements: &numrs2::traits::AllocationRequirements) -> alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::strategy_stats(&self) -> numrs2::traits::StrategyStats
impl<A> numrs2::traits::MemoryAllocator for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
pub type numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl<A> numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::memory_alloc::MonitoredAllocatorFactory
impl numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory::create_monitored_enhanced<T>(&self, inner: T) -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>> where T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory::create_monitored_numerical(&self) -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory::create_monitored_simd_optimized(&self) -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory::new(monitoring_config: numrs2::memory_alloc::monitored_allocator::MonitoringConfig, tuning_config: numrs2::memory_alloc::performance_tuning::TuningConfig) -> Self
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory::wrap<A>(&self, allocator: A) -> numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
impl core::default::Default for numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocatorFactory::default() -> Self
pub struct numrs2::memory_alloc::MonitoringConfig
pub numrs2::memory_alloc::MonitoringConfig::auto_optimization: bool
pub numrs2::memory_alloc::MonitoringConfig::detailed_timing: bool
pub numrs2::memory_alloc::MonitoringConfig::max_tracked_allocations: usize
pub numrs2::memory_alloc::MonitoringConfig::min_monitored_size: usize
pub numrs2::memory_alloc::MonitoringConfig::report_frequency: u64
impl core::default::Default for numrs2::memory_alloc::monitored_allocator::MonitoringConfig
pub fn numrs2::memory_alloc::monitored_allocator::MonitoringConfig::default() -> Self
pub struct numrs2::memory_alloc::NumericalArrayAllocator
impl numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::new() -> Self
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::with_alignment(alignment: usize) -> Self
impl core::default::Default for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::default() -> Self
impl numrs2::traits::ArrayAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub type numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate_array<T>(&self, len: usize) -> core::result::Result<core::ptr::non_null::NonNull<T>, Self::Error>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate_simd_aligned<T>(&self, len: usize, alignment: usize) -> core::result::Result<core::ptr::non_null::NonNull<T>, Self::Error>
impl numrs2::traits::MemoryAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub type numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::memory_alloc::OptimizationRecommendation
pub numrs2::memory_alloc::OptimizationRecommendation::description: alloc::string::String
pub numrs2::memory_alloc::OptimizationRecommendation::difficulty: u8
pub numrs2::memory_alloc::OptimizationRecommendation::estimated_improvement: f64
pub numrs2::memory_alloc::OptimizationRecommendation::optimization_type: numrs2::memory_alloc::performance_tuning::OptimizationType
pub numrs2::memory_alloc::OptimizationRecommendation::parameters: std::collections::hash::map::HashMap<alloc::string::String, alloc::string::String>
pub struct numrs2::memory_alloc::OutOfCoreArray<T: core::marker::Copy + core::marker::Send + core::marker::Sync + core::default::Default + 'static>
impl<T: core::marker::Copy + core::marker::Send + core::marker::Sync + core::default::Default + 'static> numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::from_data(data: alloc::vec::Vec<T>, shape: alloc::vec::Vec<usize>, config: numrs2::memory_alloc::out_of_core::OutOfCoreConfig) -> numrs2::Result<Self>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::get(&self, indices: &[usize]) -> numrs2::Result<T>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::get_cache_stats(&self) -> numrs2::memory_alloc::out_of_core::CacheStats
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::get_linear(&self, linear_index: usize) -> numrs2::Result<T>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::get_memory_stats(&self) -> numrs2::memory_alloc::large_scale::MemoryStats
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::is_empty(&self) -> bool
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::len(&self) -> usize
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::new(shape: alloc::vec::Vec<usize>, config: numrs2::memory_alloc::out_of_core::OutOfCoreConfig) -> numrs2::Result<Self>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::num_chunks(&self) -> usize
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::set_linear(&mut self, linear_index: usize, value: T) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::shape(&self) -> &[usize]
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::sync_all(&self) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::to_array(&self) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: core::marker::Copy + core::marker::Send + core::marker::Sync + core::default::Default + 'static> core::ops::drop::Drop for numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreArray<T>::drop(&mut self)
pub struct numrs2::memory_alloc::OutOfCoreConfig
pub numrs2::memory_alloc::OutOfCoreConfig::cache_strategy: numrs2::memory_alloc::out_of_core::CacheStrategy
pub numrs2::memory_alloc::OutOfCoreConfig::chunk_size: usize
pub numrs2::memory_alloc::OutOfCoreConfig::enable_prefetch: bool
pub numrs2::memory_alloc::OutOfCoreConfig::max_chunks_in_memory: usize
pub numrs2::memory_alloc::OutOfCoreConfig::prefetch_count: usize
pub numrs2::memory_alloc::OutOfCoreConfig::storage_path: std::path::PathBuf
pub numrs2::memory_alloc::OutOfCoreConfig::use_compression: bool
impl core::default::Default for numrs2::memory_alloc::out_of_core::OutOfCoreConfig
pub fn numrs2::memory_alloc::out_of_core::OutOfCoreConfig::default() -> Self
pub struct numrs2::memory_alloc::PerformanceMetrics
pub numrs2::memory_alloc::PerformanceMetrics::allocation_failures: u64
pub numrs2::memory_alloc::PerformanceMetrics::avg_allocation_time_ns: u64
pub numrs2::memory_alloc::PerformanceMetrics::avg_deallocation_time_ns: u64
pub numrs2::memory_alloc::PerformanceMetrics::current_memory_usage: u64
pub numrs2::memory_alloc::PerformanceMetrics::last_updated: std::time::Instant
pub numrs2::memory_alloc::PerformanceMetrics::peak_memory_usage: u64
pub numrs2::memory_alloc::PerformanceMetrics::total_allocations: u64
pub numrs2::memory_alloc::PerformanceMetrics::total_bytes_allocated: u64
pub numrs2::memory_alloc::PerformanceMetrics::total_bytes_deallocated: u64
pub numrs2::memory_alloc::PerformanceMetrics::total_deallocations: u64
impl core::default::Default for numrs2::memory_alloc::performance_tuning::PerformanceMetrics
pub fn numrs2::memory_alloc::performance_tuning::PerformanceMetrics::default() -> Self
pub struct numrs2::memory_alloc::PerformanceTuner
impl numrs2::memory_alloc::performance_tuning::PerformanceTuner
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::analyze_performance(&self) -> alloc::vec::Vec<numrs2::memory_alloc::performance_tuning::OptimizationRecommendation>
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::apply_optimization(&self, recommendation: &numrs2::memory_alloc::performance_tuning::OptimizationRecommendation) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::benchmark_allocator<A>(&mut self, allocator: &A, name: &str, config: numrs2::memory_alloc::benchmarking::BenchmarkConfig) -> numrs2::Result<numrs2::memory_alloc::benchmarking::BenchmarkResults> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::generate_performance_report(&self) -> alloc::string::String
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::get_current_metrics(&self) -> numrs2::memory_alloc::performance_tuning::PerformanceMetrics
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::new(config: numrs2::memory_alloc::performance_tuning::TuningConfig) -> Self
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::record_allocation(&self, size: usize, duration: core::time::Duration)
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::record_allocation_failure(&self)
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::record_deallocation(&self, size: usize, duration: core::time::Duration)
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::reset(&mut self)
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::take_snapshot(&mut self)
impl core::default::Default for numrs2::memory_alloc::performance_tuning::PerformanceTuner
pub fn numrs2::memory_alloc::performance_tuning::PerformanceTuner::default() -> Self
pub struct numrs2::memory_alloc::PoolAllocator
impl numrs2::memory_alloc::pool::PoolAllocator
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate(&self) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::pool::PoolAllocator::available_blocks(&self) -> usize
pub fn numrs2::memory_alloc::pool::PoolAllocator::block_size(&self) -> usize
pub unsafe fn numrs2::memory_alloc::pool::PoolAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>)
pub fn numrs2::memory_alloc::pool::PoolAllocator::new(config: numrs2::memory_alloc::pool::PoolConfig) -> Self
pub fn numrs2::memory_alloc::pool::PoolAllocator::reset(&self)
pub fn numrs2::memory_alloc::pool::PoolAllocator::total_blocks(&self) -> usize
pub fn numrs2::memory_alloc::pool::PoolAllocator::used_blocks(&self) -> usize
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::pool::PoolAllocator
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::pool::PoolAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, _layout: core::alloc::layout::Layout)
pub struct numrs2::memory_alloc::PoolConfig
pub numrs2::memory_alloc::PoolConfig::auto_resize: bool
pub numrs2::memory_alloc::PoolConfig::block_size: usize
pub numrs2::memory_alloc::PoolConfig::growth_factor: f64
pub numrs2::memory_alloc::PoolConfig::initial_blocks: usize
pub numrs2::memory_alloc::PoolConfig::max_blocks: core::option::Option<usize>
impl core::default::Default for numrs2::memory_alloc::pool::PoolConfig
pub fn numrs2::memory_alloc::pool::PoolConfig::default() -> Self
pub struct numrs2::memory_alloc::SpillStats
pub numrs2::memory_alloc::SpillStats::spilled_count: usize
pub numrs2::memory_alloc::SpillStats::temp_dir: std::path::PathBuf
pub numrs2::memory_alloc::SpillStats::total_spilled_size: usize
pub struct numrs2::memory_alloc::TuningConfig
pub numrs2::memory_alloc::TuningConfig::auto_tuning_enabled: bool
pub numrs2::memory_alloc::TuningConfig::collection_interval_ms: u64
pub numrs2::memory_alloc::TuningConfig::improvement_threshold: f64
pub numrs2::memory_alloc::TuningConfig::max_history_size: usize
pub numrs2::memory_alloc::TuningConfig::min_sample_size: u64
impl core::default::Default for numrs2::memory_alloc::performance_tuning::TuningConfig
pub fn numrs2::memory_alloc::performance_tuning::TuningConfig::default() -> Self
pub trait numrs2::memory_alloc::MemoryAllocator: core::marker::Send + core::marker::Sync
pub fn numrs2::memory_alloc::MemoryAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::MemoryAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::MemoryAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::aligned::AlignedAllocator
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::arena::ArenaAllocator
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::arena::ArenaAllocator::deallocate(&self, _ptr: core::ptr::non_null::NonNull<u8>, _layout: core::alloc::layout::Layout)
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::pool::PoolAllocator
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::pool::PoolAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, _layout: core::alloc::layout::Layout)
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::strategy::AutoAllocator
pub fn numrs2::memory_alloc::strategy::AutoAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::strategy::AutoAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::strategy::AutoAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::strategy::StandardAllocator
pub fn numrs2::memory_alloc::strategy::StandardAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::strategy::StandardAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::strategy::StandardAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
pub fn numrs2::memory_alloc::get_default_allocator() -> alloc::boxed::Box<dyn numrs2::memory_alloc::strategy::MemoryAllocator>
pub fn numrs2::memory_alloc::get_global_allocator_strategy() -> numrs2::memory_alloc::strategy::AllocStrategy
pub fn numrs2::memory_alloc::get_global_memory_stats() -> numrs2::Result<numrs2::memory_alloc::large_scale::MemoryStats>
pub fn numrs2::memory_alloc::get_global_spill_stats() -> numrs2::Result<numrs2::memory_alloc::large_scale::SpillStats>
pub fn numrs2::memory_alloc::init_global_allocator(strategy: numrs2::memory_alloc::strategy::AllocStrategy)
pub fn numrs2::memory_alloc::init_global_manager(config: numrs2::memory_alloc::large_scale::LargeScaleConfig) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::init_global_tuner(config: numrs2::memory_alloc::performance_tuning::TuningConfig)
pub fn numrs2::memory_alloc::load_spilled_data_globally(spill_id: &str) -> numrs2::Result<alloc::vec::Vec<u8>>
pub fn numrs2::memory_alloc::reset_global_allocator()
pub fn numrs2::memory_alloc::should_spill_globally() -> bool
pub fn numrs2::memory_alloc::spill_data_globally(data: &[u8], id: core::option::Option<alloc::string::String>) -> numrs2::Result<alloc::string::String>
pub fn numrs2::memory_alloc::with_global_manager<F, R>(f: F) -> numrs2::Result<R> where F: core::ops::function::FnOnce(&numrs2::memory_alloc::large_scale::LargeScaleManager) -> R
pub fn numrs2::memory_alloc::with_global_manager_mut<F, R>(f: F) -> numrs2::Result<R> where F: core::ops::function::FnOnce(&mut numrs2::memory_alloc::large_scale::LargeScaleManager) -> numrs2::Result<R>
pub fn numrs2::memory_alloc::with_global_tuner<F, R>(f: F) -> core::option::Option<R> where F: core::ops::function::FnOnce(&numrs2::memory_alloc::performance_tuning::PerformanceTuner) -> R
pub fn numrs2::memory_alloc::with_global_tuner_mut<F, R>(f: F) -> core::option::Option<R> where F: core::ops::function::FnOnce(&mut numrs2::memory_alloc::performance_tuning::PerformanceTuner) -> R
pub mod numrs2::memory_optimize
pub mod numrs2::memory_optimize::access_patterns
pub enum numrs2::memory_optimize::access_patterns::AccessPattern
pub numrs2::memory_optimize::access_patterns::AccessPattern::Blocked
pub numrs2::memory_optimize::access_patterns::AccessPattern::Random
pub numrs2::memory_optimize::access_patterns::AccessPattern::Reverse
pub numrs2::memory_optimize::access_patterns::AccessPattern::Sequential
pub numrs2::memory_optimize::access_patterns::AccessPattern::Strided(usize)
impl numrs2::memory_optimize::access_patterns::AccessPattern
pub fn numrs2::memory_optimize::access_patterns::AccessPattern::benefits_from_prefetch(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::AccessPattern::prefetch_distance(&self) -> usize
pub enum numrs2::memory_optimize::access_patterns::CacheLevel
pub numrs2::memory_optimize::access_patterns::CacheLevel::L1
pub numrs2::memory_optimize::access_patterns::CacheLevel::L2
pub numrs2::memory_optimize::access_patterns::CacheLevel::L3
pub enum numrs2::memory_optimize::access_patterns::MemoryLayout
pub numrs2::memory_optimize::access_patterns::MemoryLayout::CContiguous
pub numrs2::memory_optimize::access_patterns::MemoryLayout::FContiguous
pub numrs2::memory_optimize::access_patterns::MemoryLayout::Scalar
pub numrs2::memory_optimize::access_patterns::MemoryLayout::Strided
impl numrs2::memory_optimize::access_patterns::MemoryLayout
pub fn numrs2::memory_optimize::access_patterns::MemoryLayout::is_c_optimal(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::MemoryLayout::is_contiguous(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::MemoryLayout::is_f_optimal(&self) -> bool
pub struct numrs2::memory_optimize::access_patterns::AccessStats
pub numrs2::memory_optimize::access_patterns::AccessStats::estimated_miss_rate: f64
pub numrs2::memory_optimize::access_patterns::AccessStats::random_accesses: u64
pub numrs2::memory_optimize::access_patterns::AccessStats::sequential_accesses: u64
pub numrs2::memory_optimize::access_patterns::AccessStats::strided_accesses: u64
pub numrs2::memory_optimize::access_patterns::AccessStats::total_accesses: u64
impl numrs2::memory_optimize::access_patterns::AccessStats
pub fn numrs2::memory_optimize::access_patterns::AccessStats::cache_efficiency(&self) -> f64
pub fn numrs2::memory_optimize::access_patterns::AccessStats::new() -> Self
pub fn numrs2::memory_optimize::access_patterns::AccessStats::record_random(&mut self)
pub fn numrs2::memory_optimize::access_patterns::AccessStats::record_sequential(&mut self)
pub fn numrs2::memory_optimize::access_patterns::AccessStats::record_strided(&mut self)
pub fn numrs2::memory_optimize::access_patterns::AccessStats::update_miss_rate(&mut self)
pub struct numrs2::memory_optimize::access_patterns::Block
pub numrs2::memory_optimize::access_patterns::Block::end: usize
pub numrs2::memory_optimize::access_patterns::Block::start: usize
impl numrs2::memory_optimize::access_patterns::Block
pub fn numrs2::memory_optimize::access_patterns::Block::is_empty(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::Block::iter(&self) -> core::ops::range::Range<usize>
pub fn numrs2::memory_optimize::access_patterns::Block::len(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::Block::new(start: usize, end: usize) -> Self
pub struct numrs2::memory_optimize::access_patterns::BlockedIterator
impl numrs2::memory_optimize::access_patterns::BlockedIterator
pub fn numrs2::memory_optimize::access_patterns::BlockedIterator::for_type<T>(total: usize, cache: numrs2::memory_optimize::access_patterns::CacheConfig) -> Self
pub fn numrs2::memory_optimize::access_patterns::BlockedIterator::new(total: usize, block_size: usize) -> Self
impl core::iter::traits::exact_size::ExactSizeIterator for numrs2::memory_optimize::access_patterns::BlockedIterator
impl core::iter::traits::iterator::Iterator for numrs2::memory_optimize::access_patterns::BlockedIterator
pub type numrs2::memory_optimize::access_patterns::BlockedIterator::Item = numrs2::memory_optimize::access_patterns::Block
pub fn numrs2::memory_optimize::access_patterns::BlockedIterator::next(&mut self) -> core::option::Option<Self::Item>
pub fn numrs2::memory_optimize::access_patterns::BlockedIterator::size_hint(&self) -> (usize, core::option::Option<usize>)
pub struct numrs2::memory_optimize::access_patterns::CacheConfig
pub numrs2::memory_optimize::access_patterns::CacheConfig::associativity: usize
pub numrs2::memory_optimize::access_patterns::CacheConfig::level: numrs2::memory_optimize::access_patterns::CacheLevel
pub numrs2::memory_optimize::access_patterns::CacheConfig::line_size: usize
pub numrs2::memory_optimize::access_patterns::CacheConfig::size_bytes: usize
impl numrs2::memory_optimize::access_patterns::CacheConfig
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::elements_per_block<T>(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::elements_per_line<T>(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::l1_default() -> Self
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::l2_default() -> Self
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::l3_default() -> Self
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::new(level: numrs2::memory_optimize::access_patterns::CacheLevel, size_bytes: usize, line_size: usize, associativity: usize) -> Self
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::tile_size_2d<T>(&self) -> (usize, usize)
impl core::default::Default for numrs2::memory_optimize::access_patterns::CacheConfig
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::default() -> Self
pub struct numrs2::memory_optimize::access_patterns::OptimizationHints
pub numrs2::memory_optimize::access_patterns::OptimizationHints::access_pattern: numrs2::memory_optimize::access_patterns::AccessPattern
pub numrs2::memory_optimize::access_patterns::OptimizationHints::block_size: usize
pub numrs2::memory_optimize::access_patterns::OptimizationHints::cache_efficiency: f64
pub numrs2::memory_optimize::access_patterns::OptimizationHints::layout: numrs2::memory_optimize::access_patterns::MemoryLayout
pub numrs2::memory_optimize::access_patterns::OptimizationHints::tile_size: core::option::Option<(usize, usize)>
pub numrs2::memory_optimize::access_patterns::OptimizationHints::use_parallel: bool
impl numrs2::memory_optimize::access_patterns::OptimizationHints
pub fn numrs2::memory_optimize::access_patterns::OptimizationHints::analyze<T>(shape: &[usize], strides: &[usize]) -> Self
pub fn numrs2::memory_optimize::access_patterns::OptimizationHints::default_for<T>(total_elements: usize) -> Self
impl core::default::Default for numrs2::memory_optimize::access_patterns::OptimizationHints
pub fn numrs2::memory_optimize::access_patterns::OptimizationHints::default() -> Self
pub struct numrs2::memory_optimize::access_patterns::StrideOptimizer
impl numrs2::memory_optimize::access_patterns::StrideOptimizer
pub fn numrs2::memory_optimize::access_patterns::StrideOptimizer::bandwidth_efficiency(&self) -> f64
pub fn numrs2::memory_optimize::access_patterns::StrideOptimizer::new(shape: &[usize], strides: &[usize]) -> Self
pub fn numrs2::memory_optimize::access_patterns::StrideOptimizer::optimal_iteration_order(&self) -> &[usize]
pub fn numrs2::memory_optimize::access_patterns::StrideOptimizer::should_copy(&self) -> bool
pub struct numrs2::memory_optimize::access_patterns::Tile2D
pub numrs2::memory_optimize::access_patterns::Tile2D::col_end: usize
pub numrs2::memory_optimize::access_patterns::Tile2D::col_start: usize
pub numrs2::memory_optimize::access_patterns::Tile2D::row_end: usize
pub numrs2::memory_optimize::access_patterns::Tile2D::row_start: usize
impl numrs2::memory_optimize::access_patterns::Tile2D
pub fn numrs2::memory_optimize::access_patterns::Tile2D::cols(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::Tile2D::is_empty(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::Tile2D::len(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::Tile2D::new(row_start: usize, row_end: usize, col_start: usize, col_end: usize) -> Self
pub fn numrs2::memory_optimize::access_patterns::Tile2D::rows(&self) -> usize
pub struct numrs2::memory_optimize::access_patterns::TiledIterator2D
impl numrs2::memory_optimize::access_patterns::TiledIterator2D
pub fn numrs2::memory_optimize::access_patterns::TiledIterator2D::for_type<T>(total_rows: usize, total_cols: usize, cache: numrs2::memory_optimize::access_patterns::CacheConfig) -> Self
pub fn numrs2::memory_optimize::access_patterns::TiledIterator2D::new(total_rows: usize, total_cols: usize, tile_rows: usize, tile_cols: usize) -> Self
impl core::iter::traits::exact_size::ExactSizeIterator for numrs2::memory_optimize::access_patterns::TiledIterator2D
impl core::iter::traits::iterator::Iterator for numrs2::memory_optimize::access_patterns::TiledIterator2D
pub type numrs2::memory_optimize::access_patterns::TiledIterator2D::Item = numrs2::memory_optimize::access_patterns::Tile2D
pub fn numrs2::memory_optimize::access_patterns::TiledIterator2D::next(&mut self) -> core::option::Option<Self::Item>
pub fn numrs2::memory_optimize::access_patterns::TiledIterator2D::size_hint(&self) -> (usize, core::option::Option<usize>)
pub fn numrs2::memory_optimize::access_patterns::cache_aware_binary_op<T, U, V, F>(a: &[T], b: &[U], result: &mut [V], f: F) where T: core::marker::Copy, U: core::marker::Copy, F: core::ops::function::Fn(T, U) -> V
pub fn numrs2::memory_optimize::access_patterns::cache_aware_copy<T: core::marker::Copy>(src: &[T], dst: &mut [T])
pub fn numrs2::memory_optimize::access_patterns::cache_aware_transform<T, U, F>(src: &[T], dst: &mut [U], f: F) where T: core::marker::Copy, F: core::ops::function::Fn(T) -> U
pub fn numrs2::memory_optimize::access_patterns::detect_layout(shape: &[usize], strides: &[usize]) -> numrs2::memory_optimize::access_patterns::MemoryLayout
pub mod numrs2::memory_optimize::alignment
pub enum numrs2::memory_optimize::alignment::AlignmentStrategy
pub numrs2::memory_optimize::alignment::AlignmentStrategy::CacheLine
pub numrs2::memory_optimize::alignment::AlignmentStrategy::Custom(usize)
pub numrs2::memory_optimize::alignment::AlignmentStrategy::Default
pub numrs2::memory_optimize::alignment::AlignmentStrategy::Simd
pub struct numrs2::memory_optimize::alignment::AlignmentInfo
pub numrs2::memory_optimize::alignment::AlignmentInfo::address: usize
pub numrs2::memory_optimize::alignment::AlignmentInfo::cache_line_aligned: bool
pub numrs2::memory_optimize::alignment::AlignmentInfo::cache_line_size: usize
pub numrs2::memory_optimize::alignment::AlignmentInfo::natural_aligned: bool
pub numrs2::memory_optimize::alignment::AlignmentInfo::simd_aligned: bool
pub numrs2::memory_optimize::alignment::AlignmentInfo::simd_alignment: usize
pub numrs2::memory_optimize::alignment::AlignmentInfo::type_alignment: usize
pub fn numrs2::memory_optimize::alignment::align_address(addr: usize, alignment: usize) -> usize
pub fn numrs2::memory_optimize::alignment::align_data<T: core::marker::Copy>(data: &mut [T], strategy: numrs2::memory_optimize::alignment::AlignmentStrategy)
pub fn numrs2::memory_optimize::alignment::alignment_padding(offset: usize, alignment: usize) -> usize
pub fn numrs2::memory_optimize::alignment::create_aligned_buffer<T: core::marker::Copy + core::default::Default>(size: usize, alignment: usize) -> alloc::vec::Vec<T>
pub fn numrs2::memory_optimize::alignment::create_aligned_vec<T: core::marker::Copy>(data: &[T], alignment: usize) -> alloc::vec::Vec<T>
pub fn numrs2::memory_optimize::alignment::get_alignment_info<T>(data: &[T]) -> numrs2::memory_optimize::alignment::AlignmentInfo
pub fn numrs2::memory_optimize::alignment::get_optimal_alignment_for_type<T>() -> usize
pub fn numrs2::memory_optimize::alignment::is_aligned<T>(ptr: *const T, alignment: usize) -> bool
pub fn numrs2::memory_optimize::alignment::is_range_aligned<T>(slice: &[T], alignment: usize) -> bool
pub fn numrs2::memory_optimize::alignment::realign_vec<T: core::marker::Copy>(vec: alloc::vec::Vec<T>, new_alignment: usize) -> alloc::vec::Vec<T>
pub mod numrs2::memory_optimize::cache_layout
pub enum numrs2::memory_optimize::cache_layout::LayoutStrategy
pub numrs2::memory_optimize::cache_layout::LayoutStrategy::Blocked(usize)
pub numrs2::memory_optimize::cache_layout::LayoutStrategy::CacheOblivious
pub numrs2::memory_optimize::cache_layout::LayoutStrategy::ColumnMajor
pub numrs2::memory_optimize::cache_layout::LayoutStrategy::Hilbert
pub numrs2::memory_optimize::cache_layout::LayoutStrategy::Morton
pub numrs2::memory_optimize::cache_layout::LayoutStrategy::RowMajor
pub fn numrs2::memory_optimize::cache_layout::calculate_optimal_block_size<T>() -> usize
pub fn numrs2::memory_optimize::cache_layout::optimize_layout<T: core::marker::Copy>(data: &mut [T], strategy: numrs2::memory_optimize::cache_layout::LayoutStrategy)
pub mod numrs2::memory_optimize::memory_placement
pub enum numrs2::memory_optimize::memory_placement::PlacementStrategy
pub numrs2::memory_optimize::memory_placement::PlacementStrategy::Aligned(usize)
pub numrs2::memory_optimize::memory_placement::PlacementStrategy::CacheAware
pub numrs2::memory_optimize::memory_placement::PlacementStrategy::Default
pub numrs2::memory_optimize::memory_placement::PlacementStrategy::NumaAware
pub numrs2::memory_optimize::memory_placement::PlacementStrategy::Packed
pub fn numrs2::memory_optimize::memory_placement::get_optimal_simd_width<T>() -> usize
pub fn numrs2::memory_optimize::memory_placement::optimal_alignment<T>() -> usize
pub fn numrs2::memory_optimize::memory_placement::optimize_placement<T: core::marker::Copy>(data: &mut [T], strategy: numrs2::memory_optimize::memory_placement::PlacementStrategy)
pub enum numrs2::memory_optimize::AccessPattern
pub numrs2::memory_optimize::AccessPattern::Blocked
pub numrs2::memory_optimize::AccessPattern::Random
pub numrs2::memory_optimize::AccessPattern::Reverse
pub numrs2::memory_optimize::AccessPattern::Sequential
pub numrs2::memory_optimize::AccessPattern::Strided(usize)
impl numrs2::memory_optimize::access_patterns::AccessPattern
pub fn numrs2::memory_optimize::access_patterns::AccessPattern::benefits_from_prefetch(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::AccessPattern::prefetch_distance(&self) -> usize
pub enum numrs2::memory_optimize::AlignmentStrategy
pub numrs2::memory_optimize::AlignmentStrategy::CacheLine
pub numrs2::memory_optimize::AlignmentStrategy::Custom(usize)
pub numrs2::memory_optimize::AlignmentStrategy::Default
pub numrs2::memory_optimize::AlignmentStrategy::Simd
pub enum numrs2::memory_optimize::CacheLevel
pub numrs2::memory_optimize::CacheLevel::L1
pub numrs2::memory_optimize::CacheLevel::L2
pub numrs2::memory_optimize::CacheLevel::L3
pub enum numrs2::memory_optimize::LayoutStrategy
pub numrs2::memory_optimize::LayoutStrategy::Blocked(usize)
pub numrs2::memory_optimize::LayoutStrategy::CacheOblivious
pub numrs2::memory_optimize::LayoutStrategy::ColumnMajor
pub numrs2::memory_optimize::LayoutStrategy::Hilbert
pub numrs2::memory_optimize::LayoutStrategy::Morton
pub numrs2::memory_optimize::LayoutStrategy::RowMajor
pub enum numrs2::memory_optimize::MemoryLayout
pub numrs2::memory_optimize::MemoryLayout::CContiguous
pub numrs2::memory_optimize::MemoryLayout::FContiguous
pub numrs2::memory_optimize::MemoryLayout::Scalar
pub numrs2::memory_optimize::MemoryLayout::Strided
impl numrs2::memory_optimize::access_patterns::MemoryLayout
pub fn numrs2::memory_optimize::access_patterns::MemoryLayout::is_c_optimal(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::MemoryLayout::is_contiguous(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::MemoryLayout::is_f_optimal(&self) -> bool
pub enum numrs2::memory_optimize::PlacementStrategy
pub numrs2::memory_optimize::PlacementStrategy::Aligned(usize)
pub numrs2::memory_optimize::PlacementStrategy::CacheAware
pub numrs2::memory_optimize::PlacementStrategy::Default
pub numrs2::memory_optimize::PlacementStrategy::NumaAware
pub numrs2::memory_optimize::PlacementStrategy::Packed
pub struct numrs2::memory_optimize::AccessStats
pub numrs2::memory_optimize::AccessStats::estimated_miss_rate: f64
pub numrs2::memory_optimize::AccessStats::random_accesses: u64
pub numrs2::memory_optimize::AccessStats::sequential_accesses: u64
pub numrs2::memory_optimize::AccessStats::strided_accesses: u64
pub numrs2::memory_optimize::AccessStats::total_accesses: u64
impl numrs2::memory_optimize::access_patterns::AccessStats
pub fn numrs2::memory_optimize::access_patterns::AccessStats::cache_efficiency(&self) -> f64
pub fn numrs2::memory_optimize::access_patterns::AccessStats::new() -> Self
pub fn numrs2::memory_optimize::access_patterns::AccessStats::record_random(&mut self)
pub fn numrs2::memory_optimize::access_patterns::AccessStats::record_sequential(&mut self)
pub fn numrs2::memory_optimize::access_patterns::AccessStats::record_strided(&mut self)
pub fn numrs2::memory_optimize::access_patterns::AccessStats::update_miss_rate(&mut self)
pub struct numrs2::memory_optimize::Block
pub numrs2::memory_optimize::Block::end: usize
pub numrs2::memory_optimize::Block::start: usize
impl numrs2::memory_optimize::access_patterns::Block
pub fn numrs2::memory_optimize::access_patterns::Block::is_empty(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::Block::iter(&self) -> core::ops::range::Range<usize>
pub fn numrs2::memory_optimize::access_patterns::Block::len(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::Block::new(start: usize, end: usize) -> Self
pub struct numrs2::memory_optimize::BlockedIterator
impl numrs2::memory_optimize::access_patterns::BlockedIterator
pub fn numrs2::memory_optimize::access_patterns::BlockedIterator::for_type<T>(total: usize, cache: numrs2::memory_optimize::access_patterns::CacheConfig) -> Self
pub fn numrs2::memory_optimize::access_patterns::BlockedIterator::new(total: usize, block_size: usize) -> Self
impl core::iter::traits::exact_size::ExactSizeIterator for numrs2::memory_optimize::access_patterns::BlockedIterator
impl core::iter::traits::iterator::Iterator for numrs2::memory_optimize::access_patterns::BlockedIterator
pub type numrs2::memory_optimize::access_patterns::BlockedIterator::Item = numrs2::memory_optimize::access_patterns::Block
pub fn numrs2::memory_optimize::access_patterns::BlockedIterator::next(&mut self) -> core::option::Option<Self::Item>
pub fn numrs2::memory_optimize::access_patterns::BlockedIterator::size_hint(&self) -> (usize, core::option::Option<usize>)
pub struct numrs2::memory_optimize::CacheConfig
pub numrs2::memory_optimize::CacheConfig::associativity: usize
pub numrs2::memory_optimize::CacheConfig::level: numrs2::memory_optimize::access_patterns::CacheLevel
pub numrs2::memory_optimize::CacheConfig::line_size: usize
pub numrs2::memory_optimize::CacheConfig::size_bytes: usize
impl numrs2::memory_optimize::access_patterns::CacheConfig
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::elements_per_block<T>(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::elements_per_line<T>(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::l1_default() -> Self
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::l2_default() -> Self
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::l3_default() -> Self
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::new(level: numrs2::memory_optimize::access_patterns::CacheLevel, size_bytes: usize, line_size: usize, associativity: usize) -> Self
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::tile_size_2d<T>(&self) -> (usize, usize)
impl core::default::Default for numrs2::memory_optimize::access_patterns::CacheConfig
pub fn numrs2::memory_optimize::access_patterns::CacheConfig::default() -> Self
pub struct numrs2::memory_optimize::OptimizationHints
pub numrs2::memory_optimize::OptimizationHints::access_pattern: numrs2::memory_optimize::access_patterns::AccessPattern
pub numrs2::memory_optimize::OptimizationHints::block_size: usize
pub numrs2::memory_optimize::OptimizationHints::cache_efficiency: f64
pub numrs2::memory_optimize::OptimizationHints::layout: numrs2::memory_optimize::access_patterns::MemoryLayout
pub numrs2::memory_optimize::OptimizationHints::tile_size: core::option::Option<(usize, usize)>
pub numrs2::memory_optimize::OptimizationHints::use_parallel: bool
impl numrs2::memory_optimize::access_patterns::OptimizationHints
pub fn numrs2::memory_optimize::access_patterns::OptimizationHints::analyze<T>(shape: &[usize], strides: &[usize]) -> Self
pub fn numrs2::memory_optimize::access_patterns::OptimizationHints::default_for<T>(total_elements: usize) -> Self
impl core::default::Default for numrs2::memory_optimize::access_patterns::OptimizationHints
pub fn numrs2::memory_optimize::access_patterns::OptimizationHints::default() -> Self
pub struct numrs2::memory_optimize::StrideOptimizer
impl numrs2::memory_optimize::access_patterns::StrideOptimizer
pub fn numrs2::memory_optimize::access_patterns::StrideOptimizer::bandwidth_efficiency(&self) -> f64
pub fn numrs2::memory_optimize::access_patterns::StrideOptimizer::new(shape: &[usize], strides: &[usize]) -> Self
pub fn numrs2::memory_optimize::access_patterns::StrideOptimizer::optimal_iteration_order(&self) -> &[usize]
pub fn numrs2::memory_optimize::access_patterns::StrideOptimizer::should_copy(&self) -> bool
pub struct numrs2::memory_optimize::Tile2D
pub numrs2::memory_optimize::Tile2D::col_end: usize
pub numrs2::memory_optimize::Tile2D::col_start: usize
pub numrs2::memory_optimize::Tile2D::row_end: usize
pub numrs2::memory_optimize::Tile2D::row_start: usize
impl numrs2::memory_optimize::access_patterns::Tile2D
pub fn numrs2::memory_optimize::access_patterns::Tile2D::cols(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::Tile2D::is_empty(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::Tile2D::len(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::Tile2D::new(row_start: usize, row_end: usize, col_start: usize, col_end: usize) -> Self
pub fn numrs2::memory_optimize::access_patterns::Tile2D::rows(&self) -> usize
pub struct numrs2::memory_optimize::TiledIterator2D
impl numrs2::memory_optimize::access_patterns::TiledIterator2D
pub fn numrs2::memory_optimize::access_patterns::TiledIterator2D::for_type<T>(total_rows: usize, total_cols: usize, cache: numrs2::memory_optimize::access_patterns::CacheConfig) -> Self
pub fn numrs2::memory_optimize::access_patterns::TiledIterator2D::new(total_rows: usize, total_cols: usize, tile_rows: usize, tile_cols: usize) -> Self
impl core::iter::traits::exact_size::ExactSizeIterator for numrs2::memory_optimize::access_patterns::TiledIterator2D
impl core::iter::traits::iterator::Iterator for numrs2::memory_optimize::access_patterns::TiledIterator2D
pub type numrs2::memory_optimize::access_patterns::TiledIterator2D::Item = numrs2::memory_optimize::access_patterns::Tile2D
pub fn numrs2::memory_optimize::access_patterns::TiledIterator2D::next(&mut self) -> core::option::Option<Self::Item>
pub fn numrs2::memory_optimize::access_patterns::TiledIterator2D::size_hint(&self) -> (usize, core::option::Option<usize>)
pub fn numrs2::memory_optimize::align_data<T: core::marker::Copy>(data: &mut [T], strategy: numrs2::memory_optimize::alignment::AlignmentStrategy)
pub fn numrs2::memory_optimize::cache_aware_binary_op<T, U, V, F>(a: &[T], b: &[U], result: &mut [V], f: F) where T: core::marker::Copy, U: core::marker::Copy, F: core::ops::function::Fn(T, U) -> V
pub fn numrs2::memory_optimize::cache_aware_copy<T: core::marker::Copy>(src: &[T], dst: &mut [T])
pub fn numrs2::memory_optimize::cache_aware_transform<T, U, F>(src: &[T], dst: &mut [U], f: F) where T: core::marker::Copy, F: core::ops::function::Fn(T) -> U
pub fn numrs2::memory_optimize::detect_layout(shape: &[usize], strides: &[usize]) -> numrs2::memory_optimize::access_patterns::MemoryLayout
pub fn numrs2::memory_optimize::optimize_layout<T: core::marker::Copy>(data: &mut [T], strategy: numrs2::memory_optimize::cache_layout::LayoutStrategy)
pub fn numrs2::memory_optimize::optimize_memory<T: core::marker::Copy>(data: &mut [T], layout: numrs2::memory_optimize::cache_layout::LayoutStrategy, placement: numrs2::memory_optimize::memory_placement::PlacementStrategy)
pub fn numrs2::memory_optimize::optimize_placement<T: core::marker::Copy>(data: &mut [T], strategy: numrs2::memory_optimize::memory_placement::PlacementStrategy)
pub mod numrs2::mmap
pub enum numrs2::mmap::AccessPatternType
pub numrs2::mmap::AccessPatternType::Blocked
pub numrs2::mmap::AccessPatternType::Random
pub numrs2::mmap::AccessPatternType::Sequential
pub numrs2::mmap::AccessPatternType::Strided
pub numrs2::mmap::AccessPatternType::Unknown
pub enum numrs2::mmap::PrefetchStrategy
pub numrs2::mmap::PrefetchStrategy::Adaptive
pub numrs2::mmap::PrefetchStrategy::None
pub numrs2::mmap::PrefetchStrategy::Random
pub numrs2::mmap::PrefetchStrategy::Sequential
pub struct numrs2::mmap::MmapArray<T: core::marker::Copy>
impl<T: core::marker::Copy> numrs2::mmap::MmapArray<T>
pub fn numrs2::mmap::MmapArray<T>::access_stats(&self) -> core::option::Option<(numrs2::mmap::AccessPatternType, usize)>
pub fn numrs2::mmap::MmapArray<T>::config(&self) -> &numrs2::mmap::MmapConfig
pub fn numrs2::mmap::MmapArray<T>::flush(&mut self) -> numrs2::Result<()>
pub fn numrs2::mmap::MmapArray<T>::from_array<P: core::convert::AsRef<std::path::Path>>(array: &numrs2::array::Array<T>, path: &P) -> numrs2::Result<Self>
pub fn numrs2::mmap::MmapArray<T>::get(&self, indices: &[usize]) -> numrs2::Result<T>
pub fn numrs2::mmap::MmapArray<T>::ndim(&self) -> usize
pub fn numrs2::mmap::MmapArray<T>::new<P: core::convert::AsRef<std::path::Path>>(path: &P, shape: &[usize], create: bool) -> numrs2::Result<Self>
pub fn numrs2::mmap::MmapArray<T>::path(&self) -> &std::path::Path
pub fn numrs2::mmap::MmapArray<T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::mmap::MmapArray<T>::shape(&self) -> &[usize]
pub fn numrs2::mmap::MmapArray<T>::size(&self) -> usize
pub fn numrs2::mmap::MmapArray<T>::to_array(&self) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::mmap::MmapArray<T>::update_config(&mut self, config: numrs2::mmap::MmapConfig)
impl<T: core::marker::Copy + core::fmt::Debug> core::fmt::Display for numrs2::mmap::MmapArray<T>
pub fn numrs2::mmap::MmapArray<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::mmap::MmapArrayMeta
pub numrs2::mmap::MmapArrayMeta::checksum: core::option::Option<u64>
pub numrs2::mmap::MmapArrayMeta::config: core::option::Option<numrs2::mmap::MmapConfig>
pub numrs2::mmap::MmapArrayMeta::created_at: u64
pub numrs2::mmap::MmapArrayMeta::modified_at: u64
pub numrs2::mmap::MmapArrayMeta::shape: alloc::vec::Vec<usize>
pub numrs2::mmap::MmapArrayMeta::size: usize
pub numrs2::mmap::MmapArrayMeta::type_name: alloc::string::String
pub numrs2::mmap::MmapArrayMeta::type_size: usize
pub numrs2::mmap::MmapArrayMeta::version: u8
pub struct numrs2::mmap::MmapConfig
pub numrs2::mmap::MmapConfig::alignment: usize
pub numrs2::mmap::MmapConfig::layout_strategy: numrs2::memory_optimize::cache_layout::LayoutStrategy
pub numrs2::mmap::MmapConfig::page_size_hint: core::option::Option<usize>
pub numrs2::mmap::MmapConfig::prefetch: numrs2::mmap::PrefetchStrategy
pub numrs2::mmap::MmapConfig::write_back: bool
impl core::default::Default for numrs2::mmap::MmapConfig
pub fn numrs2::mmap::MmapConfig::default() -> Self
pub fn numrs2::mmap::open_mmap_info<P: core::convert::AsRef<std::path::Path>>(path: &P) -> numrs2::Result<numrs2::mmap::MmapArrayMeta>
pub mod numrs2::ndimage
pub use numrs2::ndimage::<<scirs2_ndimage::*>>
pub mod numrs2::new_modules
pub mod numrs2::new_modules::eigenvalues
pub type numrs2::new_modules::eigenvalues::EigResult<T> = (numrs2::array::Array<num_complex::Complex<T>>, numrs2::array::Array<num_complex::Complex<T>>)
pub mod numrs2::new_modules::fft
pub struct numrs2::new_modules::fft::FFT
impl numrs2::signal::FFT
pub fn numrs2::signal::FFT::apply_window<T>(x: &numrs2::array::Array<T>, window_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub fn numrs2::signal::FFT::fft<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::fft2<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::fftfreq<T>(n: usize, d: T) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub fn numrs2::signal::FFT::fftshift<T: core::clone::Clone>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::signal::FFT::ifft<T>(x: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::ifft2<T>(x: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::ifftshift<T: core::clone::Clone>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::signal::FFT::irfft<T>(x: &numrs2::array::Array<num_complex::Complex<T>>, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::irfft2<T>(x: &numrs2::array::Array<num_complex::Complex<T>>, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::power_spectrum<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::rfft<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::rfft2<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::rfftfreq<T>(n: usize, d: T) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub mod numrs2::new_modules::fft_enhanced
pub struct numrs2::new_modules::fft_enhanced::FFTEnhanced
impl numrs2::signal::enhanced::FFTEnhanced
pub fn numrs2::signal::enhanced::FFTEnhanced::apply_window<T>(x: &numrs2::array::Array<T>, window_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub fn numrs2::signal::enhanced::FFTEnhanced::fft_any_size<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::enhanced::FFTEnhanced::ifft_any_size<T>(x: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::enhanced::FFTEnhanced::real_fft_optimized<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::enhanced::FFTEnhanced::stockwell_transform<T>(x: &numrs2::array::Array<T>, min_freq: core::option::Option<usize>, max_freq: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::enhanced::FFTEnhanced::window<T>(window_type: &str, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub fn numrs2::signal::enhanced::FFTEnhanced::window_energy_concentration<T>(window_types: &[&str], n: usize) -> numrs2::Result<alloc::vec::Vec<(alloc::string::String, T)>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64> + core::convert::Into<f64>
pub mod numrs2::new_modules::frequency_analysis
pub enum numrs2::new_modules::frequency_analysis::PSDScaling
pub numrs2::new_modules::frequency_analysis::PSDScaling::Density
pub numrs2::new_modules::frequency_analysis::PSDScaling::Spectrum
pub struct numrs2::new_modules::frequency_analysis::CoherenceResult<T: core::clone::Clone>
pub numrs2::new_modules::frequency_analysis::CoherenceResult::coherence: numrs2::array::Array<T>
pub numrs2::new_modules::frequency_analysis::CoherenceResult::frequencies: numrs2::array::Array<T>
pub struct numrs2::new_modules::frequency_analysis::CrossSpectralResult<T: core::clone::Clone>
pub numrs2::new_modules::frequency_analysis::CrossSpectralResult::cross_psd: numrs2::array::Array<num_complex::Complex<T>>
pub numrs2::new_modules::frequency_analysis::CrossSpectralResult::frequencies: numrs2::array::Array<T>
pub struct numrs2::new_modules::frequency_analysis::FrequencyAnalyzer
impl numrs2::new_modules::frequency_analysis::FrequencyAnalyzer
pub fn numrs2::new_modules::frequency_analysis::FrequencyAnalyzer::coherence<T>(signal1: &numrs2::array::Array<T>, signal2: &numrs2::array::Array<T>, nperseg: core::option::Option<usize>, noverlap: core::option::Option<usize>, window: &str, nfft: core::option::Option<usize>) -> numrs2::Result<numrs2::new_modules::frequency_analysis::CoherenceResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::frequency_analysis::FrequencyAnalyzer::cross_spectral_density<T>(signal1: &numrs2::array::Array<T>, signal2: &numrs2::array::Array<T>, nperseg: core::option::Option<usize>, noverlap: core::option::Option<usize>, window: &str, nfft: core::option::Option<usize>) -> numrs2::Result<numrs2::new_modules::frequency_analysis::CrossSpectralResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::frequency_analysis::FrequencyAnalyzer::generate_window_function<T>(n: usize, window_type: &str) -> numrs2::Result<alloc::vec::Vec<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub fn numrs2::new_modules::frequency_analysis::FrequencyAnalyzer::multitaper<T>(signal: &numrs2::array::Array<T>, bandwidth: T, n_tapers: usize) -> numrs2::Result<numrs2::new_modules::frequency_analysis::MultitaperResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::frequency_analysis::FrequencyAnalyzer::periodogram<T>(signal: &numrs2::array::Array<T>, window: core::option::Option<&str>, scaling: numrs2::new_modules::frequency_analysis::PSDScaling) -> numrs2::Result<numrs2::new_modules::frequency_analysis::PeriodogramResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::frequency_analysis::FrequencyAnalyzer::welch<T>(signal: &numrs2::array::Array<T>, nperseg: core::option::Option<usize>, noverlap: core::option::Option<usize>, window: &str, nfft: core::option::Option<usize>, detrend: bool, scaling: numrs2::new_modules::frequency_analysis::PSDScaling) -> numrs2::Result<numrs2::new_modules::frequency_analysis::WelchResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub struct numrs2::new_modules::frequency_analysis::MultitaperResult<T: core::clone::Clone>
pub numrs2::new_modules::frequency_analysis::MultitaperResult::eigenvalues: numrs2::array::Array<T>
pub numrs2::new_modules::frequency_analysis::MultitaperResult::frequencies: numrs2::array::Array<T>
pub numrs2::new_modules::frequency_analysis::MultitaperResult::psd: numrs2::array::Array<T>
pub struct numrs2::new_modules::frequency_analysis::PeriodogramResult<T: core::clone::Clone>
pub numrs2::new_modules::frequency_analysis::PeriodogramResult::frequencies: numrs2::array::Array<T>
pub numrs2::new_modules::frequency_analysis::PeriodogramResult::psd: numrs2::array::Array<T>
pub struct numrs2::new_modules::frequency_analysis::WelchResult<T: core::clone::Clone>
pub numrs2::new_modules::frequency_analysis::WelchResult::frequencies: numrs2::array::Array<T>
pub numrs2::new_modules::frequency_analysis::WelchResult::psd: numrs2::array::Array<T>
pub mod numrs2::new_modules::matrix_decomp
pub mod numrs2::new_modules::matrix_decomp::utils
pub mod numrs2::new_modules::polynomial
pub struct numrs2::new_modules::polynomial::CubicSpline<T>
impl<T> numrs2::math_extended::CubicSpline<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialOrd + core::fmt::Debug + num_traits::float::Float
pub fn numrs2::math_extended::CubicSpline<T>::evaluate(&self, x: T) -> numrs2::Result<T>
pub fn numrs2::math_extended::CubicSpline<T>::evaluate_array(&self, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math_extended::CubicSpline<T>::new(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub struct numrs2::new_modules::polynomial::OrthogonalPolynomials
impl numrs2::math_extended::OrthogonalPolynomials
pub fn numrs2::math_extended::OrthogonalPolynomials::chebyshev_t<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::OrthogonalPolynomials::chebyshev_u<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::OrthogonalPolynomials::hermite<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::OrthogonalPolynomials::laguerre<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::OrthogonalPolynomials::legendre<T>(n: usize) -> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub struct numrs2::new_modules::polynomial::Polynomial<T>
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::math_extended::Polynomial<T>::coefficients(&self) -> &[T]
pub fn numrs2::math_extended::Polynomial<T>::degree(&self) -> usize
pub fn numrs2::math_extended::Polynomial<T>::new(coefficients: alloc::vec::Vec<T>) -> Self
pub fn numrs2::math_extended::Polynomial<T>::to_array(&self) -> numrs2::array::Array<T>
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::Polynomial<T>::evaluate(&self, x: T) -> T
pub fn numrs2::math_extended::Polynomial<T>::evaluate_array(&self, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math_extended::Polynomial<T>::monomial(degree: usize) -> Self
pub fn numrs2::math_extended::Polynomial<T>::one() -> Self
pub fn numrs2::math_extended::Polynomial<T>::zero() -> Self
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::Polynomial<T>::definite_integral(&self, a: T, b: T) -> T
pub fn numrs2::math_extended::Polynomial<T>::derivative(&self) -> Self
pub fn numrs2::math_extended::Polynomial<T>::integral(&self) -> Self
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::Polynomial<T>::divide(&self, divisor: &Self) -> numrs2::Result<(Self, Self)>
impl<T> core::ops::arith::Add for numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::cmp::PartialEq
pub type numrs2::math_extended::Polynomial<T>::Output = numrs2::math_extended::Polynomial<T>
pub fn numrs2::math_extended::Polynomial<T>::add(self, other: numrs2::math_extended::Polynomial<T>) -> numrs2::math_extended::Polynomial<T>
impl<T> core::ops::arith::Mul for numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub type numrs2::math_extended::Polynomial<T>::Output = numrs2::math_extended::Polynomial<T>
pub fn numrs2::math_extended::Polynomial<T>::mul(self, other: numrs2::math_extended::Polynomial<T>) -> numrs2::math_extended::Polynomial<T>
impl<T> core::ops::arith::Sub for numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Sub<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub type numrs2::math_extended::Polynomial<T>::Output = numrs2::math_extended::Polynomial<T>
pub fn numrs2::math_extended::Polynomial<T>::sub(self, other: numrs2::math_extended::Polynomial<T>) -> numrs2::math_extended::Polynomial<T>
pub struct numrs2::new_modules::polynomial::PolynomialInterpolation
impl numrs2::math_extended::PolynomialInterpolation
pub fn numrs2::math_extended::PolynomialInterpolation::lagrange<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::PolynomialInterpolation::newton<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T>
pub fn numrs2::new_modules::polynomial::poly<T>(roots: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::new_modules::polynomial::polyadd<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::cmp::PartialEq
pub fn numrs2::new_modules::polynomial::polychebyshev<T>(degree: usize, kind: u8) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::new_modules::polynomial::polycompanion<T>(c: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Neg<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq
pub fn numrs2::new_modules::polynomial::polycompose<T>(p: &numrs2::array::Array<T>, q: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::new_modules::polynomial::polyder<T>(c: &numrs2::array::Array<T>, m: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::new_modules::polynomial::polydiv<T>(u: &numrs2::array::Array<T>, v: &numrs2::array::Array<T>) -> numrs2::Result<(numrs2::math_extended::Polynomial<T>, numrs2::math_extended::Polynomial<T>)> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq
pub fn numrs2::new_modules::polynomial::polyextrap<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, new_x: &numrs2::array::Array<T>, degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::new_modules::polynomial::polyfit<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, degree: usize) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::new_modules::polynomial::polyfit_weighted<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, degree: usize, weights: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::new_modules::polynomial::polyfromroots<T>(roots: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::new_modules::polynomial::polygcd<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + num_traits::float::Float
pub fn numrs2::new_modules::polynomial::polygrid2d<T>(c: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::new_modules::polynomial::polyhermite<T>(degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::new_modules::polynomial::polyint<T>(c: &numrs2::array::Array<T>, m: usize, k: core::option::Option<&[T]>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::new_modules::polynomial::polyjacobi<T>(degree: usize, alpha: T, beta: T) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::new_modules::polynomial::polylaguerre<T>(degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::new_modules::polynomial::polylegendre<T>(degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::new_modules::polynomial::polymul<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::new_modules::polynomial::polymulx<T>(c: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::new_modules::polynomial::polypower<T>(c: &numrs2::array::Array<T>, pow: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::new_modules::polynomial::polyresidual<T>(c: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::new_modules::polynomial::polyscale<T>(c: &numrs2::array::Array<T>, domain: &numrs2::array::Array<T>, window: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + num_traits::float::Float
pub fn numrs2::new_modules::polynomial::polysub<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Sub<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::new_modules::polynomial::polytrim<T>(c: &numrs2::array::Array<T>, tol: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialOrd + num_traits::float::Float
pub fn numrs2::new_modules::polynomial::polyval<T>(p: &numrs2::math_extended::Polynomial<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::new_modules::polynomial::polyval2d<T>(c: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::new_modules::polynomial::polyvander<T>(x: &numrs2::array::Array<T>, deg: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Mul<Output = T>
pub fn numrs2::new_modules::polynomial::polyvander2d<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, deg: (usize, usize)) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Mul<Output = T>
pub fn numrs2::new_modules::polynomial::roots<T>(p: &numrs2::math_extended::Polynomial<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub mod numrs2::new_modules::signal_processing
pub enum numrs2::new_modules::signal_processing::FilterType
pub numrs2::new_modules::signal_processing::FilterType::BandPass
pub numrs2::new_modules::signal_processing::FilterType::BandStop
pub numrs2::new_modules::signal_processing::FilterType::Butterworth
pub numrs2::new_modules::signal_processing::FilterType::Chebyshev
pub numrs2::new_modules::signal_processing::FilterType::HighPass
pub numrs2::new_modules::signal_processing::FilterType::LowPass
pub enum numrs2::new_modules::signal_processing::WaveletType
pub numrs2::new_modules::signal_processing::WaveletType::Gaussian
pub numrs2::new_modules::signal_processing::WaveletType::Mexican
pub numrs2::new_modules::signal_processing::WaveletType::Morlet
pub struct numrs2::new_modules::signal_processing::FilterParams<T>
pub numrs2::new_modules::signal_processing::FilterParams::cutoff: T
pub numrs2::new_modules::signal_processing::FilterParams::high_cutoff: T
pub numrs2::new_modules::signal_processing::FilterParams::low_cutoff: T
pub numrs2::new_modules::signal_processing::FilterParams::order: core::option::Option<i32>
pub numrs2::new_modules::signal_processing::FilterParams::ripple: core::option::Option<T>
pub numrs2::new_modules::signal_processing::FilterParams::sample_rate: T
impl<T: core::clone::Clone> numrs2::new_modules::signal_processing::FilterParams<T>
pub fn numrs2::new_modules::signal_processing::FilterParams<T>::bandpass(low_cutoff: T, high_cutoff: T, sample_rate: T) -> Self
pub fn numrs2::new_modules::signal_processing::FilterParams<T>::new(cutoff: T, sample_rate: T) -> Self
pub struct numrs2::new_modules::signal_processing::InstantaneousAttributes<T: core::clone::Clone>
pub numrs2::new_modules::signal_processing::InstantaneousAttributes::amplitude: numrs2::array::Array<T>
pub numrs2::new_modules::signal_processing::InstantaneousAttributes::frequency: numrs2::array::Array<T>
pub numrs2::new_modules::signal_processing::InstantaneousAttributes::phase: numrs2::array::Array<T>
pub struct numrs2::new_modules::signal_processing::SignalProcessor
impl numrs2::new_modules::signal_processing::SignalProcessor
pub fn numrs2::new_modules::signal_processing::SignalProcessor::autocorrelate<T>(signal: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::signal_processing::SignalProcessor::convolve<T>(signal1: &numrs2::array::Array<T>, signal2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::signal_processing::SignalProcessor::correlate<T>(signal1: &numrs2::array::Array<T>, signal2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::signal_processing::SignalProcessor::cwt<T>(signal: &numrs2::array::Array<T>, scales: &[T], wavelet_type: numrs2::new_modules::signal_processing::WaveletType) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::signal_processing::SignalProcessor::detrend<T>(signal: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::signal_processing::SignalProcessor::filter<T>(signal: &numrs2::array::Array<T>, filter_type: numrs2::new_modules::signal_processing::FilterType, params: numrs2::new_modules::signal_processing::FilterParams<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::signal_processing::SignalProcessor::hilbert<T>(signal: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::signal_processing::SignalProcessor::instantaneous_attributes<T>(signal: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::new_modules::signal_processing::InstantaneousAttributes<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::signal_processing::SignalProcessor::resample<T>(signal: &numrs2::array::Array<T>, new_length: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::new_modules::signal_processing::SignalProcessor::spectrogram<T>(signal: &numrs2::array::Array<T>, window_size: usize, overlap: usize, window_type: &str) -> numrs2::Result<numrs2::new_modules::signal_processing::SpectrogramResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub struct numrs2::new_modules::signal_processing::SpectrogramResult<T: core::clone::Clone>
pub numrs2::new_modules::signal_processing::SpectrogramResult::freq_axis: numrs2::array::Array<T>
pub numrs2::new_modules::signal_processing::SpectrogramResult::spectrogram: numrs2::array::Array<T>
pub numrs2::new_modules::signal_processing::SpectrogramResult::time_axis: numrs2::array::Array<T>
pub mod numrs2::new_modules::sparse
pub enum numrs2::new_modules::sparse::SparseMatrixFormat
pub numrs2::new_modules::sparse::SparseMatrixFormat::COO
pub numrs2::new_modules::sparse::SparseMatrixFormat::CSC
pub numrs2::new_modules::sparse::SparseMatrixFormat::CSR
pub numrs2::new_modules::sparse::SparseMatrixFormat::DIA
pub struct numrs2::new_modules::sparse::SparseArray<T>
pub numrs2::new_modules::sparse::SparseArray::data: std::collections::hash::map::HashMap<alloc::vec::Vec<usize>, T>
pub numrs2::new_modules::sparse::SparseArray::shape: alloc::vec::Vec<usize>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Add<Output = T>
pub fn numrs2::sparse::SparseArray<T>::add(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Div<Output = T>
pub fn numrs2::sparse::SparseArray<T>::divide(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
pub fn numrs2::sparse::SparseArray<T>::divide_scalar(&self, scalar: T) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Mul<Output = T>
pub fn numrs2::sparse::SparseArray<T>::multiply(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
pub fn numrs2::sparse::SparseArray<T>::multiply_scalar(&self, scalar: T) -> numrs2::sparse::SparseArray<T>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Sub<Output = T>
pub fn numrs2::sparse::SparseArray<T>::subtract(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero
pub fn numrs2::sparse::SparseArray<T>::density(&self) -> f64
pub fn numrs2::sparse::SparseArray<T>::from_array(array: &numrs2::array::Array<T>) -> Self
pub fn numrs2::sparse::SparseArray<T>::get(&self, indices: &[usize]) -> numrs2::Result<T>
pub fn numrs2::sparse::SparseArray<T>::ndim(&self) -> usize
pub fn numrs2::sparse::SparseArray<T>::new(shape: &[usize]) -> Self
pub fn numrs2::sparse::SparseArray<T>::nnz(&self) -> usize
pub fn numrs2::sparse::SparseArray<T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseArray<T>::shape(&self) -> &[usize]
pub fn numrs2::sparse::SparseArray<T>::to_array(&self) -> numrs2::array::Array<T>
pub struct numrs2::new_modules::sparse::SparseMatrix<T>
pub numrs2::new_modules::sparse::SparseMatrix::array: numrs2::sparse::SparseArray<T>
pub numrs2::new_modules::sparse::SparseMatrix::diag_offsets: core::option::Option<alloc::vec::Vec<isize>>
pub numrs2::new_modules::sparse::SparseMatrix::format: numrs2::sparse::SparseMatrixFormat
pub numrs2::new_modules::sparse::SparseMatrix::indices: core::option::Option<alloc::vec::Vec<usize>>
pub numrs2::new_modules::sparse::SparseMatrix::indptr: core::option::Option<alloc::vec::Vec<usize>>
impl<T> numrs2::sparse::SparseMatrix<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::fmt::Debug
pub fn numrs2::sparse::SparseMatrix<T>::density(&self) -> f64
pub fn numrs2::sparse::SparseMatrix<T>::diag(diagonal: &[T]) -> numrs2::Result<Self>
pub fn numrs2::sparse::SparseMatrix<T>::eye(n: usize) -> numrs2::Result<Self> where T: num_traits::identities::One
pub fn numrs2::sparse::SparseMatrix<T>::from_array(array: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub fn numrs2::sparse::SparseMatrix<T>::get(&self, row: usize, col: usize) -> numrs2::Result<T>
pub fn numrs2::sparse::SparseMatrix<T>::new(shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::sparse::SparseMatrix<T>::nnz(&self) -> usize
pub fn numrs2::sparse::SparseMatrix<T>::set(&mut self, row: usize, col: usize, value: T) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseMatrix<T>::shape(&self) -> &[usize]
pub fn numrs2::sparse::SparseMatrix<T>::to_array(&self) -> numrs2::array::Array<T>
pub fn numrs2::sparse::SparseMatrix<T>::to_csc(&mut self) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseMatrix<T>::to_csr(&mut self) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseMatrix<T>::to_dia(&mut self) -> numrs2::Result<()>
impl<T> numrs2::sparse::SparseMatrix<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::fmt::Debug
pub fn numrs2::sparse::SparseMatrix<T>::matmul(&self, other: &numrs2::sparse::SparseMatrix<T>) -> numrs2::Result<numrs2::sparse::SparseMatrix<T>>
pub fn numrs2::sparse::SparseMatrix<T>::transpose(&self) -> numrs2::Result<numrs2::sparse::SparseMatrix<T>>
pub mod numrs2::new_modules::special
pub fn numrs2::new_modules::special::airy_ai<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::airy_bi<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::associated_legendre_p<T>(l: i32, m: i32, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::bessel_i<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::bessel_j<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::bessel_k<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::bessel_y<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::beta<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::betainc<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::digamma<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::ellipe<T>(m: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::ellipeinc<T>(phi: &numrs2::array::Array<T>, m: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::ellipf<T>(phi: &numrs2::array::Array<T>, m: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::ellipk<T>(m: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::erf<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::erfc<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::erfcinv<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::erfinv<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::exp1<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::expi<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::fresnel<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::gamma<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::gammainc<T>(a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::gammaln<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::jacobi_elliptic<T>(u: &numrs2::array::Array<T>, m: T) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::lambertw<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::lambertwm1<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::legendre_p<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::polylog<T>(s: T, z: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::shichi<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::sici<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::spherical_harmonic<T>(l: i32, m: i32, theta: &numrs2::array::Array<T>, phi: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::struve_h<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::new_modules::special::zeta<T>(s: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub mod numrs2::new_modules::spectral_analysis
pub struct numrs2::new_modules::spectral_analysis::HarmonicResult<T: core::clone::Clone>
pub numrs2::new_modules::spectral_analysis::HarmonicResult::fundamental_frequency: T
pub numrs2::new_modules::spectral_analysis::HarmonicResult::harmonic_amplitudes: numrs2::array::Array<T>
pub numrs2::new_modules::spectral_analysis::HarmonicResult::harmonics: numrs2::array::Array<T>
pub numrs2::new_modules::spectral_analysis::HarmonicResult::total_harmonic_distortion: T
pub struct numrs2::new_modules::spectral_analysis::PeakResult<T: core::clone::Clone>
pub numrs2::new_modules::spectral_analysis::PeakResult::peak_frequencies: numrs2::array::Array<T>
pub numrs2::new_modules::spectral_analysis::PeakResult::peak_heights: numrs2::array::Array<T>
pub numrs2::new_modules::spectral_analysis::PeakResult::peak_indices: numrs2::array::Array<f64>
pub numrs2::new_modules::spectral_analysis::PeakResult::peak_prominences: numrs2::array::Array<T>
pub numrs2::new_modules::spectral_analysis::PeakResult::peak_widths: numrs2::array::Array<T>
pub struct numrs2::new_modules::spectral_analysis::STFTResult<T: core::clone::Clone>
pub numrs2::new_modules::spectral_analysis::STFTResult::freq_axis: numrs2::array::Array<T>
pub numrs2::new_modules::spectral_analysis::STFTResult::stft: numrs2::array::Array<num_complex::Complex<T>>
pub numrs2::new_modules::spectral_analysis::STFTResult::time_axis: numrs2::array::Array<T>
pub struct numrs2::new_modules::spectral_analysis::SpectralAnalyzer
impl numrs2::new_modules::spectral_analysis::SpectralAnalyzer
pub fn numrs2::new_modules::spectral_analysis::SpectralAnalyzer::find_peaks<T>(spectrum: &numrs2::array::Array<T>, frequencies: &numrs2::array::Array<T>, height: core::option::Option<T>, distance: core::option::Option<usize>, prominence: core::option::Option<T>, width: core::option::Option<T>) -> numrs2::Result<numrs2::new_modules::spectral_analysis::PeakResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64> + core::iter::traits::accum::Sum
pub fn numrs2::new_modules::spectral_analysis::SpectralAnalyzer::harmonic_analysis<T>(spectrum: &numrs2::array::Array<T>, frequencies: &numrs2::array::Array<T>, max_harmonics: usize, tolerance: T) -> numrs2::Result<numrs2::new_modules::spectral_analysis::HarmonicResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64> + core::iter::traits::accum::Sum
pub fn numrs2::new_modules::spectral_analysis::SpectralAnalyzer::instantaneous_frequency<T>(complex_signal: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64> + core::iter::traits::accum::Sum
pub fn numrs2::new_modules::spectral_analysis::SpectralAnalyzer::mfcc<T>(spectrum: &numrs2::array::Array<T>, sample_rate: T, n_mfcc: usize, n_mels: usize, fmin: T, fmax: T) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64> + core::iter::traits::accum::Sum
pub fn numrs2::new_modules::spectral_analysis::SpectralAnalyzer::spectral_bandwidth<T>(spectrum: &numrs2::array::Array<T>, frequencies: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::iter::traits::accum::Sum
pub fn numrs2::new_modules::spectral_analysis::SpectralAnalyzer::spectral_centroid<T>(spectrum: &numrs2::array::Array<T>, frequencies: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::iter::traits::accum::Sum
pub fn numrs2::new_modules::spectral_analysis::SpectralAnalyzer::spectral_flatness<T>(spectrum: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64> + core::iter::traits::accum::Sum
pub fn numrs2::new_modules::spectral_analysis::SpectralAnalyzer::spectral_rolloff<T>(spectrum: &numrs2::array::Array<T>, frequencies: &numrs2::array::Array<T>, percentage: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::iter::traits::accum::Sum
pub fn numrs2::new_modules::spectral_analysis::SpectralAnalyzer::stft<T>(signal: &numrs2::array::Array<T>, window_size: usize, hop_size: usize, window_type: &str, zero_pad: bool) -> numrs2::Result<numrs2::new_modules::spectral_analysis::STFTResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64> + core::iter::traits::accum::Sum
pub mod numrs2::ode
pub enum numrs2::ode::OdeMethod
pub numrs2::ode::OdeMethod::BDF2
pub numrs2::ode::OdeMethod::DoPri5
pub numrs2::ode::OdeMethod::Euler
pub numrs2::ode::OdeMethod::ImplicitEuler
pub numrs2::ode::OdeMethod::RK4
pub numrs2::ode::OdeMethod::RK45
pub struct numrs2::ode::OdeConfig<T>
pub numrs2::ode::OdeConfig::atol: T
pub numrs2::ode::OdeConfig::h0: T
pub numrs2::ode::OdeConfig::h_max: T
pub numrs2::ode::OdeConfig::h_min: T
pub numrs2::ode::OdeConfig::max_steps: usize
pub numrs2::ode::OdeConfig::rtol: T
pub numrs2::ode::OdeConfig::t_eval: core::option::Option<alloc::vec::Vec<T>>
impl<T: num_traits::float::Float> core::default::Default for numrs2::ode::OdeConfig<T>
pub fn numrs2::ode::OdeConfig<T>::default() -> Self
pub struct numrs2::ode::OdeResult<T>
pub numrs2::ode::OdeResult::message: alloc::string::String
pub numrs2::ode::OdeResult::nfev: usize
pub numrs2::ode::OdeResult::nsteps: usize
pub numrs2::ode::OdeResult::success: bool
pub numrs2::ode::OdeResult::t: alloc::vec::Vec<T>
pub numrs2::ode::OdeResult::y: alloc::vec::Vec<alloc::vec::Vec<T>>
pub fn numrs2::ode::odeint<T, F>(f: F, t_span: (T, T), y0: T) -> numrs2::Result<numrs2::ode::OdeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::ode::solve_ivp<T, F>(f: F, t_span: (T, T), y0: &[T], method: numrs2::ode::OdeMethod) -> numrs2::Result<numrs2::ode::OdeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(T, &[T]) -> alloc::vec::Vec<T>
pub fn numrs2::ode::solve_ivp_with_config<T, F>(f: F, t_span: (T, T), y0: &[T], method: numrs2::ode::OdeMethod, config: &numrs2::ode::OdeConfig<T>) -> numrs2::Result<numrs2::ode::OdeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(T, &[T]) -> alloc::vec::Vec<T>
pub mod numrs2::optimize
pub struct numrs2::optimize::BoxConstraints<T>
pub numrs2::optimize::BoxConstraints::lower: alloc::vec::Vec<core::option::Option<T>>
pub numrs2::optimize::BoxConstraints::upper: alloc::vec::Vec<core::option::Option<T>>
impl<T: num_traits::float::Float> numrs2::optimize::BoxConstraints<T>
pub fn numrs2::optimize::BoxConstraints<T>::is_feasible(&self, x: &[T]) -> bool
pub fn numrs2::optimize::BoxConstraints<T>::project(&self, x: &[T]) -> alloc::vec::Vec<T>
pub fn numrs2::optimize::BoxConstraints<T>::uniform(n: usize, lower: core::option::Option<T>, upper: core::option::Option<T>) -> Self
pub struct numrs2::optimize::OptimizeConfig<T: num_traits::float::Float>
pub numrs2::optimize::OptimizeConfig::c1: T
pub numrs2::optimize::OptimizeConfig::c2: T
pub numrs2::optimize::OptimizeConfig::ftol: T
pub numrs2::optimize::OptimizeConfig::gtol: T
pub numrs2::optimize::OptimizeConfig::ls_max_iter: usize
pub numrs2::optimize::OptimizeConfig::max_iter: usize
pub numrs2::optimize::OptimizeConfig::xtol: T
impl<T: num_traits::float::Float> core::default::Default for numrs2::optimize::OptimizeConfig<T>
pub fn numrs2::optimize::OptimizeConfig<T>::default() -> Self
pub struct numrs2::optimize::OptimizeResult<T: num_traits::float::Float>
pub numrs2::optimize::OptimizeResult::fun: T
pub numrs2::optimize::OptimizeResult::grad: alloc::vec::Vec<T>
pub numrs2::optimize::OptimizeResult::message: alloc::string::String
pub numrs2::optimize::OptimizeResult::nfev: usize
pub numrs2::optimize::OptimizeResult::nit: usize
pub numrs2::optimize::OptimizeResult::njev: usize
pub numrs2::optimize::OptimizeResult::success: bool
pub numrs2::optimize::OptimizeResult::x: alloc::vec::Vec<T>
pub fn numrs2::optimize::bfgs<T, F, G>(f: F, grad: G, x0: &[T], config: core::option::Option<numrs2::optimize::OptimizeConfig<T>>) -> numrs2::Result<numrs2::optimize::OptimizeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(&[T]) -> T, G: core::ops::function::Fn(&[T]) -> alloc::vec::Vec<T>
pub fn numrs2::optimize::check_gradient<T, F, G>(f: &F, grad: &G, x: &[T], tol: T) -> bool where T: num_traits::float::Float + core::iter::traits::accum::Sum, F: core::ops::function::Fn(&[T]) -> T, G: core::ops::function::Fn(&[T]) -> alloc::vec::Vec<T>
pub fn numrs2::optimize::lbfgs<T, F, G>(f: F, grad: G, x0: &[T], m: usize, config: core::option::Option<numrs2::optimize::OptimizeConfig<T>>) -> numrs2::Result<numrs2::optimize::OptimizeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(&[T]) -> T, G: core::ops::function::Fn(&[T]) -> alloc::vec::Vec<T>
pub fn numrs2::optimize::levenberg_marquardt<T, R>(residual: R, x0: &[T], config: core::option::Option<numrs2::optimize::OptimizeConfig<T>>) -> numrs2::Result<numrs2::optimize::OptimizeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, R: core::ops::function::Fn(&[T]) -> alloc::vec::Vec<T>
pub fn numrs2::optimize::nelder_mead<T, F>(f: F, x0: &[T], config: core::option::Option<numrs2::optimize::OptimizeConfig<T>>) -> numrs2::Result<numrs2::optimize::OptimizeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(&[T]) -> T
pub fn numrs2::optimize::penalty_method<T, F, G>(f: F, grad: G, equality_constraints: &[&dyn core::ops::function::Fn(&[T]) -> T], inequality_constraints: &[&dyn core::ops::function::Fn(&[T]) -> T], x0: &[T], initial_penalty: T, penalty_increase: T, config: core::option::Option<numrs2::optimize::OptimizeConfig<T>>) -> numrs2::Result<numrs2::optimize::OptimizeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(&[T]) -> T, G: core::ops::function::Fn(&[T]) -> alloc::vec::Vec<T>
pub fn numrs2::optimize::projected_gradient<T, F, G>(f: F, grad: G, x0: &[T], constraints: &numrs2::optimize::BoxConstraints<T>, config: core::option::Option<numrs2::optimize::OptimizeConfig<T>>) -> numrs2::Result<numrs2::optimize::OptimizeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(&[T]) -> T, G: core::ops::function::Fn(&[T]) -> alloc::vec::Vec<T>
pub fn numrs2::optimize::trust_region<T, F, G, H>(f: F, grad: G, hess: H, x0: &[T], config: core::option::Option<numrs2::optimize::OptimizeConfig<T>>) -> numrs2::Result<numrs2::optimize::OptimizeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum, F: core::ops::function::Fn(&[T]) -> T, G: core::ops::function::Fn(&[T]) -> alloc::vec::Vec<T>, H: core::ops::function::Fn(&[T]) -> alloc::vec::Vec<alloc::vec::Vec<T>>
pub mod numrs2::optimized_ops
pub mod numrs2::optimized_ops::avx512
pub struct numrs2::optimized_ops::avx512::Avx512MatrixOps
impl numrs2::optimized_ops::avx512::Avx512MatrixOps
pub fn numrs2::optimized_ops::avx512::Avx512MatrixOps::transpose_8x8_block(input: &[f64; 64], output: &mut [f64; 64])
pub struct numrs2::optimized_ops::avx512::Avx512Ops
impl numrs2::optimized_ops::avx512::Avx512Ops
pub fn numrs2::optimized_ops::avx512::Avx512Ops::convert_f64_to_f32(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f32>
pub fn numrs2::optimized_ops::avx512::Avx512Ops::gather(data: &ndarray::aliases::ArrayView1<'_, f64>, indices: &ndarray::aliases::ArrayView1<'_, usize>) -> numrs2::Result<ndarray::aliases::Array1<f64>>
pub fn numrs2::optimized_ops::avx512::Avx512Ops::histogram(data: &ndarray::aliases::ArrayView1<'_, f64>, bins: usize, min_val: f64, max_val: f64) -> numrs2::Result<ndarray::aliases::Array1<usize>>
pub fn numrs2::optimized_ops::avx512::Avx512Ops::is_available() -> bool
pub fn numrs2::optimized_ops::avx512::Avx512Ops::masked_add(a: &ndarray::aliases::ArrayView1<'_, f64>, b: &ndarray::aliases::ArrayView1<'_, f64>, mask: &ndarray::aliases::ArrayView1<'_, bool>) -> numrs2::Result<ndarray::aliases::Array1<f64>>
pub fn numrs2::optimized_ops::avx512::Avx512Ops::masked_sum(data: &ndarray::aliases::ArrayView1<'_, f64>, mask: &ndarray::aliases::ArrayView1<'_, bool>) -> numrs2::Result<f64>
pub fn numrs2::optimized_ops::avx512::Avx512Ops::scatter(values: &ndarray::aliases::ArrayView1<'_, f64>, indices: &ndarray::aliases::ArrayView1<'_, usize>, output_size: usize) -> numrs2::Result<ndarray::aliases::Array1<f64>>
pub mod numrs2::optimized_ops::enhanced_exp
pub fn numrs2::optimized_ops::enhanced_exp::parallel_cbrt(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_exp::parallel_exp(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_exp::parallel_exp2(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_exp::parallel_expm1(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_exp::parallel_ln(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_exp::parallel_ln1p(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_exp::parallel_log10(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_exp::parallel_log2(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_exp::parallel_pow(base: &ndarray::aliases::ArrayView1<'_, f64>, exp: &ndarray::aliases::ArrayView1<'_, f64>) -> numrs2::Result<ndarray::aliases::Array1<f64>>
pub fn numrs2::optimized_ops::enhanced_exp::simd_sqrt(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub mod numrs2::optimized_ops::enhanced_math
pub fn numrs2::optimized_ops::enhanced_math::parallel_acos(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_math::parallel_asin(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_math::parallel_atan(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_math::parallel_atan2(y: &ndarray::aliases::ArrayView1<'_, f64>, x: &ndarray::aliases::ArrayView1<'_, f64>) -> numrs2::Result<ndarray::aliases::Array1<f64>>
pub fn numrs2::optimized_ops::enhanced_math::parallel_cos(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_math::parallel_cosh(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_math::parallel_sin(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_math::parallel_sincos(data: &ndarray::aliases::ArrayView1<'_, f64>) -> (ndarray::aliases::Array1<f64>, ndarray::aliases::Array1<f64>)
pub fn numrs2::optimized_ops::enhanced_math::parallel_sinh(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_math::parallel_tan(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::enhanced_math::parallel_tanh(data: &ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>
pub mod numrs2::optimized_ops::simd_complex
pub struct numrs2::optimized_ops::simd_complex::SimdComplexOps
impl numrs2::optimized_ops::simd_complex::SimdComplexOps
pub fn numrs2::optimized_ops::simd_complex::SimdComplexOps::complex_conjugate(a: &ndarray::aliases::ArrayView1<'_, num_complex::Complex<f64>>) -> ndarray::aliases::Array1<num_complex::Complex<f64>>
pub fn numrs2::optimized_ops::simd_complex::SimdComplexOps::complex_exp(a: &ndarray::aliases::ArrayView1<'_, num_complex::Complex<f64>>) -> ndarray::aliases::Array1<num_complex::Complex<f64>>
pub fn numrs2::optimized_ops::simd_complex::SimdComplexOps::complex_magnitude(a: &ndarray::aliases::ArrayView1<'_, num_complex::Complex<f64>>) -> ndarray::aliases::Array1<f64>
pub fn numrs2::optimized_ops::simd_complex::SimdComplexOps::complex_multiply(a: &ndarray::aliases::ArrayView1<'_, num_complex::Complex<f64>>, b: &ndarray::aliases::ArrayView1<'_, num_complex::Complex<f64>>) -> numrs2::Result<ndarray::aliases::Array1<num_complex::Complex<f64>>>
pub fn numrs2::optimized_ops::simd_complex::SimdComplexOps::complex_phase(a: &ndarray::aliases::ArrayView1<'_, num_complex::Complex<f64>>) -> ndarray::aliases::Array1<f64>
pub struct numrs2::optimized_ops::simd_complex::SimdConvolution
impl numrs2::optimized_ops::simd_complex::SimdConvolution
pub fn numrs2::optimized_ops::simd_complex::SimdConvolution::convolve(signal: &ndarray::aliases::ArrayView1<'_, f64>, kernel: &ndarray::aliases::ArrayView1<'_, f64>) -> numrs2::Result<ndarray::aliases::Array1<f64>>
pub struct numrs2::optimized_ops::simd_complex::SimdFft
impl numrs2::optimized_ops::simd_complex::SimdFft
pub fn numrs2::optimized_ops::simd_complex::SimdFft::fft(input: &ndarray::aliases::ArrayView1<'_, num_complex::Complex<f64>>) -> numrs2::Result<ndarray::aliases::Array1<num_complex::Complex<f64>>>
pub fn numrs2::optimized_ops::simd_complex::SimdFft::fft2d(input: &ndarray::aliases::ArrayView2<'_, num_complex::Complex<f64>>) -> numrs2::Result<ndarray::aliases::Array2<num_complex::Complex<f64>>>
pub fn numrs2::optimized_ops::simd_complex::SimdFft::ifft(input: &ndarray::aliases::ArrayView1<'_, num_complex::Complex<f64>>) -> numrs2::Result<ndarray::aliases::Array1<num_complex::Complex<f64>>>
pub struct numrs2::optimized_ops::ColumnStats
pub numrs2::optimized_ops::ColumnStats::max: f64
pub numrs2::optimized_ops::ColumnStats::mean: f64
pub numrs2::optimized_ops::ColumnStats::min: f64
pub numrs2::optimized_ops::ColumnStats::sum: f64
pub struct numrs2::optimized_ops::SimdMathOps
impl numrs2::optimized_ops::SimdMathOps
pub fn numrs2::optimized_ops::SimdMathOps::adaptive_math_function<F, G>(data: &ndarray::aliases::ArrayView1<'_, f64>, simd_fn: F, scalar_fn: G) -> ndarray::aliases::Array1<f64> where F: core::ops::function::Fn(&ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64>, G: core::ops::function::Fn(f64) -> f64
pub fn numrs2::optimized_ops::SimdMathOps::apply_chunked<F>(data: &ndarray::aliases::ArrayView1<'_, f64>, chunk_size: usize, simd_fn: F) -> ndarray::aliases::Array1<f64> where F: core::ops::function::Fn(&ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<f64> + core::marker::Send + core::marker::Sync
pub struct numrs2::optimized_ops::SimdOpsResult
pub numrs2::optimized_ops::SimdOpsResult::add: numrs2::array::Array<f64>
pub numrs2::optimized_ops::SimdOpsResult::div: numrs2::array::Array<f64>
pub numrs2::optimized_ops::SimdOpsResult::mul: numrs2::array::Array<f64>
pub numrs2::optimized_ops::SimdOpsResult::sub: numrs2::array::Array<f64>
pub struct numrs2::optimized_ops::SimdVectorResult
pub numrs2::optimized_ops::SimdVectorResult::max: f32
pub numrs2::optimized_ops::SimdVectorResult::mean: f32
pub numrs2::optimized_ops::SimdVectorResult::min: f32
pub numrs2::optimized_ops::SimdVectorResult::norm: f32
pub numrs2::optimized_ops::SimdVectorResult::sum: f32
pub fn numrs2::optimized_ops::adaptive_array_sum(data: &ndarray::aliases::ArrayView1<'_, f64>) -> f64
pub fn numrs2::optimized_ops::chunked_array_processing<F, R>(data: &ndarray::aliases::ArrayView1<'_, f64>, chunk_size: usize, processor: F) -> alloc::vec::Vec<R> where F: core::ops::function::Fn(&[f64]) -> R + core::marker::Send + core::marker::Sync, R: core::marker::Send
pub fn numrs2::optimized_ops::get_optimization_info() -> alloc::string::String
pub fn numrs2::optimized_ops::parallel_column_statistics(data: &ndarray::aliases::ArrayView2<'_, f64>) -> alloc::vec::Vec<numrs2::optimized_ops::ColumnStats>
pub fn numrs2::optimized_ops::process_large_array<F, T>(data: &ndarray::aliases::ArrayView1<'_, f64>, chunk_size: usize, processor: F) -> numrs2::Result<ndarray::aliases::Array1<T>> where F: core::ops::function::Fn(&ndarray::aliases::ArrayView1<'_, f64>) -> ndarray::aliases::Array1<T> + core::marker::Send + core::marker::Sync, T: core::clone::Clone + core::marker::Send + core::default::Default + ndarray::linalg_traits::LinalgScalar
pub fn numrs2::optimized_ops::should_use_parallel(data_size: usize) -> bool
pub fn numrs2::optimized_ops::simd_elementwise_ops(a: &ndarray::aliases::ArrayView1<'_, f64>, b: &ndarray::aliases::ArrayView1<'_, f64>) -> numrs2::Result<numrs2::optimized_ops::SimdOpsResult>
pub fn numrs2::optimized_ops::simd_matmul(a: &ndarray::aliases::ArrayView2<'_, f32>, b: &ndarray::aliases::ArrayView2<'_, f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::optimized_ops::simd_vector_ops(v: &ndarray::aliases::ArrayView1<'_, f32>) -> numrs2::optimized_ops::SimdVectorResult
pub mod numrs2::parallel
pub mod numrs2::parallel::load_balancer
pub enum numrs2::parallel::load_balancer::BalancingStrategy
pub numrs2::parallel::load_balancer::BalancingStrategy::Adaptive
pub numrs2::parallel::load_balancer::BalancingStrategy::LeastLoaded
pub numrs2::parallel::load_balancer::BalancingStrategy::NumaAware
pub numrs2::parallel::load_balancer::BalancingStrategy::RoundRobin
pub numrs2::parallel::load_balancer::BalancingStrategy::WeightedCapacity
pub numrs2::parallel::load_balancer::BalancingStrategy::WorkStealing
pub struct numrs2::parallel::load_balancer::LoadBalancer
impl numrs2::parallel::load_balancer::LoadBalancer
pub fn numrs2::parallel::load_balancer::LoadBalancer::current_metrics(&self) -> numrs2::parallel::load_balancer::WorkloadMetrics
pub fn numrs2::parallel::load_balancer::LoadBalancer::current_strategy(&self) -> numrs2::parallel::load_balancer::BalancingStrategy
pub fn numrs2::parallel::load_balancer::LoadBalancer::new(strategy: numrs2::parallel::load_balancer::BalancingStrategy, num_workers: usize) -> numrs2::Result<Self>
pub fn numrs2::parallel::load_balancer::LoadBalancer::num_workers(&self) -> usize
pub fn numrs2::parallel::load_balancer::LoadBalancer::select_worker(&self) -> numrs2::Result<usize>
pub fn numrs2::parallel::load_balancer::LoadBalancer::set_strategy(&self, new_strategy: numrs2::parallel::load_balancer::BalancingStrategy)
pub fn numrs2::parallel::load_balancer::LoadBalancer::update_worker_metrics(&self, worker_id: usize, queue_length: usize, cpu_utilization: f64, memory_usage: f64) -> numrs2::Result<()>
pub struct numrs2::parallel::load_balancer::LoadBalancingAdvisor
impl numrs2::parallel::load_balancer::LoadBalancingAdvisor
pub fn numrs2::parallel::load_balancer::LoadBalancingAdvisor::analyze_trends(&self) -> numrs2::parallel::load_balancer::LoadBalancingAnalysis
pub fn numrs2::parallel::load_balancer::LoadBalancingAdvisor::new() -> Self
pub fn numrs2::parallel::load_balancer::LoadBalancingAdvisor::recommend_strategy(&self) -> numrs2::parallel::load_balancer::BalancingStrategy
pub fn numrs2::parallel::load_balancer::LoadBalancingAdvisor::record_metrics(&mut self, metrics: numrs2::parallel::load_balancer::WorkloadMetrics)
impl core::default::Default for numrs2::parallel::load_balancer::LoadBalancingAdvisor
pub fn numrs2::parallel::load_balancer::LoadBalancingAdvisor::default() -> Self
pub struct numrs2::parallel::load_balancer::LoadBalancingAnalysis
pub numrs2::parallel::load_balancer::LoadBalancingAnalysis::imbalance_trend: f64
pub numrs2::parallel::load_balancer::LoadBalancingAnalysis::recommendation: numrs2::parallel::load_balancer::BalancingStrategy
pub numrs2::parallel::load_balancer::LoadBalancingAnalysis::response_time_trend: f64
pub numrs2::parallel::load_balancer::LoadBalancingAnalysis::stability_score: f64
pub numrs2::parallel::load_balancer::LoadBalancingAnalysis::throughput_trend: f64
pub struct numrs2::parallel::load_balancer::WorkloadMetrics
pub numrs2::parallel::load_balancer::WorkloadMetrics::active_tasks: u64
pub numrs2::parallel::load_balancer::WorkloadMetrics::avg_response_time: core::time::Duration
pub numrs2::parallel::load_balancer::WorkloadMetrics::cache_miss_rate: f64
pub numrs2::parallel::load_balancer::WorkloadMetrics::cpu_utilization: alloc::vec::Vec<f64>
pub numrs2::parallel::load_balancer::WorkloadMetrics::load_imbalance: f64
pub numrs2::parallel::load_balancer::WorkloadMetrics::memory_usage: alloc::vec::Vec<f64>
pub numrs2::parallel::load_balancer::WorkloadMetrics::queue_lengths: alloc::vec::Vec<usize>
pub numrs2::parallel::load_balancer::WorkloadMetrics::total_throughput: f64
pub numrs2::parallel::load_balancer::WorkloadMetrics::work_steals: u64
impl numrs2::parallel::load_balancer::WorkloadMetrics
pub fn numrs2::parallel::load_balancer::WorkloadMetrics::is_balanced(&self, threshold: f64) -> bool
pub fn numrs2::parallel::load_balancer::WorkloadMetrics::least_loaded_worker(&self) -> core::option::Option<usize>
pub fn numrs2::parallel::load_balancer::WorkloadMetrics::load_distribution_cv(&self) -> f64
pub fn numrs2::parallel::load_balancer::WorkloadMetrics::most_loaded_worker(&self) -> core::option::Option<usize>
pub mod numrs2::parallel::parallel_algorithms
pub struct numrs2::parallel::parallel_algorithms::ParallelArrayOps
impl numrs2::parallel::parallel_algorithms::ParallelArrayOps
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::new(config: numrs2::parallel::parallel_algorithms::ParallelConfig) -> numrs2::Result<Self>
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::parallel_binary_op<T, F>(&self, a: &[T], b: &[T], result: &mut [T], op: F) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T + core::marker::Send + core::marker::Sync + core::marker::Copy + 'static
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::parallel_prefix_sum<T>(&self, data: &[T], result: &mut [T]) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy + core::ops::arith::Add<Output = T>
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::parallel_reduce<T, F>(&self, data: &[T], init: T, op: F) -> numrs2::Result<T> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T + core::marker::Send + core::marker::Sync + core::marker::Copy + 'static
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::parallel_sort<T>(&self, data: &mut [T]) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::cmp::Ord + core::marker::Copy
pub struct numrs2::parallel::parallel_algorithms::ParallelConfig
pub numrs2::parallel::parallel_algorithms::ParallelConfig::block_size: usize
pub numrs2::parallel::parallel_algorithms::ParallelConfig::chunk_size: usize
pub numrs2::parallel::parallel_algorithms::ParallelConfig::num_threads: core::option::Option<usize>
pub numrs2::parallel::parallel_algorithms::ParallelConfig::numa_aware: bool
pub numrs2::parallel::parallel_algorithms::ParallelConfig::parallel_threshold: usize
impl core::default::Default for numrs2::parallel::parallel_algorithms::ParallelConfig
pub fn numrs2::parallel::parallel_algorithms::ParallelConfig::default() -> Self
pub struct numrs2::parallel::parallel_algorithms::ParallelFFT<T>
impl<T: numrs2::traits::FloatingPoint + core::marker::Send + core::marker::Sync + core::marker::Copy> numrs2::parallel::parallel_algorithms::ParallelFFT<T>
pub fn numrs2::parallel::parallel_algorithms::ParallelFFT<T>::new(config: numrs2::parallel::parallel_algorithms::ParallelConfig) -> numrs2::Result<Self>
pub fn numrs2::parallel::parallel_algorithms::ParallelFFT<T>::parallel_fft(&self, data: &mut [num_complex::Complex<T>]) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_algorithms::ParallelFFT<T>::parallel_ifft(&self, data: &mut [num_complex::Complex<T>]) -> numrs2::Result<()>
pub struct numrs2::parallel::parallel_algorithms::ParallelMatrixOps
impl numrs2::parallel::parallel_algorithms::ParallelMatrixOps
pub fn numrs2::parallel::parallel_algorithms::ParallelMatrixOps::new(config: numrs2::parallel::parallel_algorithms::ParallelConfig) -> numrs2::Result<Self>
pub fn numrs2::parallel::parallel_algorithms::ParallelMatrixOps::parallel_matmul<T>(&self, a: &[T], b: &[T], c: &mut [T], m: usize, n: usize, k: usize) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::parallel::parallel_algorithms::ParallelMatrixOps::parallel_transpose<T>(&self, src: &[T], dst: &mut [T], rows: usize, cols: usize) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy
pub mod numrs2::parallel::parallel_allocator
pub struct numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone
impl<A> numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::aggregate_statistics(&self) -> numrs2::traits::AllocationStats
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::force_cleanup(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::garbage_collect_all(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::new(base_allocator: A, config: numrs2::parallel::parallel_allocator::ParallelAllocatorConfig) -> Self
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::total_cached_blocks(&self) -> usize
impl<A> core::fmt::Debug for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A> numrs2::traits::MemoryAllocator for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub type numrs2::parallel::parallel_allocator::ParallelAllocator<A>::Error = numrs2::NumRs2Error
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl<A> numrs2::traits::SpecializedAllocator for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::parallel::parallel_allocator::ParallelAllocatorConfig
pub numrs2::parallel::parallel_allocator::ParallelAllocatorConfig::enable_thread_local_cache: bool
pub numrs2::parallel::parallel_allocator::ParallelAllocatorConfig::enable_tracking: bool
pub numrs2::parallel::parallel_allocator::ParallelAllocatorConfig::gc_interval: core::time::Duration
pub numrs2::parallel::parallel_allocator::ParallelAllocatorConfig::global_pool_size: usize
pub numrs2::parallel::parallel_allocator::ParallelAllocatorConfig::max_block_age: core::time::Duration
pub numrs2::parallel::parallel_allocator::ParallelAllocatorConfig::max_cached_blocks_per_thread: usize
pub numrs2::parallel::parallel_allocator::ParallelAllocatorConfig::numa_aware: bool
impl core::default::Default for numrs2::parallel::parallel_allocator::ParallelAllocatorConfig
pub fn numrs2::parallel::parallel_allocator::ParallelAllocatorConfig::default() -> Self
pub struct numrs2::parallel::parallel_allocator::ThreadLocalAllocator
impl numrs2::parallel::parallel_allocator::ThreadLocalAllocator
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::current_thread_statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub unsafe fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::garbage_collect_current_thread(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::initialize_current_thread<A>(&self, allocator: A) -> numrs2::Result<()> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + 'static
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::new(config: numrs2::parallel::parallel_allocator::ParallelAllocatorConfig) -> Self
pub mod numrs2::parallel::scheduler
pub enum numrs2::parallel::scheduler::TaskPriority
pub numrs2::parallel::scheduler::TaskPriority::Critical = 3
pub numrs2::parallel::scheduler::TaskPriority::High = 2
pub numrs2::parallel::scheduler::TaskPriority::Low = 0
pub numrs2::parallel::scheduler::TaskPriority::Normal = 1
pub enum numrs2::parallel::scheduler::TaskResult
pub numrs2::parallel::scheduler::TaskResult::Cancelled
pub numrs2::parallel::scheduler::TaskResult::Error(alloc::string::String)
pub numrs2::parallel::scheduler::TaskResult::Success
pub struct numrs2::parallel::scheduler::ParallelScheduler
impl numrs2::parallel::scheduler::ParallelScheduler
pub fn numrs2::parallel::scheduler::ParallelScheduler::new(config: numrs2::parallel::scheduler::SchedulerConfig) -> numrs2::Result<Self>
pub fn numrs2::parallel::scheduler::ParallelScheduler::num_threads(&self) -> usize
pub fn numrs2::parallel::scheduler::ParallelScheduler::queue_length(&self) -> usize
pub fn numrs2::parallel::scheduler::ParallelScheduler::shutdown(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::scheduler::ParallelScheduler::statistics(&self) -> numrs2::parallel::scheduler::SchedulerStats
pub fn numrs2::parallel::scheduler::ParallelScheduler::submit_task<F>(&self, task: F, priority: numrs2::parallel::scheduler::TaskPriority, estimated_duration: core::option::Option<core::time::Duration>, thread_affinity: core::option::Option<usize>) -> numrs2::Result<u64> where F: core::ops::function::FnOnce() -> numrs2::parallel::scheduler::TaskResult + core::marker::Send + 'static
pub fn numrs2::parallel::scheduler::ParallelScheduler::submit_urgent_task<F>(&self, task: F) -> numrs2::Result<u64> where F: core::ops::function::FnOnce() -> numrs2::parallel::scheduler::TaskResult + core::marker::Send + 'static
pub struct numrs2::parallel::scheduler::ScheduledTask
pub numrs2::parallel::scheduler::ScheduledTask::estimated_duration: core::option::Option<core::time::Duration>
pub numrs2::parallel::scheduler::ScheduledTask::id: u64
pub numrs2::parallel::scheduler::ScheduledTask::priority: numrs2::parallel::scheduler::TaskPriority
pub numrs2::parallel::scheduler::ScheduledTask::submitted_at: std::time::Instant
pub numrs2::parallel::scheduler::ScheduledTask::task: alloc::boxed::Box<(dyn core::ops::function::FnOnce() -> numrs2::parallel::scheduler::TaskResult + core::marker::Send + 'static)>
pub numrs2::parallel::scheduler::ScheduledTask::thread_affinity: core::option::Option<usize>
impl core::cmp::Eq for numrs2::parallel::scheduler::ScheduledTask
impl core::cmp::Ord for numrs2::parallel::scheduler::ScheduledTask
pub fn numrs2::parallel::scheduler::ScheduledTask::cmp(&self, other: &Self) -> core::cmp::Ordering
impl core::cmp::PartialEq for numrs2::parallel::scheduler::ScheduledTask
pub fn numrs2::parallel::scheduler::ScheduledTask::eq(&self, other: &Self) -> bool
impl core::cmp::PartialOrd for numrs2::parallel::scheduler::ScheduledTask
pub fn numrs2::parallel::scheduler::ScheduledTask::partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering>
impl core::fmt::Debug for numrs2::parallel::scheduler::ScheduledTask
pub fn numrs2::parallel::scheduler::ScheduledTask::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::parallel::scheduler::SchedulerConfig
pub numrs2::parallel::scheduler::SchedulerConfig::cache_aware_scheduling: bool
pub numrs2::parallel::scheduler::SchedulerConfig::enable_adaptive_scheduling: bool
pub numrs2::parallel::scheduler::SchedulerConfig::enable_thread_affinity: bool
pub numrs2::parallel::scheduler::SchedulerConfig::max_queue_size: usize
pub numrs2::parallel::scheduler::SchedulerConfig::num_threads: usize
pub numrs2::parallel::scheduler::SchedulerConfig::time_slice_ms: u64
pub numrs2::parallel::scheduler::SchedulerConfig::work_stealing_threshold: usize
impl numrs2::parallel::scheduler::SchedulerConfig
pub fn numrs2::parallel::scheduler::SchedulerConfig::latency_optimized(num_cores: usize) -> Self
pub fn numrs2::parallel::scheduler::SchedulerConfig::optimal_for_cores(num_cores: usize) -> Self
pub fn numrs2::parallel::scheduler::SchedulerConfig::throughput_optimized(num_cores: usize) -> Self
pub struct numrs2::parallel::scheduler::SchedulerStats
pub numrs2::parallel::scheduler::SchedulerStats::average_execution_time: core::time::Duration
pub numrs2::parallel::scheduler::SchedulerStats::average_queue_time: core::time::Duration
pub numrs2::parallel::scheduler::SchedulerStats::queue_overflows: u64
pub numrs2::parallel::scheduler::SchedulerStats::tasks_completed: u64
pub numrs2::parallel::scheduler::SchedulerStats::tasks_failed: u64
pub numrs2::parallel::scheduler::SchedulerStats::tasks_submitted: u64
pub numrs2::parallel::scheduler::SchedulerStats::thread_efficiency: alloc::vec::Vec<f64>
pub numrs2::parallel::scheduler::SchedulerStats::work_steals: u64
pub mod numrs2::parallel::work_stealing
pub enum numrs2::parallel::work_stealing::TaskResult<T>
pub numrs2::parallel::work_stealing::TaskResult::Cancelled
pub numrs2::parallel::work_stealing::TaskResult::Error(alloc::string::String)
pub numrs2::parallel::work_stealing::TaskResult::Success(T)
pub struct numrs2::parallel::work_stealing::ClosureTask<F, T> where F: core::ops::function::FnOnce() -> T + core::marker::Send + 'static, T: core::marker::Send + 'static
impl<F, T> numrs2::parallel::work_stealing::ClosureTask<F, T> where F: core::ops::function::FnOnce() -> T + core::marker::Send + 'static, T: core::marker::Send + 'static
pub fn numrs2::parallel::work_stealing::ClosureTask<F, T>::new(closure: F) -> Self
impl<F> numrs2::parallel::work_stealing::Task for numrs2::parallel::work_stealing::ClosureTask<F, ()> where F: core::ops::function::FnOnce() + core::marker::Send + 'static
pub type numrs2::parallel::work_stealing::ClosureTask<F, ()>::Output = numrs2::parallel::work_stealing::TaskResult<()>
pub fn numrs2::parallel::work_stealing::ClosureTask<F, ()>::execute(self: alloc::boxed::Box<Self>) -> Self::Output
pub struct numrs2::parallel::work_stealing::PoolStats
pub numrs2::parallel::work_stealing::PoolStats::average_execution_time: core::time::Duration
pub numrs2::parallel::work_stealing::PoolStats::average_queue_time: core::time::Duration
pub numrs2::parallel::work_stealing::PoolStats::queue_imbalance: f64
pub numrs2::parallel::work_stealing::PoolStats::tasks_completed: u64
pub numrs2::parallel::work_stealing::PoolStats::tasks_stolen: u64
pub numrs2::parallel::work_stealing::PoolStats::tasks_submitted: u64
pub numrs2::parallel::work_stealing::PoolStats::total_steal_attempts: u64
pub numrs2::parallel::work_stealing::PoolStats::worker_utilization: alloc::vec::Vec<f64>
pub struct numrs2::parallel::work_stealing::WorkStealingConfig
pub numrs2::parallel::work_stealing::WorkStealingConfig::adaptive_stealing: bool
pub numrs2::parallel::work_stealing::WorkStealingConfig::enable_task_splitting: bool
pub numrs2::parallel::work_stealing::WorkStealingConfig::idle_timeout: core::time::Duration
pub numrs2::parallel::work_stealing::WorkStealingConfig::max_queue_size: usize
pub numrs2::parallel::work_stealing::WorkStealingConfig::max_steal_attempts: usize
pub numrs2::parallel::work_stealing::WorkStealingConfig::num_threads: usize
pub numrs2::parallel::work_stealing::WorkStealingConfig::steal_interval: core::time::Duration
impl core::default::Default for numrs2::parallel::work_stealing::WorkStealingConfig
pub fn numrs2::parallel::work_stealing::WorkStealingConfig::default() -> Self
pub struct numrs2::parallel::work_stealing::WorkStealingPool
impl numrs2::parallel::work_stealing::WorkStealingPool
pub fn numrs2::parallel::work_stealing::WorkStealingPool::active_workers(&self) -> usize
pub fn numrs2::parallel::work_stealing::WorkStealingPool::new(num_threads: usize) -> numrs2::Result<Self>
pub fn numrs2::parallel::work_stealing::WorkStealingPool::pending_tasks(&self) -> usize
pub fn numrs2::parallel::work_stealing::WorkStealingPool::shutdown(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::work_stealing::WorkStealingPool::statistics(&self) -> numrs2::parallel::work_stealing::PoolStats
pub fn numrs2::parallel::work_stealing::WorkStealingPool::submit<T>(&self, task: T) -> numrs2::Result<()> where T: numrs2::parallel::work_stealing::Task<Output = numrs2::parallel::work_stealing::TaskResult<()>> + 'static
pub fn numrs2::parallel::work_stealing::WorkStealingPool::submit_urgent<T>(&self, task: T) -> numrs2::Result<()> where T: numrs2::parallel::work_stealing::Task<Output = numrs2::parallel::work_stealing::TaskResult<()>> + 'static
pub fn numrs2::parallel::work_stealing::WorkStealingPool::with_config(config: numrs2::parallel::work_stealing::WorkStealingConfig) -> numrs2::Result<Self>
pub trait numrs2::parallel::work_stealing::Task: core::marker::Send + 'static
pub type numrs2::parallel::work_stealing::Task::Output: core::marker::Send + 'static
pub fn numrs2::parallel::work_stealing::Task::can_split(&self) -> bool
pub fn numrs2::parallel::work_stealing::Task::estimated_cost(&self) -> core::option::Option<u64>
pub fn numrs2::parallel::work_stealing::Task::execute(self: alloc::boxed::Box<Self>) -> Self::Output
pub fn numrs2::parallel::work_stealing::Task::split(self: alloc::boxed::Box<Self>) -> alloc::vec::Vec<alloc::boxed::Box<dyn numrs2::parallel::work_stealing::Task<Output = Self::Output>>> where Self: core::marker::Sized
impl<F> numrs2::parallel::work_stealing::Task for numrs2::parallel::work_stealing::ClosureTask<F, ()> where F: core::ops::function::FnOnce() + core::marker::Send + 'static
pub type numrs2::parallel::work_stealing::ClosureTask<F, ()>::Output = numrs2::parallel::work_stealing::TaskResult<()>
pub fn numrs2::parallel::work_stealing::ClosureTask<F, ()>::execute(self: alloc::boxed::Box<Self>) -> Self::Output
pub fn numrs2::parallel::work_stealing::task<F>(closure: F) -> numrs2::parallel::work_stealing::ClosureTask<F, ()> where F: core::ops::function::FnOnce() + core::marker::Send + 'static
pub enum numrs2::parallel::BalancingStrategy
pub numrs2::parallel::BalancingStrategy::Adaptive
pub numrs2::parallel::BalancingStrategy::LeastLoaded
pub numrs2::parallel::BalancingStrategy::NumaAware
pub numrs2::parallel::BalancingStrategy::RoundRobin
pub numrs2::parallel::BalancingStrategy::WeightedCapacity
pub numrs2::parallel::BalancingStrategy::WorkStealing
pub enum numrs2::parallel::TaskPriority
pub numrs2::parallel::TaskPriority::Critical = 3
pub numrs2::parallel::TaskPriority::High = 2
pub numrs2::parallel::TaskPriority::Low = 0
pub numrs2::parallel::TaskPriority::Normal = 1
pub enum numrs2::parallel::TaskResult<T>
pub numrs2::parallel::TaskResult::Cancelled
pub numrs2::parallel::TaskResult::Error(alloc::string::String)
pub numrs2::parallel::TaskResult::Success(T)
pub struct numrs2::parallel::LoadBalancer
impl numrs2::parallel::load_balancer::LoadBalancer
pub fn numrs2::parallel::load_balancer::LoadBalancer::current_metrics(&self) -> numrs2::parallel::load_balancer::WorkloadMetrics
pub fn numrs2::parallel::load_balancer::LoadBalancer::current_strategy(&self) -> numrs2::parallel::load_balancer::BalancingStrategy
pub fn numrs2::parallel::load_balancer::LoadBalancer::new(strategy: numrs2::parallel::load_balancer::BalancingStrategy, num_workers: usize) -> numrs2::Result<Self>
pub fn numrs2::parallel::load_balancer::LoadBalancer::num_workers(&self) -> usize
pub fn numrs2::parallel::load_balancer::LoadBalancer::select_worker(&self) -> numrs2::Result<usize>
pub fn numrs2::parallel::load_balancer::LoadBalancer::set_strategy(&self, new_strategy: numrs2::parallel::load_balancer::BalancingStrategy)
pub fn numrs2::parallel::load_balancer::LoadBalancer::update_worker_metrics(&self, worker_id: usize, queue_length: usize, cpu_utilization: f64, memory_usage: f64) -> numrs2::Result<()>
pub struct numrs2::parallel::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone
impl<A> numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::aggregate_statistics(&self) -> numrs2::traits::AllocationStats
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::force_cleanup(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::garbage_collect_all(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::new(base_allocator: A, config: numrs2::parallel::parallel_allocator::ParallelAllocatorConfig) -> Self
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::total_cached_blocks(&self) -> usize
impl<A> core::fmt::Debug for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A> numrs2::traits::MemoryAllocator for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub type numrs2::parallel::parallel_allocator::ParallelAllocator<A>::Error = numrs2::NumRs2Error
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl<A> numrs2::traits::SpecializedAllocator for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::parallel::ParallelAllocatorConfig
pub numrs2::parallel::ParallelAllocatorConfig::enable_thread_local_cache: bool
pub numrs2::parallel::ParallelAllocatorConfig::enable_tracking: bool
pub numrs2::parallel::ParallelAllocatorConfig::gc_interval: core::time::Duration
pub numrs2::parallel::ParallelAllocatorConfig::global_pool_size: usize
pub numrs2::parallel::ParallelAllocatorConfig::max_block_age: core::time::Duration
pub numrs2::parallel::ParallelAllocatorConfig::max_cached_blocks_per_thread: usize
pub numrs2::parallel::ParallelAllocatorConfig::numa_aware: bool
impl core::default::Default for numrs2::parallel::parallel_allocator::ParallelAllocatorConfig
pub fn numrs2::parallel::parallel_allocator::ParallelAllocatorConfig::default() -> Self
pub struct numrs2::parallel::ParallelArrayOps
impl numrs2::parallel::parallel_algorithms::ParallelArrayOps
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::new(config: numrs2::parallel::parallel_algorithms::ParallelConfig) -> numrs2::Result<Self>
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::parallel_binary_op<T, F>(&self, a: &[T], b: &[T], result: &mut [T], op: F) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T + core::marker::Send + core::marker::Sync + core::marker::Copy + 'static
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::parallel_prefix_sum<T>(&self, data: &[T], result: &mut [T]) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy + core::ops::arith::Add<Output = T>
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::parallel_reduce<T, F>(&self, data: &[T], init: T, op: F) -> numrs2::Result<T> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T + core::marker::Send + core::marker::Sync + core::marker::Copy + 'static
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::parallel_sort<T>(&self, data: &mut [T]) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::cmp::Ord + core::marker::Copy
pub struct numrs2::parallel::ParallelConfig
pub numrs2::parallel::ParallelConfig::block_size: usize
pub numrs2::parallel::ParallelConfig::chunk_size: usize
pub numrs2::parallel::ParallelConfig::num_threads: core::option::Option<usize>
pub numrs2::parallel::ParallelConfig::numa_aware: bool
pub numrs2::parallel::ParallelConfig::parallel_threshold: usize
impl core::default::Default for numrs2::parallel::parallel_algorithms::ParallelConfig
pub fn numrs2::parallel::parallel_algorithms::ParallelConfig::default() -> Self
pub struct numrs2::parallel::ParallelContext
impl numrs2::parallel::ParallelContext
pub fn numrs2::parallel::ParallelContext::load_balancer(&self) -> &alloc::sync::Arc<numrs2::parallel::load_balancer::LoadBalancer>
pub fn numrs2::parallel::ParallelContext::new() -> numrs2::Result<Self>
pub fn numrs2::parallel::ParallelContext::scheduler(&self) -> &alloc::sync::Arc<numrs2::parallel::scheduler::ParallelScheduler>
pub fn numrs2::parallel::ParallelContext::shutdown(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::ParallelContext::with_config(scheduler_config: numrs2::parallel::scheduler::SchedulerConfig, balancing_strategy: numrs2::parallel::load_balancer::BalancingStrategy, num_threads: usize) -> numrs2::Result<Self>
pub fn numrs2::parallel::ParallelContext::work_stealing_pool(&self) -> &alloc::sync::Arc<numrs2::parallel::work_stealing::WorkStealingPool>
pub fn numrs2::parallel::ParallelContext::workload_stats(&self) -> numrs2::parallel::load_balancer::WorkloadMetrics
impl core::default::Default for numrs2::parallel::ParallelContext
pub fn numrs2::parallel::ParallelContext::default() -> Self
pub struct numrs2::parallel::ParallelFFT<T>
impl<T: numrs2::traits::FloatingPoint + core::marker::Send + core::marker::Sync + core::marker::Copy> numrs2::parallel::parallel_algorithms::ParallelFFT<T>
pub fn numrs2::parallel::parallel_algorithms::ParallelFFT<T>::new(config: numrs2::parallel::parallel_algorithms::ParallelConfig) -> numrs2::Result<Self>
pub fn numrs2::parallel::parallel_algorithms::ParallelFFT<T>::parallel_fft(&self, data: &mut [num_complex::Complex<T>]) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_algorithms::ParallelFFT<T>::parallel_ifft(&self, data: &mut [num_complex::Complex<T>]) -> numrs2::Result<()>
pub struct numrs2::parallel::ParallelMatrixOps
impl numrs2::parallel::parallel_algorithms::ParallelMatrixOps
pub fn numrs2::parallel::parallel_algorithms::ParallelMatrixOps::new(config: numrs2::parallel::parallel_algorithms::ParallelConfig) -> numrs2::Result<Self>
pub fn numrs2::parallel::parallel_algorithms::ParallelMatrixOps::parallel_matmul<T>(&self, a: &[T], b: &[T], c: &mut [T], m: usize, n: usize, k: usize) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::parallel::parallel_algorithms::ParallelMatrixOps::parallel_transpose<T>(&self, src: &[T], dst: &mut [T], rows: usize, cols: usize) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy
pub struct numrs2::parallel::ParallelScheduler
impl numrs2::parallel::scheduler::ParallelScheduler
pub fn numrs2::parallel::scheduler::ParallelScheduler::new(config: numrs2::parallel::scheduler::SchedulerConfig) -> numrs2::Result<Self>
pub fn numrs2::parallel::scheduler::ParallelScheduler::num_threads(&self) -> usize
pub fn numrs2::parallel::scheduler::ParallelScheduler::queue_length(&self) -> usize
pub fn numrs2::parallel::scheduler::ParallelScheduler::shutdown(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::scheduler::ParallelScheduler::statistics(&self) -> numrs2::parallel::scheduler::SchedulerStats
pub fn numrs2::parallel::scheduler::ParallelScheduler::submit_task<F>(&self, task: F, priority: numrs2::parallel::scheduler::TaskPriority, estimated_duration: core::option::Option<core::time::Duration>, thread_affinity: core::option::Option<usize>) -> numrs2::Result<u64> where F: core::ops::function::FnOnce() -> numrs2::parallel::scheduler::TaskResult + core::marker::Send + 'static
pub fn numrs2::parallel::scheduler::ParallelScheduler::submit_urgent_task<F>(&self, task: F) -> numrs2::Result<u64> where F: core::ops::function::FnOnce() -> numrs2::parallel::scheduler::TaskResult + core::marker::Send + 'static
pub struct numrs2::parallel::SchedulerConfig
pub numrs2::parallel::SchedulerConfig::cache_aware_scheduling: bool
pub numrs2::parallel::SchedulerConfig::enable_adaptive_scheduling: bool
pub numrs2::parallel::SchedulerConfig::enable_thread_affinity: bool
pub numrs2::parallel::SchedulerConfig::max_queue_size: usize
pub numrs2::parallel::SchedulerConfig::num_threads: usize
pub numrs2::parallel::SchedulerConfig::time_slice_ms: u64
pub numrs2::parallel::SchedulerConfig::work_stealing_threshold: usize
impl numrs2::parallel::scheduler::SchedulerConfig
pub fn numrs2::parallel::scheduler::SchedulerConfig::latency_optimized(num_cores: usize) -> Self
pub fn numrs2::parallel::scheduler::SchedulerConfig::optimal_for_cores(num_cores: usize) -> Self
pub fn numrs2::parallel::scheduler::SchedulerConfig::throughput_optimized(num_cores: usize) -> Self
pub struct numrs2::parallel::ThreadLocalAllocator
impl numrs2::parallel::parallel_allocator::ThreadLocalAllocator
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::current_thread_statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub unsafe fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::garbage_collect_current_thread(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::initialize_current_thread<A>(&self, allocator: A) -> numrs2::Result<()> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + 'static
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::new(config: numrs2::parallel::parallel_allocator::ParallelAllocatorConfig) -> Self
pub struct numrs2::parallel::WorkStealingPool
impl numrs2::parallel::work_stealing::WorkStealingPool
pub fn numrs2::parallel::work_stealing::WorkStealingPool::active_workers(&self) -> usize
pub fn numrs2::parallel::work_stealing::WorkStealingPool::new(num_threads: usize) -> numrs2::Result<Self>
pub fn numrs2::parallel::work_stealing::WorkStealingPool::pending_tasks(&self) -> usize
pub fn numrs2::parallel::work_stealing::WorkStealingPool::shutdown(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::work_stealing::WorkStealingPool::statistics(&self) -> numrs2::parallel::work_stealing::PoolStats
pub fn numrs2::parallel::work_stealing::WorkStealingPool::submit<T>(&self, task: T) -> numrs2::Result<()> where T: numrs2::parallel::work_stealing::Task<Output = numrs2::parallel::work_stealing::TaskResult<()>> + 'static
pub fn numrs2::parallel::work_stealing::WorkStealingPool::submit_urgent<T>(&self, task: T) -> numrs2::Result<()> where T: numrs2::parallel::work_stealing::Task<Output = numrs2::parallel::work_stealing::TaskResult<()>> + 'static
pub fn numrs2::parallel::work_stealing::WorkStealingPool::with_config(config: numrs2::parallel::work_stealing::WorkStealingConfig) -> numrs2::Result<Self>
pub struct numrs2::parallel::WorkloadMetrics
pub numrs2::parallel::WorkloadMetrics::active_tasks: u64
pub numrs2::parallel::WorkloadMetrics::avg_response_time: core::time::Duration
pub numrs2::parallel::WorkloadMetrics::cache_miss_rate: f64
pub numrs2::parallel::WorkloadMetrics::cpu_utilization: alloc::vec::Vec<f64>
pub numrs2::parallel::WorkloadMetrics::load_imbalance: f64
pub numrs2::parallel::WorkloadMetrics::memory_usage: alloc::vec::Vec<f64>
pub numrs2::parallel::WorkloadMetrics::queue_lengths: alloc::vec::Vec<usize>
pub numrs2::parallel::WorkloadMetrics::total_throughput: f64
pub numrs2::parallel::WorkloadMetrics::work_steals: u64
impl numrs2::parallel::load_balancer::WorkloadMetrics
pub fn numrs2::parallel::load_balancer::WorkloadMetrics::is_balanced(&self, threshold: f64) -> bool
pub fn numrs2::parallel::load_balancer::WorkloadMetrics::least_loaded_worker(&self) -> core::option::Option<usize>
pub fn numrs2::parallel::load_balancer::WorkloadMetrics::load_distribution_cv(&self) -> f64
pub fn numrs2::parallel::load_balancer::WorkloadMetrics::most_loaded_worker(&self) -> core::option::Option<usize>
pub trait numrs2::parallel::Task: core::marker::Send + 'static
pub type numrs2::parallel::Task::Output: core::marker::Send + 'static
pub fn numrs2::parallel::Task::can_split(&self) -> bool
pub fn numrs2::parallel::Task::estimated_cost(&self) -> core::option::Option<u64>
pub fn numrs2::parallel::Task::execute(self: alloc::boxed::Box<Self>) -> Self::Output
pub fn numrs2::parallel::Task::split(self: alloc::boxed::Box<Self>) -> alloc::vec::Vec<alloc::boxed::Box<dyn numrs2::parallel::work_stealing::Task<Output = Self::Output>>> where Self: core::marker::Sized
impl<F> numrs2::parallel::work_stealing::Task for numrs2::parallel::work_stealing::ClosureTask<F, ()> where F: core::ops::function::FnOnce() + core::marker::Send + 'static
pub type numrs2::parallel::work_stealing::ClosureTask<F, ()>::Output = numrs2::parallel::work_stealing::TaskResult<()>
pub fn numrs2::parallel::work_stealing::ClosureTask<F, ()>::execute(self: alloc::boxed::Box<Self>) -> Self::Output
pub fn numrs2::parallel::global_parallel_context() -> numrs2::Result<alloc::sync::Arc<numrs2::parallel::ParallelContext>>
pub fn numrs2::parallel::initialize_parallel_context() -> numrs2::Result<()>
pub fn numrs2::parallel::shutdown_parallel_context() -> numrs2::Result<()>
pub fn numrs2::parallel::task<F>(closure: F) -> numrs2::parallel::work_stealing::ClosureTask<F, ()> where F: core::ops::function::FnOnce() + core::marker::Send + 'static
pub mod numrs2::parallel_optimize
pub mod numrs2::parallel_optimize::scheduling
pub enum numrs2::parallel_optimize::scheduling::SchedulingStrategy
pub numrs2::parallel_optimize::scheduling::SchedulingStrategy::Adaptive
pub numrs2::parallel_optimize::scheduling::SchedulingStrategy::Dynamic
pub numrs2::parallel_optimize::scheduling::SchedulingStrategy::Guided
pub numrs2::parallel_optimize::scheduling::SchedulingStrategy::Static
pub numrs2::parallel_optimize::scheduling::SchedulingStrategy::WorkStealing
pub fn numrs2::parallel_optimize::scheduling::calculate_chunk_size(array_size: usize, strategy: numrs2::parallel_optimize::scheduling::SchedulingStrategy) -> usize
pub fn numrs2::parallel_optimize::scheduling::optimize_scheduling(array_size: usize, element_cost: f64, strategy: numrs2::parallel_optimize::scheduling::SchedulingStrategy, num_threads: usize) -> usize
pub fn numrs2::parallel_optimize::scheduling::work_stealing_scheduler(array_size: usize, element_cost: f64, num_threads: usize) -> usize
pub mod numrs2::parallel_optimize::threshold
pub enum numrs2::parallel_optimize::threshold::ParallelizationThreshold
pub numrs2::parallel_optimize::threshold::ParallelizationThreshold::Adaptive
pub numrs2::parallel_optimize::threshold::ParallelizationThreshold::AutoTuning
pub numrs2::parallel_optimize::threshold::ParallelizationThreshold::Benchmarked
pub numrs2::parallel_optimize::threshold::ParallelizationThreshold::Fixed(usize)
pub fn numrs2::parallel_optimize::threshold::adaptive_threshold(array_size: usize, element_cost: f64) -> usize
pub fn numrs2::parallel_optimize::threshold::auto_tune_threshold(array_size: usize, element_cost: f64) -> usize
pub fn numrs2::parallel_optimize::threshold::benchmark_threshold<F>(element_cost: F) -> usize where F: core::ops::function::Fn(usize) -> f64 + core::marker::Sync + core::marker::Send
pub fn numrs2::parallel_optimize::threshold::get_global_threshold() -> usize
pub fn numrs2::parallel_optimize::threshold::get_optimal_threshold(threshold_type: numrs2::parallel_optimize::threshold::ParallelizationThreshold, array_size: usize, element_cost: f64) -> usize
pub fn numrs2::parallel_optimize::threshold::set_global_threshold(threshold: usize)
pub mod numrs2::parallel_optimize::workload
pub enum numrs2::parallel_optimize::workload::WorkloadPartitioning
pub numrs2::parallel_optimize::workload::WorkloadPartitioning::CacheOptimizedChunks
pub numrs2::parallel_optimize::workload::WorkloadPartitioning::DynamicPartitioning
pub numrs2::parallel_optimize::workload::WorkloadPartitioning::EqualChunks
pub numrs2::parallel_optimize::workload::WorkloadPartitioning::PowerOfTwoChunks
pub numrs2::parallel_optimize::workload::WorkloadPartitioning::VariableChunks
pub fn numrs2::parallel_optimize::workload::parallel_execute<F, R>(array_size: usize, partitioning: numrs2::parallel_optimize::workload::WorkloadPartitioning, scheduling: numrs2::parallel_optimize::scheduling::SchedulingStrategy, op: F) -> alloc::vec::Vec<R> where F: core::ops::function::Fn(core::ops::range::Range<usize>) -> R + core::marker::Send + core::marker::Sync, R: core::marker::Send
pub fn numrs2::parallel_optimize::workload::partition_workload(array_size: usize, partitioning: numrs2::parallel_optimize::workload::WorkloadPartitioning, num_threads: usize) -> alloc::vec::Vec<core::ops::range::Range<usize>>
pub enum numrs2::parallel_optimize::ParallelizationThreshold
pub numrs2::parallel_optimize::ParallelizationThreshold::Adaptive
pub numrs2::parallel_optimize::ParallelizationThreshold::AutoTuning
pub numrs2::parallel_optimize::ParallelizationThreshold::Benchmarked
pub numrs2::parallel_optimize::ParallelizationThreshold::Fixed(usize)
pub enum numrs2::parallel_optimize::SchedulingStrategy
pub numrs2::parallel_optimize::SchedulingStrategy::Adaptive
pub numrs2::parallel_optimize::SchedulingStrategy::Dynamic
pub numrs2::parallel_optimize::SchedulingStrategy::Guided
pub numrs2::parallel_optimize::SchedulingStrategy::Static
pub numrs2::parallel_optimize::SchedulingStrategy::WorkStealing
pub enum numrs2::parallel_optimize::WorkloadPartitioning
pub numrs2::parallel_optimize::WorkloadPartitioning::CacheOptimizedChunks
pub numrs2::parallel_optimize::WorkloadPartitioning::DynamicPartitioning
pub numrs2::parallel_optimize::WorkloadPartitioning::EqualChunks
pub numrs2::parallel_optimize::WorkloadPartitioning::PowerOfTwoChunks
pub numrs2::parallel_optimize::WorkloadPartitioning::VariableChunks
pub struct numrs2::parallel_optimize::ParallelConfig
pub numrs2::parallel_optimize::ParallelConfig::chunk_size: usize
pub numrs2::parallel_optimize::ParallelConfig::max_threads: core::option::Option<usize>
pub numrs2::parallel_optimize::ParallelConfig::min_parallel_size: usize
pub numrs2::parallel_optimize::ParallelConfig::scheduling_strategy: numrs2::parallel_optimize::scheduling::SchedulingStrategy
pub numrs2::parallel_optimize::ParallelConfig::use_parallel: bool
impl numrs2::parallel_optimize::ParallelConfig
pub fn numrs2::parallel_optimize::ParallelConfig::new() -> Self
pub fn numrs2::parallel_optimize::ParallelConfig::optimal_threads(&self, array_size: usize, element_cost: f64) -> usize
pub fn numrs2::parallel_optimize::ParallelConfig::optimized(array_size: usize, element_cost: f64) -> Self
pub fn numrs2::parallel_optimize::ParallelConfig::should_parallelize(&self, array_size: usize) -> bool
pub fn numrs2::parallel_optimize::ParallelConfig::with_chunk_size(self, chunk_size: usize) -> Self
pub fn numrs2::parallel_optimize::ParallelConfig::with_max_threads(self, max_threads: usize) -> Self
pub fn numrs2::parallel_optimize::ParallelConfig::with_min_size(self, min_size: usize) -> Self
pub fn numrs2::parallel_optimize::ParallelConfig::with_parallel(self, use_parallel: bool) -> Self
pub fn numrs2::parallel_optimize::ParallelConfig::with_scheduling(self, strategy: numrs2::parallel_optimize::scheduling::SchedulingStrategy) -> Self
impl core::default::Default for numrs2::parallel_optimize::ParallelConfig
pub fn numrs2::parallel_optimize::ParallelConfig::default() -> Self
pub fn numrs2::parallel_optimize::adaptive_threshold(array_size: usize, element_cost: f64) -> usize
pub fn numrs2::parallel_optimize::get_optimal_threshold(threshold_type: numrs2::parallel_optimize::threshold::ParallelizationThreshold, array_size: usize, element_cost: f64) -> usize
pub fn numrs2::parallel_optimize::optimize_parallel_computation(array_size: usize, element_cost: f64, scheduling: numrs2::parallel_optimize::scheduling::SchedulingStrategy) -> usize
pub fn numrs2::parallel_optimize::optimize_scheduling(array_size: usize, element_cost: f64, strategy: numrs2::parallel_optimize::scheduling::SchedulingStrategy, num_threads: usize) -> usize
pub fn numrs2::parallel_optimize::partition_workload(array_size: usize, partitioning: numrs2::parallel_optimize::workload::WorkloadPartitioning, num_threads: usize) -> alloc::vec::Vec<core::ops::range::Range<usize>>
pub fn numrs2::parallel_optimize::set_global_threshold(threshold: usize)
pub fn numrs2::parallel_optimize::work_stealing_scheduler(array_size: usize, element_cost: f64, num_threads: usize) -> usize
pub mod numrs2::pde
pub enum numrs2::pde::BoundaryCondition<T>
pub numrs2::pde::BoundaryCondition::Dirichlet(T)
pub numrs2::pde::BoundaryCondition::Neumann(T)
pub numrs2::pde::BoundaryCondition::Periodic
pub struct numrs2::pde::Pde2dResult<T>
pub numrs2::pde::Pde2dResult::nt: usize
pub numrs2::pde::Pde2dResult::nx: usize
pub numrs2::pde::Pde2dResult::ny: usize
pub numrs2::pde::Pde2dResult::success: bool
pub numrs2::pde::Pde2dResult::t: alloc::vec::Vec<T>
pub numrs2::pde::Pde2dResult::u: alloc::vec::Vec<alloc::vec::Vec<T>>
pub numrs2::pde::Pde2dResult::x: alloc::vec::Vec<T>
pub numrs2::pde::Pde2dResult::y: alloc::vec::Vec<T>
pub struct numrs2::pde::PdeResult<T>
pub numrs2::pde::PdeResult::message: alloc::string::String
pub numrs2::pde::PdeResult::nt: usize
pub numrs2::pde::PdeResult::nx: usize
pub numrs2::pde::PdeResult::success: bool
pub numrs2::pde::PdeResult::t: alloc::vec::Vec<T>
pub numrs2::pde::PdeResult::u: alloc::vec::Vec<alloc::vec::Vec<T>>
pub numrs2::pde::PdeResult::x: alloc::vec::Vec<T>
pub fn numrs2::pde::method_of_lines_heat<T>(nx: usize, alpha: T, dx: T, bc_left: numrs2::pde::BoundaryCondition<T>, bc_right: numrs2::pde::BoundaryCondition<T>) -> impl core::ops::function::Fn(T, &[T]) -> alloc::vec::Vec<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::pde::optimal_omega<T>(nx: usize, ny: usize) -> T where T: num_traits::float::Float
pub fn numrs2::pde::solve_heat_1d<T>(initial: &[T], alpha: T, dx: T, dt: T, nt: usize, bc_left: numrs2::pde::BoundaryCondition<T>, bc_right: numrs2::pde::BoundaryCondition<T>) -> numrs2::Result<numrs2::pde::PdeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum
pub fn numrs2::pde::solve_heat_1d_crank_nicolson<T>(initial: &[T], alpha: T, dx: T, dt: T, nt: usize, bc_left: numrs2::pde::BoundaryCondition<T>, bc_right: numrs2::pde::BoundaryCondition<T>) -> numrs2::Result<numrs2::pde::PdeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum
pub fn numrs2::pde::solve_heat_2d<T>(initial: &[T], nx: usize, ny: usize, alpha: T, dx: T, dy: T, dt: T, nt: usize, bc: numrs2::pde::BoundaryCondition<T>) -> numrs2::Result<numrs2::pde::Pde2dResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum
pub fn numrs2::pde::solve_poisson_2d<T>(f: &[T], nx: usize, ny: usize, dx: T, dy: T, bc: numrs2::pde::BoundaryCondition<T>, max_iter: usize, tol: T) -> numrs2::Result<(alloc::vec::Vec<T>, usize, T)> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum
pub fn numrs2::pde::solve_poisson_gauss_seidel<T>(f: &[T], nx: usize, ny: usize, dx: T, dy: T, bc: numrs2::pde::BoundaryCondition<T>, max_iter: usize, tol: T) -> numrs2::Result<(alloc::vec::Vec<T>, usize, T)> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum
pub fn numrs2::pde::solve_poisson_sor<T>(f: &[T], nx: usize, ny: usize, dx: T, dy: T, bc: numrs2::pde::BoundaryCondition<T>, omega: T, max_iter: usize, tol: T) -> numrs2::Result<(alloc::vec::Vec<T>, usize, T)> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum
pub fn numrs2::pde::solve_wave_1d<T>(initial_u: &[T], initial_v: &[T], c: T, dx: T, dt: T, nt: usize, bc_left: numrs2::pde::BoundaryCondition<T>, bc_right: numrs2::pde::BoundaryCondition<T>) -> numrs2::Result<numrs2::pde::PdeResult<T>> where T: num_traits::float::Float + core::fmt::Debug + core::iter::traits::accum::Sum
pub mod numrs2::prelude
pub use numrs2::prelude::Axis
pub use numrs2::prelude::Complex
pub use numrs2::prelude::Complex64
pub use numrs2::prelude::Dimension
pub use numrs2::prelude::IxDyn
pub use numrs2::prelude::IxDyn
pub use numrs2::prelude::ShapeBuilder
pub mod numrs2::prelude::advanced_distributions
pub struct numrs2::prelude::advanced_distributions::Maxwell
impl numrs2::random::advanced_distributions::Maxwell
pub fn numrs2::random::advanced_distributions::Maxwell::new(scale: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::Maxwell::sample(&self) -> f64
pub struct numrs2::prelude::advanced_distributions::NonCentralChiSquared
impl numrs2::random::advanced_distributions::NonCentralChiSquared
pub fn numrs2::random::advanced_distributions::NonCentralChiSquared::new(df: f64, nonc: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::NonCentralChiSquared::sample(&self) -> f64
pub struct numrs2::prelude::advanced_distributions::NonCentralF
impl numrs2::random::advanced_distributions::NonCentralF
pub fn numrs2::random::advanced_distributions::NonCentralF::new(df1: f64, df2: f64, nonc: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::NonCentralF::sample(&self) -> f64
pub struct numrs2::prelude::advanced_distributions::VonMises
impl numrs2::random::advanced_distributions::VonMises
pub fn numrs2::random::advanced_distributions::VonMises::new(mu: f64, kappa: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::VonMises::sample(&self) -> f64
pub struct numrs2::prelude::advanced_distributions::Wald
impl numrs2::random::advanced_distributions::Wald
pub fn numrs2::random::advanced_distributions::Wald::new(mean: f64, shape: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::Wald::sample(&self) -> f64
pub fn numrs2::prelude::advanced_distributions::maxwell<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::advanced_distributions::noncentral_chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::advanced_distributions::noncentral_f<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::advanced_distributions::vonmises<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::advanced_distributions::wald<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::prelude::advanced_indexing
pub fn numrs2::prelude::advanced_indexing::apply_along_axis<T, U, F>(func: F, array: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + num_traits::identities::Zero, U: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> U
pub fn numrs2::prelude::advanced_indexing::apply_over_axes<T, F>(func: F, array: &numrs2::array::Array<T>, axes: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::advanced_indexing::boolean_index<T: core::clone::Clone>(array: &numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::advanced_indexing::compress<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::advanced_indexing::extract<T: core::clone::Clone>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::advanced_indexing::fancy_index<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &[numrs2::array::Array<usize>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::advanced_indexing::place<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>, values: &[T]) -> numrs2::Result<()>
pub fn numrs2::prelude::advanced_indexing::put<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, indices: &numrs2::array::Array<usize>, values: &[T]) -> numrs2::Result<()>
pub fn numrs2::prelude::advanced_indexing::putmask<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>, values: &numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::prelude::advanced_indexing::select<T: core::clone::Clone>(conditions: &[numrs2::array::Array<bool>], choices: &[numrs2::array::Array<T>], default: T) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::advanced_indexing::take<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &numrs2::array::Array<usize>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::advanced_indexing::take_along_axis<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &numrs2::array::Array<usize>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::prelude::array_requirements
pub struct numrs2::prelude::array_requirements::ArrayRequirements(_)
impl numrs2::array_ops::ArrayRequirements
pub const numrs2::array_ops::ArrayRequirements::CONTIGUOUS: Self
pub const numrs2::array_ops::ArrayRequirements::C_LAYOUT: Self
pub const numrs2::array_ops::ArrayRequirements::F_LAYOUT: Self
pub const numrs2::array_ops::ArrayRequirements::OWNDATA: Self
pub const numrs2::array_ops::ArrayRequirements::WRITEABLE: Self
pub fn numrs2::array_ops::ArrayRequirements::contains(&self, other: Self) -> bool
pub fn numrs2::array_ops::ArrayRequirements::empty() -> Self
pub fn numrs2::array_ops::ArrayRequirements::is_empty(&self) -> bool
impl core::ops::bit::BitAnd for numrs2::array_ops::ArrayRequirements
pub type numrs2::array_ops::ArrayRequirements::Output = numrs2::array_ops::ArrayRequirements
pub fn numrs2::array_ops::ArrayRequirements::bitand(self, rhs: Self) -> Self
impl core::ops::bit::BitOr for numrs2::array_ops::ArrayRequirements
pub type numrs2::array_ops::ArrayRequirements::Output = numrs2::array_ops::ArrayRequirements
pub fn numrs2::array_ops::ArrayRequirements::bitor(self, rhs: Self) -> Self
pub fn numrs2::prelude::array_requirements::require<T: core::clone::Clone>(array: &numrs2::array::Array<T>, requirements: core::option::Option<numrs2::array_ops::ArrayRequirements>) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::prelude::atleast
pub fn numrs2::prelude::atleast::atleast_1d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::atleast::atleast_2d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::atleast::atleast_3d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub mod numrs2::prelude::axis_ops
pub fn numrs2::prelude::axis_ops::moveaxis<T: core::clone::Clone>(array: &numrs2::array::Array<T>, source: &[usize], destination: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::axis_ops::rollaxis<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, axis: usize, start: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::axis_ops::swapaxes<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis1: usize, axis2: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::prelude::broadcasting
pub fn numrs2::prelude::broadcasting::broadcast_arrays<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::broadcasting::broadcast_to<T: core::clone::Clone>(array: &numrs2::array::Array<T>, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::prelude::business_days
pub enum numrs2::prelude::business_days::Weekday
pub numrs2::prelude::business_days::Weekday::Friday = 4
pub numrs2::prelude::business_days::Weekday::Monday = 0
pub numrs2::prelude::business_days::Weekday::Saturday = 5
pub numrs2::prelude::business_days::Weekday::Sunday = 6
pub numrs2::prelude::business_days::Weekday::Thursday = 3
pub numrs2::prelude::business_days::Weekday::Tuesday = 1
pub numrs2::prelude::business_days::Weekday::Wednesday = 2
impl numrs2::types::datetime::business_days::Weekday
pub fn numrs2::types::datetime::business_days::Weekday::is_business_day(&self) -> bool
pub struct numrs2::prelude::business_days::HolidayCalendar
impl numrs2::types::datetime::business_days::HolidayCalendar
pub fn numrs2::types::datetime::business_days::HolidayCalendar::add_holiday(&mut self, date: numrs2::types::datetime::DateTime64)
pub fn numrs2::types::datetime::business_days::HolidayCalendar::business_day_count(&self, start: &numrs2::types::datetime::DateTime64, end: &numrs2::types::datetime::DateTime64) -> numrs2::Result<i64>
pub fn numrs2::types::datetime::business_days::HolidayCalendar::is_business_day(&self, dt: &numrs2::types::datetime::DateTime64) -> numrs2::Result<bool>
pub fn numrs2::types::datetime::business_days::HolidayCalendar::is_holiday(&self, dt: &numrs2::types::datetime::DateTime64) -> bool
pub fn numrs2::types::datetime::business_days::HolidayCalendar::new() -> Self
pub fn numrs2::types::datetime::business_days::HolidayCalendar::us_federal(year: i32) -> numrs2::Result<Self>
impl core::default::Default for numrs2::types::datetime::business_days::HolidayCalendar
pub fn numrs2::types::datetime::business_days::HolidayCalendar::default() -> Self
pub fn numrs2::prelude::business_days::busday_count(start: &numrs2::types::datetime::DateTime64, end: &numrs2::types::datetime::DateTime64) -> numrs2::Result<i64>
pub fn numrs2::prelude::business_days::busday_offset(dt: &numrs2::types::datetime::DateTime64, offset: i64) -> numrs2::Result<numrs2::types::datetime::DateTime64>
pub fn numrs2::prelude::business_days::is_busday(dt: &numrs2::types::datetime::DateTime64) -> numrs2::Result<bool>
pub fn numrs2::prelude::business_days::weekday(dt: &numrs2::types::datetime::DateTime64) -> numrs2::Result<numrs2::types::datetime::business_days::Weekday>
pub mod numrs2::prelude::char
pub mod numrs2::prelude::char::regex_ops
pub fn numrs2::prelude::char::regex_ops::findall(arr: &numrs2::array_ops::string_ops::StringArray, pattern: &str) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::prelude::char::regex_ops::match_pattern(arr: &numrs2::array_ops::string_ops::StringArray, pattern: &str) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::regex_ops::split_regex(arr: &numrs2::array_ops::string_ops::StringArray, pattern: &str, maxsplit: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::prelude::char::regex_ops::sub(arr: &numrs2::array_ops::string_ops::StringArray, pattern: &str, replacement: &str, count: core::option::Option<usize>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub enum numrs2::prelude::char::StringElement
pub numrs2::prelude::char::StringElement::Fixed
pub numrs2::prelude::char::StringElement::Fixed::data: alloc::vec::Vec<u8>
pub numrs2::prelude::char::StringElement::Fixed::max_len: usize
pub numrs2::prelude::char::StringElement::Unicode(alloc::string::String)
impl numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::as_str(&self) -> numrs2::Result<&str>
pub fn numrs2::array_ops::string_ops::StringElement::capacity(&self) -> usize
pub fn numrs2::array_ops::string_ops::StringElement::fixed(s: &str, max_len: usize) -> Self
pub fn numrs2::array_ops::string_ops::StringElement::is_empty(&self) -> numrs2::Result<bool>
pub fn numrs2::array_ops::string_ops::StringElement::len(&self) -> numrs2::Result<usize>
pub fn numrs2::array_ops::string_ops::StringElement::to_string(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::array_ops::string_ops::StringElement::unicode<S: core::convert::Into<alloc::string::String>>(s: S) -> Self
impl core::cmp::Ord for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::cmp(&self, other: &Self) -> core::cmp::Ordering
impl core::cmp::PartialOrd for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering>
impl core::default::Default for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::default() -> Self
impl core::fmt::Display for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add for numrs2::array_ops::string_ops::StringElement
pub type numrs2::array_ops::string_ops::StringElement::Output = numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::add(self, other: Self) -> Self
impl num_traits::identities::Zero for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::is_zero(&self) -> bool
pub fn numrs2::array_ops::string_ops::StringElement::zero() -> Self
pub fn numrs2::prelude::char::add(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::array_from_strings<S: core::convert::AsRef<str>>(strings: &[S], dtype: &str, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::array_with_prefix<S: core::convert::AsRef<str>>(prefix: S, suffixes: &[S], dtype: &str) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::array_with_suffix<S: core::convert::AsRef<str>>(prefixes: &[S], suffix: S, dtype: &str) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::capitalize(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::center(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::count(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::prelude::char::decode(arr: &numrs2::array_ops::string_ops::StringArray, encoding: &str, errors: &str) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::encode(arr: &numrs2::array_ops::string_ops::StringArray, encoding: &str, errors: &str) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::endswith(arr: &numrs2::array_ops::string_ops::StringArray, suffix: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::expandtabs(arr: &numrs2::array_ops::string_ops::StringArray, tabsize: core::option::Option<usize>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::find(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::prelude::char::greater(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::greater_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::isalnum(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::isalpha(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::isdigit(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::islower(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::isspace(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::istitle(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::isupper(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::join(sep: &str, arr: &[alloc::vec::Vec<alloc::string::String>]) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::less(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::less_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::ljust(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::lower(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::lstrip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::mod_format(arr: &numrs2::array_ops::string_ops::StringArray, values: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::multiply(arr: &numrs2::array_ops::string_ops::StringArray, times: &numrs2::array::Array<i32>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::not_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::partition(arr: &numrs2::array_ops::string_ops::StringArray, sep: &str) -> numrs2::Result<alloc::vec::Vec<(alloc::string::String, alloc::string::String, alloc::string::String)>>
pub fn numrs2::prelude::char::replace(arr: &numrs2::array_ops::string_ops::StringArray, old: &str, new: &str, count: core::option::Option<usize>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::rfind(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::prelude::char::rjust(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::rpartition(arr: &numrs2::array_ops::string_ops::StringArray, sep: &str) -> numrs2::Result<alloc::vec::Vec<(alloc::string::String, alloc::string::String, alloc::string::String)>>
pub fn numrs2::prelude::char::rsplit(arr: &numrs2::array_ops::string_ops::StringArray, sep: core::option::Option<&str>, maxsplit: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::prelude::char::rstrip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::split(arr: &numrs2::array_ops::string_ops::StringArray, sep: core::option::Option<&str>, maxsplit: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::prelude::char::splitlines(arr: &numrs2::array_ops::string_ops::StringArray, keepends: core::option::Option<bool>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::prelude::char::startswith(arr: &numrs2::array_ops::string_ops::StringArray, prefix: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::char::str_len(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::prelude::char::strip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::swapcase(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::title(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::translate(arr: &numrs2::array_ops::string_ops::StringArray, table: &std::collections::hash::map::HashMap<char, char>, delete: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::upper(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::char::zfill(arr: &numrs2::array_ops::string_ops::StringArray, width: usize) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub type numrs2::prelude::char::StringArray = numrs2::array::Array<numrs2::array_ops::string_ops::StringElement>
pub mod numrs2::prelude::chartype
pub fn numrs2::prelude::chartype::isalnum(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::chartype::isalpha(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::chartype::isdigit(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::chartype::islower(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::chartype::isspace(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::chartype::istitle(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::chartype::isupper(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub mod numrs2::prelude::compare
pub fn numrs2::prelude::compare::equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::compare::greater(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::compare::greater_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::compare::less(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::compare::less_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::compare::not_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub mod numrs2::prelude::conditional
pub fn numrs2::prelude::conditional::choose<T: core::clone::Clone + num_traits::identities::Zero>(a: &numrs2::array::Array<usize>, choices: &[&numrs2::array::Array<T>], mode: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::conditional::interp<T>(x: &numrs2::array::Array<T>, xp: &numrs2::array::Array<T>, fp: &numrs2::array::Array<T>, left: core::option::Option<T>, right: core::option::Option<T>, period: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::float::Float
pub fn numrs2::prelude::conditional::piecewise<T, F>(x: &numrs2::array::Array<T>, condlist: &[&numrs2::array::Array<bool>], funclist: &[&F], fill_value: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::conditional::select<T: core::clone::Clone + num_traits::identities::Zero>(condlist: &[&numrs2::array::Array<bool>], choicelist: &[&numrs2::array::Array<T>], default: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::conditional::where_cond<T: core::clone::Clone + core::fmt::Display + core::marker::Send + core::marker::Sync>(condition: &numrs2::array::Array<bool>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::prelude::creation
pub enum numrs2::prelude::creation::SliceSpec
pub numrs2::prelude::creation::SliceSpec::Ellipsis
pub numrs2::prelude::creation::SliceSpec::Index(isize)
pub numrs2::prelude::creation::SliceSpec::NewAxis
pub numrs2::prelude::creation::SliceSpec::Range
pub numrs2::prelude::creation::SliceSpec::Range::start: core::option::Option<isize>
pub numrs2::prelude::creation::SliceSpec::Range::step: core::option::Option<isize>
pub numrs2::prelude::creation::SliceSpec::Range::stop: core::option::Option<isize>
impl numrs2::array_ops::SliceSpec
pub fn numrs2::array_ops::SliceSpec::from(start: isize) -> Self
pub fn numrs2::array_ops::SliceSpec::from_to(start: isize, stop: isize) -> Self
pub fn numrs2::array_ops::SliceSpec::full() -> Self
pub fn numrs2::array_ops::SliceSpec::range(start: core::option::Option<isize>, stop: core::option::Option<isize>, step: core::option::Option<isize>) -> Self
pub fn numrs2::array_ops::SliceSpec::step(step: isize) -> Self
pub fn numrs2::array_ops::SliceSpec::to(stop: isize) -> Self
pub const numrs2::prelude::creation::NEWAXIS: numrs2::array_ops::SliceSpec
pub fn numrs2::prelude::creation::asanyarray<T>(a: &impl core::convert::AsRef<[T]>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::prelude::creation::ascontiguousarray<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::prelude::creation::asfortranarray<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::prelude::creation::c_concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::creation::diagflat<T>(v: &numrs2::array::Array<T>, k: i32) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::creation::frombuffer<T: core::clone::Clone + core::default::Default>(buffer: &[u8], dtype_size: usize, count: isize, offset: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::creation::fromfunction<T, F>(function: F, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&[usize]) -> T
pub fn numrs2::prelude::creation::fromiter<T: core::clone::Clone, I: core::iter::traits::iterator::Iterator<Item = T>>(iter: I, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::creation::frommemmap<T: core::marker::Copy + core::clone::Clone + core::default::Default>(path: &std::path::Path, mode: &str, offset: core::option::Option<usize>, shape: core::option::Option<&[usize]>, order: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::creation::fromstring<T>(string: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: core::str::traits::FromStr + core::clone::Clone + num_traits::identities::Zero, <T as core::str::traits::FromStr>::Err: core::fmt::Display
pub fn numrs2::prelude::creation::geomspace<T>(start: T, stop: T, num: usize, endpoint: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::creation::iscontiguous<T>(_a: &numrs2::array::Array<T>) -> bool
pub fn numrs2::prelude::creation::isfortran<T>(a: &numrs2::array::Array<T>) -> bool where T: core::clone::Clone
pub fn numrs2::prelude::creation::ix_<T: core::clone::Clone>(sequences: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::creation::logspace<T>(start: T, stop: T, num: usize, endpoint: bool, base: T) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::creation::may_share_memory<T>(_a: &numrs2::array::Array<T>, _b: &numrs2::array::Array<T>) -> bool
pub fn numrs2::prelude::creation::meshgrid<T>(xi: &[&numrs2::array::Array<T>], indexing: &str, sparse: bool) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::prelude::creation::mgrid<T>(slices: &[(T, T, T)]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd + num_traits::cast::FromPrimitive + 'static
pub fn numrs2::prelude::creation::ogrid<T>(slices: &[(T, T, T)]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd + num_traits::cast::FromPrimitive + 'static
pub fn numrs2::prelude::creation::r_concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::creation::s_(specs: &[numrs2::array_ops::SliceSpec]) -> alloc::vec::Vec<numrs2::array_ops::SliceSpec>
pub fn numrs2::prelude::creation::shares_memory<T>(_a: &numrs2::array::Array<T>, _b: &numrs2::array::Array<T>) -> bool
pub fn numrs2::prelude::creation::tri<T>(n: usize, m: core::option::Option<usize>, k: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::prelude::creation::vander<T>(x: &numrs2::array::Array<T>, n: core::option::Option<usize>, increasing: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Mul<Output = T>
pub mod numrs2::prelude::datetime_array
pub fn numrs2::prelude::datetime_array::date_range(start: &str, end: core::option::Option<&str>, periods: core::option::Option<usize>, freq: numrs2::types::datetime::DateTimeUnit, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::array::Array<numrs2::types::datetime::DateTime64>>
pub fn numrs2::prelude::datetime_array::datetime_from_strings(strings: &[&str], unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::array::Array<numrs2::types::datetime::DateTime64>>
pub fn numrs2::prelude::datetime_array::now(unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::types::datetime::DateTime64>
pub fn numrs2::prelude::datetime_array::timedelta_range(start: i64, end: core::option::Option<i64>, periods: core::option::Option<usize>, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::array::Array<numrs2::types::datetime::TimeDelta64>>
pub fn numrs2::prelude::datetime_array::today(unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::types::datetime::DateTime64>
pub mod numrs2::prelude::diagonal
pub fn numrs2::prelude::diagonal::diag<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: impl core::convert::Into<core::option::Option<isize>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::diagonal::diagonal<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, offset: impl core::convert::Into<core::option::Option<isize>>, axis1: impl core::convert::Into<core::option::Option<usize>>, axis2: impl core::convert::Into<core::option::Option<usize>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::diagonal::fill_diagonal<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, val: T, wrap: bool) -> numrs2::Result<()>
pub mod numrs2::prelude::distributions
pub fn numrs2::prelude::distributions::bernoulli<T>(p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::beta<T>(a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::binomial<T>(n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::distributions::cauchy<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::chisquare<T>(df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::dirichlet<T>(alpha: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::exponential<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::gamma<T>(shape_param: T, scale: T, output_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::geometric<T>(p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::distributions::get_global_random_state() -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'static, numrs2::random::state::RandomState>>
pub fn numrs2::prelude::distributions::gumbel<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::hypergeometric<T>(ngood: usize, nbad: usize, nsample: usize, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::distributions::integers<T>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive, <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::prelude::distributions::laplace<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::logistic<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::lognormal<T>(mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::logseries<T>(p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::distributions::maxwell<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::multinomial<T>(n: usize, pvals: &[f64], shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::distributions::multivariate_normal<T>(mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::multivariate_normal_with_rotation<T>(mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>, rotation: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::negative_binomial<T>(n: f64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::distributions::noncentral_chisquare<T>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::noncentral_f<T>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::normal<T>(mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::pareto<T>(alpha: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::pert<T>(min: T, mode: T, max: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::poisson<T>(lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::distributions::rayleigh<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::set_seed(seed: u64)
pub fn numrs2::prelude::distributions::standard_normal<T>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::student_t<T>(df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::triangular<T>(low: T, mode: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::truncated_normal<T>(mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::uniform<T>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast
pub fn numrs2::prelude::distributions::vonmises<T>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::wald<T>(mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::weibull<T>(shape_param: T, scale: T, output_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::distributions::zipf<T>(a: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub mod numrs2::prelude::eigenvalue
pub type numrs2::prelude::eigenvalue::EigResult<T> = (numrs2::array::Array<num_complex::Complex<T>>, numrs2::array::Array<num_complex::Complex<T>>)
pub mod numrs2::prelude::joining
pub enum numrs2::prelude::joining::AxisArg
pub numrs2::prelude::joining::AxisArg::Multiple(alloc::vec::Vec<usize>)
pub numrs2::prelude::joining::AxisArg::Single(usize)
impl core::convert::From<&[usize]> for numrs2::array_ops::joining::AxisArg
pub fn numrs2::array_ops::joining::AxisArg::from(axes: &[usize]) -> Self
impl core::convert::From<alloc::vec::Vec<usize>> for numrs2::array_ops::joining::AxisArg
pub fn numrs2::array_ops::joining::AxisArg::from(axes: alloc::vec::Vec<usize>) -> Self
impl core::convert::From<usize> for numrs2::array_ops::joining::AxisArg
pub fn numrs2::array_ops::joining::AxisArg::from(axis: usize) -> Self
pub fn numrs2::prelude::joining::block<T: core::clone::Clone>(blocks: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::joining::bmat<T: core::clone::Clone>(obj: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::joining::bmat_from_arrays<T: core::clone::Clone>(obj: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::joining::bmat_from_string<T: core::clone::Clone>(_description: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::joining::c_<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::joining::column_stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::joining::concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>], axis: impl core::convert::Into<numrs2::array_ops::joining::AxisArg>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::joining::dstack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::joining::hstack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::joining::r_<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::joining::row_stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::joining::stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>], axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::joining::vstack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::prelude::manipulation
pub fn numrs2::prelude::manipulation::append<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, values: &[T], axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::compress<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::delete<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &[usize], axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::expand_dims<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::extract<T: core::clone::Clone>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::flatten<T: core::clone::Clone>(array: &numrs2::array::Array<T>, order: core::option::Option<char>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::flip<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::fliplr<T: core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::flipud<T: core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::insert<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &[usize], values: &[T], axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::packbits(array: &numrs2::array::Array<u8>, axis: core::option::Option<isize>, bitorder: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<u8>>
pub fn numrs2::prelude::manipulation::pad<T>(array: &numrs2::array::Array<T>, pad_width: &[(usize, usize)], mode: &str, constant_values: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::manipulation::place<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>, values: &[T]) -> numrs2::Result<()>
pub fn numrs2::prelude::manipulation::put<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, indices: &[usize], values: &[T]) -> numrs2::Result<()>
pub fn numrs2::prelude::manipulation::ravel<T: core::clone::Clone>(array: &numrs2::array::Array<T>, order: core::option::Option<char>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::ravel_multi_index(multi_index: &[&numrs2::array::Array<usize>], dims: &[usize], mode: core::option::Option<&str>, order: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::prelude::manipulation::roll<T: core::clone::Clone + core::marker::Send + core::marker::Sync>(array: &numrs2::array::Array<T>, shift: isize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::rot90<T: core::clone::Clone>(array: &numrs2::array::Array<T>, k: impl core::convert::Into<core::option::Option<i32>>, axes: impl core::convert::Into<core::option::Option<(usize, usize)>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::squeeze<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::tril<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: isize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::trim_zeros<T>(array: &numrs2::array::Array<T>, trim: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::prelude::manipulation::triu<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: isize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::manipulation::unpackbits(packed: &numrs2::array::Array<u8>, axis: core::option::Option<isize>, count: core::option::Option<usize>, bitorder: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<u8>>
pub fn numrs2::prelude::manipulation::unravel_index(indices: &numrs2::array::Array<usize>, shape: &[usize], order: core::option::Option<&str>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>>
pub mod numrs2::prelude::random
pub mod numrs2::prelude::random::advanced_distributions
pub struct numrs2::prelude::random::advanced_distributions::Maxwell
impl numrs2::random::advanced_distributions::Maxwell
pub fn numrs2::random::advanced_distributions::Maxwell::new(scale: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::Maxwell::sample(&self) -> f64
pub struct numrs2::prelude::random::advanced_distributions::NonCentralChiSquared
impl numrs2::random::advanced_distributions::NonCentralChiSquared
pub fn numrs2::random::advanced_distributions::NonCentralChiSquared::new(df: f64, nonc: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::NonCentralChiSquared::sample(&self) -> f64
pub struct numrs2::prelude::random::advanced_distributions::NonCentralF
impl numrs2::random::advanced_distributions::NonCentralF
pub fn numrs2::random::advanced_distributions::NonCentralF::new(df1: f64, df2: f64, nonc: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::NonCentralF::sample(&self) -> f64
pub struct numrs2::prelude::random::advanced_distributions::VonMises
impl numrs2::random::advanced_distributions::VonMises
pub fn numrs2::random::advanced_distributions::VonMises::new(mu: f64, kappa: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::VonMises::sample(&self) -> f64
pub struct numrs2::prelude::random::advanced_distributions::Wald
impl numrs2::random::advanced_distributions::Wald
pub fn numrs2::random::advanced_distributions::Wald::new(mean: f64, shape: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::Wald::sample(&self) -> f64
pub fn numrs2::prelude::random::advanced_distributions::maxwell<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::advanced_distributions::noncentral_chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::advanced_distributions::noncentral_f<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::advanced_distributions::vonmises<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::advanced_distributions::wald<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::prelude::random::distributions
pub fn numrs2::prelude::random::distributions::bernoulli<T>(p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::beta<T>(a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::binomial<T>(n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::distributions::cauchy<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::chisquare<T>(df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::dirichlet<T>(alpha: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::exponential<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::gamma<T>(shape_param: T, scale: T, output_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::geometric<T>(p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::distributions::get_global_random_state() -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'static, numrs2::random::state::RandomState>>
pub fn numrs2::prelude::random::distributions::gumbel<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::hypergeometric<T>(ngood: usize, nbad: usize, nsample: usize, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::distributions::integers<T>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive, <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::prelude::random::distributions::laplace<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::logistic<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::lognormal<T>(mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::logseries<T>(p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::distributions::maxwell<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::multinomial<T>(n: usize, pvals: &[f64], shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::distributions::multivariate_normal<T>(mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::multivariate_normal_with_rotation<T>(mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>, rotation: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::negative_binomial<T>(n: f64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::distributions::noncentral_chisquare<T>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::noncentral_f<T>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::normal<T>(mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::pareto<T>(alpha: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::pert<T>(min: T, mode: T, max: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::poisson<T>(lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::distributions::rayleigh<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::set_seed(seed: u64)
pub fn numrs2::prelude::random::distributions::standard_normal<T>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::student_t<T>(df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::triangular<T>(low: T, mode: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::truncated_normal<T>(mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::uniform<T>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast
pub fn numrs2::prelude::random::distributions::vonmises<T>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::wald<T>(mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::weibull<T>(shape_param: T, scale: T, output_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions::zipf<T>(a: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub mod numrs2::prelude::random::distributions_enhanced
pub fn numrs2::prelude::random::distributions_enhanced::copula<T>(corr: &numrs2::array::Array<T>, n: usize, copula_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions_enhanced::latin_hypercube<T>(dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions_enhanced::maxwell<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions_enhanced::mixture_of_normals<T>(weights: &[T], means: &[T], stds: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions_enhanced::multivariate_normal_cholesky<T>(means: &[T], cov: &numrs2::array::Array<T>, size: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions_enhanced::noncentral_chisquare<T>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions_enhanced::noncentral_f<T>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions_enhanced::power<T>(a: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions_enhanced::random_correlation_matrix<T>(n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::prelude::random::distributions_enhanced::sobol_sequence<T>(dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::distributions_enhanced::truncated_normal<T>(mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::prelude::random::distributions_enhanced::vonmises<T>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub mod numrs2::prelude::random::generator
pub struct numrs2::prelude::random::generator::Generator<B: numrs2::random::generator::BitGenerator>
impl<B: numrs2::random::generator::BitGenerator> numrs2::random::generator::Generator<B>
pub fn numrs2::random::generator::Generator<B>::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::beta<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::bit_generator(&self) -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'_, B>>
pub fn numrs2::random::generator::Generator<B>::chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::integers<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::random::generator::Generator<B>::integers_simple<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::new(bit_generator: B) -> Self
pub fn numrs2::random::generator::Generator<B>::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::poisson<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + num_traits::cast::NumCast
pub fn numrs2::random::generator::Generator<B>::standard_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::weibull<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub struct numrs2::prelude::random::generator::PCG64BitGenerator
impl numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::get_inc(&self) -> u128
pub fn numrs2::random::generator::PCG64BitGenerator::get_state(&self) -> u128
pub fn numrs2::random::generator::PCG64BitGenerator::new(seed: u64) -> Self
pub fn numrs2::random::generator::PCG64BitGenerator::new_random() -> Self
pub fn numrs2::random::generator::PCG64BitGenerator::with_state_and_inc(state: u128, inc: u128) -> Self
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::PCG64BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::PCG64BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::PCG64BitGenerator::seed(&mut self, seed: u64)
pub struct numrs2::prelude::random::generator::StdBitGenerator
impl numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::new(seed: u64) -> Self
pub fn numrs2::random::generator::StdBitGenerator::new_random() -> Self
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::StdBitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::StdBitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::StdBitGenerator::seed(&mut self, seed: u64)
pub trait numrs2::prelude::random::generator::BitGenerator
pub fn numrs2::prelude::random::generator::BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::prelude::random::generator::BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::prelude::random::generator::BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::prelude::random::generator::BitGenerator::seed(&mut self, seed: u64)
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::PCG64BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::PCG64BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::PCG64BitGenerator::seed(&mut self, seed: u64)
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::StdBitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::StdBitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::StdBitGenerator::seed(&mut self, seed: u64)
pub fn numrs2::prelude::random::generator::default_rng() -> numrs2::random::generator::Generator<numrs2::random::generator::StdBitGenerator>
pub fn numrs2::prelude::random::generator::pcg64_rng() -> numrs2::random::generator::Generator<numrs2::random::generator::PCG64BitGenerator>
pub fn numrs2::prelude::random::generator::pcg64_seed_rng(seed: u64) -> numrs2::random::generator::Generator<numrs2::random::generator::PCG64BitGenerator>
pub fn numrs2::prelude::random::generator::seed_rng(seed: u64) -> numrs2::random::generator::Generator<numrs2::random::generator::StdBitGenerator>
pub mod numrs2::prelude::random::legacy
pub struct numrs2::prelude::random::legacy::Generator
impl numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::choice<T: core::clone::Clone>(&self, array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::new() -> Self
pub fn numrs2::random::legacy::Generator::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::permutation<T: num_traits::cast::NumCast + core::clone::Clone>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::legacy::Generator::shuffle<T: core::clone::Clone>(&self, array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::legacy::Generator::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::with_seed(seed: u64) -> Self
impl core::default::Default for numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::default() -> Self
pub fn numrs2::prelude::random::legacy::choice<T: core::clone::Clone>(array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::legacy::rand<T>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::prelude::random::legacy::randn<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::legacy::seed(seed: u64)
pub fn numrs2::prelude::random::legacy::shuffle<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::prelude::random::legacy::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::prelude::random::random_base
pub struct numrs2::prelude::random::random_base::Generator
impl numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::choice<T: core::clone::Clone>(&self, array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::new() -> Self
pub fn numrs2::random::legacy::Generator::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::permutation<T: num_traits::cast::NumCast + core::clone::Clone>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::legacy::Generator::shuffle<T: core::clone::Clone>(&self, array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::legacy::Generator::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::with_seed(seed: u64) -> Self
impl core::default::Default for numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::default() -> Self
pub fn numrs2::prelude::random::random_base::choice<T: core::clone::Clone>(array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::random_base::rand<T>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::prelude::random::random_base::randn<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::random_base::seed(seed: u64)
pub fn numrs2::prelude::random::random_base::shuffle<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::prelude::random::random_base::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::prelude::random::state
pub struct numrs2::prelude::random::state::RandomState
impl numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::beta<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::cauchy<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::choice<T: core::clone::Clone>(&self, array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::dirichlet<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, alpha: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::geometric<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::get_rng(&self) -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'_, scirs2_core::random::prelude::StdRng>>
pub fn numrs2::random::state::RandomState::gumbel<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::hypergeometric<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, ngood: usize, nbad: usize, nsample: usize, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::integers<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::random::state::RandomState::laplace<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::logistic<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::logseries<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multinomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: usize, pvals: &[f64], shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multivariate_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multivariate_normal_with_rotation<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>, rotation: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::negative_binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: f64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::new() -> Self
pub fn numrs2::random::state::RandomState::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::pareto<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, alpha: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::permutation<T: num_traits::cast::NumCast + core::clone::Clone>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::pert<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, min: T, mode: T, max: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::poisson<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::state::RandomState::rayleigh<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::shuffle<T: core::clone::Clone>(&self, array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::state::RandomState::standard_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::student_t<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::triangular<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, low: T, mode: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::wald<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::weibull<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::with_seed(seed: u64) -> Self
pub fn numrs2::random::state::RandomState::zipf<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, a: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
impl numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::copula<T>(&self, corr: &numrs2::array::Array<T>, n: usize, copula_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::latin_hypercube<T>(&self, dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::maxwell<T>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::mixture_of_normals<T>(&self, weights: &[T], means: &[T], stds: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::multivariate_normal_cholesky<T>(&self, means: &[T], cov: &numrs2::array::Array<T>, size: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::noncentral_chisquare<T>(&self, df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::noncentral_f<T>(&self, dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::power<T>(&self, a: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::random_correlation_matrix<T>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::random::state::RandomState::sobol_sequence<T>(&self, dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::truncated_normal<T>(&self, mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::vonmises<T>(&self, mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
impl core::default::Default for numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::default() -> Self
pub struct numrs2::prelude::random::Generator<B: numrs2::random::generator::BitGenerator>
impl<B: numrs2::random::generator::BitGenerator> numrs2::random::generator::Generator<B>
pub fn numrs2::random::generator::Generator<B>::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::beta<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::bit_generator(&self) -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'_, B>>
pub fn numrs2::random::generator::Generator<B>::chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::integers<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::random::generator::Generator<B>::integers_simple<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::new(bit_generator: B) -> Self
pub fn numrs2::random::generator::Generator<B>::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::poisson<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + num_traits::cast::NumCast
pub fn numrs2::random::generator::Generator<B>::standard_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::weibull<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub struct numrs2::prelude::random::LegacyGenerator
impl numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::choice<T: core::clone::Clone>(&self, array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::new() -> Self
pub fn numrs2::random::legacy::Generator::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::permutation<T: num_traits::cast::NumCast + core::clone::Clone>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::legacy::Generator::shuffle<T: core::clone::Clone>(&self, array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::legacy::Generator::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::with_seed(seed: u64) -> Self
impl core::default::Default for numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::default() -> Self
pub struct numrs2::prelude::random::PCG64BitGenerator
impl numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::get_inc(&self) -> u128
pub fn numrs2::random::generator::PCG64BitGenerator::get_state(&self) -> u128
pub fn numrs2::random::generator::PCG64BitGenerator::new(seed: u64) -> Self
pub fn numrs2::random::generator::PCG64BitGenerator::new_random() -> Self
pub fn numrs2::random::generator::PCG64BitGenerator::with_state_and_inc(state: u128, inc: u128) -> Self
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::PCG64BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::PCG64BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::PCG64BitGenerator::seed(&mut self, seed: u64)
pub struct numrs2::prelude::random::RandomState
impl numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::beta<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::cauchy<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::choice<T: core::clone::Clone>(&self, array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::dirichlet<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, alpha: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::geometric<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::get_rng(&self) -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'_, scirs2_core::random::prelude::StdRng>>
pub fn numrs2::random::state::RandomState::gumbel<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::hypergeometric<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, ngood: usize, nbad: usize, nsample: usize, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::integers<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::random::state::RandomState::laplace<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::logistic<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::logseries<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multinomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: usize, pvals: &[f64], shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multivariate_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multivariate_normal_with_rotation<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>, rotation: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::negative_binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: f64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::new() -> Self
pub fn numrs2::random::state::RandomState::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::pareto<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, alpha: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::permutation<T: num_traits::cast::NumCast + core::clone::Clone>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::pert<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, min: T, mode: T, max: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::poisson<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::state::RandomState::rayleigh<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::shuffle<T: core::clone::Clone>(&self, array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::state::RandomState::standard_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::student_t<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::triangular<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, low: T, mode: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::wald<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::weibull<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::with_seed(seed: u64) -> Self
pub fn numrs2::random::state::RandomState::zipf<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, a: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
impl numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::copula<T>(&self, corr: &numrs2::array::Array<T>, n: usize, copula_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::latin_hypercube<T>(&self, dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::maxwell<T>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::mixture_of_normals<T>(&self, weights: &[T], means: &[T], stds: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::multivariate_normal_cholesky<T>(&self, means: &[T], cov: &numrs2::array::Array<T>, size: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::noncentral_chisquare<T>(&self, df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::noncentral_f<T>(&self, dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::power<T>(&self, a: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::random_correlation_matrix<T>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::random::state::RandomState::sobol_sequence<T>(&self, dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::truncated_normal<T>(&self, mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::vonmises<T>(&self, mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
impl core::default::Default for numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::default() -> Self
pub struct numrs2::prelude::random::StdBitGenerator
impl numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::new(seed: u64) -> Self
pub fn numrs2::random::generator::StdBitGenerator::new_random() -> Self
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::StdBitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::StdBitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::StdBitGenerator::seed(&mut self, seed: u64)
pub trait numrs2::prelude::random::BitGenerator
pub fn numrs2::prelude::random::BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::prelude::random::BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::prelude::random::BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::prelude::random::BitGenerator::seed(&mut self, seed: u64)
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::PCG64BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::PCG64BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::PCG64BitGenerator::seed(&mut self, seed: u64)
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::StdBitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::StdBitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::StdBitGenerator::seed(&mut self, seed: u64)
pub fn numrs2::prelude::random::bernoulli<T>(p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::beta<T>(a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::binomial<T>(n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::cauchy<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::chisquare<T>(df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::choice<T: core::clone::Clone>(array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::copula<T>(corr: &numrs2::array::Array<T>, n: usize, copula_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::default_rng() -> numrs2::random::generator::Generator<numrs2::random::generator::StdBitGenerator>
pub fn numrs2::prelude::random::dirichlet<T>(alpha: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::exponential<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::gamma<T>(shape_param: T, scale: T, output_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::geometric<T>(p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::get_global_random_state() -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'static, numrs2::random::state::RandomState>>
pub fn numrs2::prelude::random::gumbel<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::hypergeometric<T>(ngood: usize, nbad: usize, nsample: usize, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::integers<T>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive, <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::prelude::random::laplace<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::latin_hypercube<T>(dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::logistic<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::lognormal<T>(mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::logseries<T>(p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::maxwell<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::maxwell<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::mixture_of_normals<T>(weights: &[T], means: &[T], stds: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::multinomial<T>(n: usize, pvals: &[f64], shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::multivariate_normal<T>(mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::multivariate_normal_cholesky<T>(means: &[T], cov: &numrs2::array::Array<T>, size: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::multivariate_normal_with_rotation<T>(mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>, rotation: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::negative_binomial<T>(n: f64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::noncentral_chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::noncentral_chisquare<T>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::noncentral_f<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::noncentral_f<T>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::normal<T>(mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::pareto<T>(alpha: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::pcg64_rng() -> numrs2::random::generator::Generator<numrs2::random::generator::PCG64BitGenerator>
pub fn numrs2::prelude::random::pcg64_seed_rng(seed: u64) -> numrs2::random::generator::Generator<numrs2::random::generator::PCG64BitGenerator>
pub fn numrs2::prelude::random::pert<T>(min: T, mode: T, max: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::poisson<T>(lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::random::power<T>(a: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::rand<T>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::prelude::random::randn<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::random_correlation_matrix<T>(n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::prelude::random::rayleigh<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::seed(seed: u64)
pub fn numrs2::prelude::random::seed_rng(seed: u64) -> numrs2::random::state::RandomState
pub fn numrs2::prelude::random::set_seed(seed: u64)
pub fn numrs2::prelude::random::shuffle<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::prelude::random::sobol_sequence<T>(dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::standard_normal<T>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::student_t<T>(df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::triangular<T>(low: T, mode: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::truncated_normal<T>(mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::truncated_normal<T>(mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::prelude::random::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::uniform<T>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast
pub fn numrs2::prelude::random::vonmises<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::vonmises<T>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::wald<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::random::wald<T>(mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::weibull<T>(shape_param: T, scale: T, output_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::prelude::random::zipf<T>(a: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub mod numrs2::prelude::sorting
pub fn numrs2::prelude::sorting::bincount<T, W>(x: &numrs2::array::Array<T>, weights: core::option::Option<&numrs2::array::Array<W>>, minlength: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<W>> where T: core::clone::Clone + num_traits::cast::ToPrimitive + core::cmp::PartialOrd + num_traits::identities::Zero, W: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::AddAssign + num_traits::cast::NumCast
pub fn numrs2::prelude::sorting::digitize<T>(x: &numrs2::array::Array<T>, bins: &numrs2::array::Array<T>, right: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::prelude::sorting::lexsort<T: core::clone::Clone + core::cmp::PartialOrd + num_traits::identities::Zero>(keys: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::prelude::sorting::msort<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::sorting::partition<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>, kth: usize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::sorting::searchsorted<T: core::clone::Clone + core::cmp::PartialOrd>(a: &numrs2::array::Array<T>, v: &numrs2::array::Array<T>, side: core::option::Option<&str>, sorter: core::option::Option<&numrs2::array::Array<usize>>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::prelude::sorting::sort<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>, kind: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::sorting::sort_complex<T>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: core::clone::Clone + core::cmp::PartialOrd + num_traits::float::Float
pub mod numrs2::prelude::sparse
pub enum numrs2::prelude::sparse::SparseMatrixFormat
pub numrs2::prelude::sparse::SparseMatrixFormat::COO
pub numrs2::prelude::sparse::SparseMatrixFormat::CSC
pub numrs2::prelude::sparse::SparseMatrixFormat::CSR
pub numrs2::prelude::sparse::SparseMatrixFormat::DIA
pub struct numrs2::prelude::sparse::SparseArray<T>
pub numrs2::prelude::sparse::SparseArray::data: std::collections::hash::map::HashMap<alloc::vec::Vec<usize>, T>
pub numrs2::prelude::sparse::SparseArray::shape: alloc::vec::Vec<usize>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Add<Output = T>
pub fn numrs2::sparse::SparseArray<T>::add(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Div<Output = T>
pub fn numrs2::sparse::SparseArray<T>::divide(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
pub fn numrs2::sparse::SparseArray<T>::divide_scalar(&self, scalar: T) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Mul<Output = T>
pub fn numrs2::sparse::SparseArray<T>::multiply(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
pub fn numrs2::sparse::SparseArray<T>::multiply_scalar(&self, scalar: T) -> numrs2::sparse::SparseArray<T>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Sub<Output = T>
pub fn numrs2::sparse::SparseArray<T>::subtract(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero
pub fn numrs2::sparse::SparseArray<T>::density(&self) -> f64
pub fn numrs2::sparse::SparseArray<T>::from_array(array: &numrs2::array::Array<T>) -> Self
pub fn numrs2::sparse::SparseArray<T>::get(&self, indices: &[usize]) -> numrs2::Result<T>
pub fn numrs2::sparse::SparseArray<T>::ndim(&self) -> usize
pub fn numrs2::sparse::SparseArray<T>::new(shape: &[usize]) -> Self
pub fn numrs2::sparse::SparseArray<T>::nnz(&self) -> usize
pub fn numrs2::sparse::SparseArray<T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseArray<T>::shape(&self) -> &[usize]
pub fn numrs2::sparse::SparseArray<T>::to_array(&self) -> numrs2::array::Array<T>
pub struct numrs2::prelude::sparse::SparseMatrix<T>
pub numrs2::prelude::sparse::SparseMatrix::array: numrs2::sparse::SparseArray<T>
pub numrs2::prelude::sparse::SparseMatrix::diag_offsets: core::option::Option<alloc::vec::Vec<isize>>
pub numrs2::prelude::sparse::SparseMatrix::format: numrs2::sparse::SparseMatrixFormat
pub numrs2::prelude::sparse::SparseMatrix::indices: core::option::Option<alloc::vec::Vec<usize>>
pub numrs2::prelude::sparse::SparseMatrix::indptr: core::option::Option<alloc::vec::Vec<usize>>
impl<T> numrs2::sparse::SparseMatrix<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::fmt::Debug
pub fn numrs2::sparse::SparseMatrix<T>::density(&self) -> f64
pub fn numrs2::sparse::SparseMatrix<T>::diag(diagonal: &[T]) -> numrs2::Result<Self>
pub fn numrs2::sparse::SparseMatrix<T>::eye(n: usize) -> numrs2::Result<Self> where T: num_traits::identities::One
pub fn numrs2::sparse::SparseMatrix<T>::from_array(array: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub fn numrs2::sparse::SparseMatrix<T>::get(&self, row: usize, col: usize) -> numrs2::Result<T>
pub fn numrs2::sparse::SparseMatrix<T>::new(shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::sparse::SparseMatrix<T>::nnz(&self) -> usize
pub fn numrs2::sparse::SparseMatrix<T>::set(&mut self, row: usize, col: usize, value: T) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseMatrix<T>::shape(&self) -> &[usize]
pub fn numrs2::sparse::SparseMatrix<T>::to_array(&self) -> numrs2::array::Array<T>
pub fn numrs2::sparse::SparseMatrix<T>::to_csc(&mut self) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseMatrix<T>::to_csr(&mut self) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseMatrix<T>::to_dia(&mut self) -> numrs2::Result<()>
impl<T> numrs2::sparse::SparseMatrix<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::fmt::Debug
pub fn numrs2::sparse::SparseMatrix<T>::matmul(&self, other: &numrs2::sparse::SparseMatrix<T>) -> numrs2::Result<numrs2::sparse::SparseMatrix<T>>
pub fn numrs2::sparse::SparseMatrix<T>::transpose(&self) -> numrs2::Result<numrs2::sparse::SparseMatrix<T>>
pub struct numrs2::prelude::sparse::SparseOpsAdvanced
impl numrs2::sparse_enhanced::SparseOpsAdvanced
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::condition_number_estimate<T>(a: &numrs2::sparse::SparseMatrix<T>, max_iter: usize, tol: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::incomplete_lu<T>(a: &numrs2::sparse::SparseMatrix<T>, _fill_factor: f64) -> numrs2::Result<(numrs2::sparse::SparseMatrix<T>, numrs2::sparse::SparseMatrix<T>)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::solve_bicgstab<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: T, max_iter: usize) -> numrs2::Result<(numrs2::array::Array<T>, usize, T)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::solve_cg<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: T, max_iter: usize) -> numrs2::Result<(numrs2::array::Array<T>, usize, T)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::solve_gmres<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: T, max_iter: usize, restart: usize) -> numrs2::Result<(numrs2::array::Array<T>, usize, T)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::spgemm<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::sparse::SparseMatrix<T>) -> numrs2::Result<numrs2::sparse::SparseMatrix<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::spmv_dense<T>(a: &numrs2::sparse::SparseMatrix<T>, x: &numrs2::array::Array<T>, y: &mut numrs2::array::Array<T>, alpha: T, beta: T) -> numrs2::Result<()> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub mod numrs2::prelude::splitting
pub enum numrs2::prelude::splitting::SplitArg
pub numrs2::prelude::splitting::SplitArg::Indices(alloc::vec::Vec<usize>)
pub numrs2::prelude::splitting::SplitArg::Sections(usize)
impl core::convert::From<&[usize]> for numrs2::array_ops::SplitArg
pub fn numrs2::array_ops::SplitArg::from(indices: &[usize]) -> Self
impl core::convert::From<alloc::vec::Vec<usize>> for numrs2::array_ops::SplitArg
pub fn numrs2::array_ops::SplitArg::from(indices: alloc::vec::Vec<usize>) -> Self
impl core::convert::From<usize> for numrs2::array_ops::SplitArg
pub fn numrs2::array_ops::SplitArg::from(sections: usize) -> Self
pub fn numrs2::prelude::splitting::array_split<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>, axis: usize) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::splitting::dsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::splitting::hsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::splitting::split<T: core::clone::Clone>(array: &numrs2::array::Array<T>, indices: &[usize], axis: usize) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::splitting::vsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub mod numrs2::prelude::string_ops
pub mod numrs2::prelude::string_ops::chartype
pub fn numrs2::prelude::string_ops::chartype::isalnum(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::chartype::isalpha(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::chartype::isdigit(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::chartype::islower(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::chartype::isspace(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::chartype::istitle(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::chartype::isupper(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub mod numrs2::prelude::string_ops::compare
pub fn numrs2::prelude::string_ops::compare::equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::compare::greater(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::compare::greater_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::compare::less(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::compare::less_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::compare::not_equal(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array::Array<bool>>
pub enum numrs2::prelude::string_ops::StringElement
pub numrs2::prelude::string_ops::StringElement::Fixed
pub numrs2::prelude::string_ops::StringElement::Fixed::data: alloc::vec::Vec<u8>
pub numrs2::prelude::string_ops::StringElement::Fixed::max_len: usize
pub numrs2::prelude::string_ops::StringElement::Unicode(alloc::string::String)
impl numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::as_str(&self) -> numrs2::Result<&str>
pub fn numrs2::array_ops::string_ops::StringElement::capacity(&self) -> usize
pub fn numrs2::array_ops::string_ops::StringElement::fixed(s: &str, max_len: usize) -> Self
pub fn numrs2::array_ops::string_ops::StringElement::is_empty(&self) -> numrs2::Result<bool>
pub fn numrs2::array_ops::string_ops::StringElement::len(&self) -> numrs2::Result<usize>
pub fn numrs2::array_ops::string_ops::StringElement::to_string(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::array_ops::string_ops::StringElement::unicode<S: core::convert::Into<alloc::string::String>>(s: S) -> Self
impl core::cmp::Ord for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::cmp(&self, other: &Self) -> core::cmp::Ordering
impl core::cmp::PartialOrd for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering>
impl core::default::Default for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::default() -> Self
impl core::fmt::Display for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add for numrs2::array_ops::string_ops::StringElement
pub type numrs2::array_ops::string_ops::StringElement::Output = numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::add(self, other: Self) -> Self
impl num_traits::identities::Zero for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::is_zero(&self) -> bool
pub fn numrs2::array_ops::string_ops::StringElement::zero() -> Self
pub fn numrs2::prelude::string_ops::add(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::array_from_strings<S: core::convert::AsRef<str>>(strings: &[S], dtype: &str, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::capitalize(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::center(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::count(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::prelude::string_ops::endswith(arr: &numrs2::array_ops::string_ops::StringArray, suffix: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::find(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::prelude::string_ops::join(sep: &str, arr: &[alloc::vec::Vec<alloc::string::String>]) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::ljust(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::lower(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::lstrip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::mod_format(arr: &numrs2::array_ops::string_ops::StringArray, values: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::multiply(arr: &numrs2::array_ops::string_ops::StringArray, times: &numrs2::array::Array<i32>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::replace(arr: &numrs2::array_ops::string_ops::StringArray, old: &str, new: &str, count: core::option::Option<usize>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::rfind(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::prelude::string_ops::rjust(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::rstrip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::split(arr: &numrs2::array_ops::string_ops::StringArray, sep: core::option::Option<&str>, maxsplit: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::prelude::string_ops::startswith(arr: &numrs2::array_ops::string_ops::StringArray, prefix: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::string_ops::strip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::title(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_ops::upper(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub type numrs2::prelude::string_ops::StringArray = numrs2::array::Array<numrs2::array_ops::string_ops::StringElement>
pub mod numrs2::prelude::tiling
pub fn numrs2::prelude::tiling::repeat<T: core::clone::Clone>(array: &numrs2::array::Array<T>, repeats: usize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::tiling::tile<T: core::clone::Clone>(array: &numrs2::array::Array<T>, reps: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::prelude::tolerances
pub fn numrs2::prelude::tolerances::default() -> numrs2::testing::ToleranceConfig
pub fn numrs2::prelude::tolerances::loose() -> numrs2::testing::ToleranceConfig
pub fn numrs2::prelude::tolerances::relaxed() -> numrs2::testing::ToleranceConfig
pub fn numrs2::prelude::tolerances::strict() -> numrs2::testing::ToleranceConfig
pub fn numrs2::prelude::tolerances::with_nan() -> numrs2::testing::ToleranceConfig
pub macro numrs2::prelude::run_tests!
pub enum numrs2::prelude::AccessPattern
pub numrs2::prelude::AccessPattern::Blocked
pub numrs2::prelude::AccessPattern::Random
pub numrs2::prelude::AccessPattern::Reverse
pub numrs2::prelude::AccessPattern::Sequential
pub numrs2::prelude::AccessPattern::Strided(usize)
impl numrs2::memory_optimize::access_patterns::AccessPattern
pub fn numrs2::memory_optimize::access_patterns::AccessPattern::benefits_from_prefetch(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::AccessPattern::prefetch_distance(&self) -> usize
pub enum numrs2::prelude::AlignmentStrategy
pub numrs2::prelude::AlignmentStrategy::CacheLine
pub numrs2::prelude::AlignmentStrategy::Custom(usize)
pub numrs2::prelude::AlignmentStrategy::Default
pub numrs2::prelude::AlignmentStrategy::Simd
pub enum numrs2::prelude::AllocStrategy
pub numrs2::prelude::AllocStrategy::Aligned
pub numrs2::prelude::AllocStrategy::Arena
pub numrs2::prelude::AllocStrategy::Auto
pub numrs2::prelude::AllocStrategy::Pool
pub numrs2::prelude::AllocStrategy::Standard
pub enum numrs2::prelude::AllocationFrequency
pub numrs2::prelude::AllocationFrequency::High
pub numrs2::prelude::AllocationFrequency::Low
pub numrs2::prelude::AllocationFrequency::Medium
pub numrs2::prelude::AllocationFrequency::VeryHigh
pub enum numrs2::prelude::AllocationLifetime
pub numrs2::prelude::AllocationLifetime::LongTerm
pub numrs2::prelude::AllocationLifetime::MediumTerm
pub numrs2::prelude::AllocationLifetime::Permanent
pub numrs2::prelude::AllocationLifetime::ShortTerm
pub numrs2::prelude::AllocationLifetime::Temporary
pub enum numrs2::prelude::BalancingStrategy
pub numrs2::prelude::BalancingStrategy::Adaptive
pub numrs2::prelude::BalancingStrategy::LeastLoaded
pub numrs2::prelude::BalancingStrategy::NumaAware
pub numrs2::prelude::BalancingStrategy::RoundRobin
pub numrs2::prelude::BalancingStrategy::WeightedCapacity
pub numrs2::prelude::BalancingStrategy::WorkStealing
pub enum numrs2::prelude::BooleanCombineOp
pub numrs2::prelude::BooleanCombineOp::And
pub numrs2::prelude::BooleanCombineOp::Or
pub numrs2::prelude::BooleanCombineOp::Xor
pub enum numrs2::prelude::CacheLevel
pub numrs2::prelude::CacheLevel::L1
pub numrs2::prelude::CacheLevel::L2
pub numrs2::prelude::CacheLevel::L3
pub enum numrs2::prelude::DType
pub numrs2::prelude::DType::Bool
pub numrs2::prelude::DType::Complex32
pub numrs2::prelude::DType::Complex64
pub numrs2::prelude::DType::Float32
pub numrs2::prelude::DType::Float64
pub numrs2::prelude::DType::Int16
pub numrs2::prelude::DType::Int32
pub numrs2::prelude::DType::Int64
pub numrs2::prelude::DType::Int8
pub numrs2::prelude::DType::String(usize)
pub numrs2::prelude::DType::Struct(alloc::vec::Vec<numrs2::types::structured::Field>)
pub numrs2::prelude::DType::UInt16
pub numrs2::prelude::DType::UInt32
pub numrs2::prelude::DType::UInt64
pub numrs2::prelude::DType::UInt8
impl numrs2::types::structured::DType
pub fn numrs2::types::structured::DType::is_complex(&self) -> bool
pub fn numrs2::types::structured::DType::is_floating_point(&self) -> bool
pub fn numrs2::types::structured::DType::is_numeric(&self) -> bool
pub fn numrs2::types::structured::DType::is_string(&self) -> bool
pub fn numrs2::types::structured::DType::is_struct(&self) -> bool
pub fn numrs2::types::structured::DType::size_in_bytes(&self) -> usize
impl core::fmt::Display for numrs2::types::structured::DType
pub fn numrs2::types::structured::DType::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub enum numrs2::prelude::DateTimeUnit
pub numrs2::prelude::DateTimeUnit::Day
pub numrs2::prelude::DateTimeUnit::Hour
pub numrs2::prelude::DateTimeUnit::Microsecond
pub numrs2::prelude::DateTimeUnit::Millisecond
pub numrs2::prelude::DateTimeUnit::Minute
pub numrs2::prelude::DateTimeUnit::Month
pub numrs2::prelude::DateTimeUnit::Nanosecond
pub numrs2::prelude::DateTimeUnit::Second
pub numrs2::prelude::DateTimeUnit::Week
pub numrs2::prelude::DateTimeUnit::Year
impl core::fmt::Display for numrs2::types::datetime::DateTimeUnit
pub fn numrs2::types::datetime::DateTimeUnit::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub enum numrs2::prelude::DateUnit
pub numrs2::prelude::DateUnit::Day
pub numrs2::prelude::DateUnit::Month
pub numrs2::prelude::DateUnit::Week
pub numrs2::prelude::DateUnit::Year
pub enum numrs2::prelude::ErrorAction
pub numrs2::prelude::ErrorAction::Call
pub numrs2::prelude::ErrorAction::Ignore
pub numrs2::prelude::ErrorAction::Raise
pub numrs2::prelude::ErrorAction::Warn
impl core::fmt::Display for numrs2::error_handling::ErrorAction
pub fn numrs2::error_handling::ErrorAction::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::str::traits::FromStr for numrs2::error_handling::ErrorAction
pub type numrs2::error_handling::ErrorAction::Err = alloc::string::String
pub fn numrs2::error_handling::ErrorAction::from_str(s: &str) -> core::result::Result<Self, Self::Err>
pub enum numrs2::prelude::ExprKey
pub numrs2::prelude::ExprKey::Array(u64)
pub numrs2::prelude::ExprKey::Binary
pub numrs2::prelude::ExprKey::Binary::left: alloc::boxed::Box<numrs2::expr::ExprKey>
pub numrs2::prelude::ExprKey::Binary::op: &'static str
pub numrs2::prelude::ExprKey::Binary::right: alloc::boxed::Box<numrs2::expr::ExprKey>
pub numrs2::prelude::ExprKey::Scalar
pub numrs2::prelude::ExprKey::Scalar::op: &'static str
pub numrs2::prelude::ExprKey::Scalar::operand: alloc::boxed::Box<numrs2::expr::ExprKey>
pub numrs2::prelude::ExprKey::Scalar::scalar_hash: u64
pub numrs2::prelude::ExprKey::Unary
pub numrs2::prelude::ExprKey::Unary::op: &'static str
pub numrs2::prelude::ExprKey::Unary::operand: alloc::boxed::Box<numrs2::expr::ExprKey>
impl numrs2::expr::ExprKey
pub fn numrs2::expr::ExprKey::array(id: u64) -> Self
pub fn numrs2::expr::ExprKey::binary(op: &'static str, left: numrs2::expr::ExprKey, right: numrs2::expr::ExprKey) -> Self
pub fn numrs2::expr::ExprKey::scalar(op: &'static str, operand: numrs2::expr::ExprKey, scalar_hash: u64) -> Self
pub fn numrs2::expr::ExprKey::unary(op: &'static str, operand: numrs2::expr::ExprKey) -> Self
pub enum numrs2::prelude::FloatingPointError
pub numrs2::prelude::FloatingPointError::DivideByZero
pub numrs2::prelude::FloatingPointError::Invalid
pub numrs2::prelude::FloatingPointError::Overflow
pub numrs2::prelude::FloatingPointError::Underflow
impl core::fmt::Display for numrs2::error_handling::FloatingPointError
pub fn numrs2::error_handling::FloatingPointError::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub enum numrs2::prelude::HistBins
pub numrs2::prelude::HistBins::Single(usize)
pub numrs2::prelude::HistBins::Tuple(usize, usize)
impl core::convert::From<(usize, usize)> for numrs2::stats::HistBins
pub fn numrs2::stats::HistBins::from(val: (usize, usize)) -> Self
impl core::convert::From<usize> for numrs2::stats::HistBins
pub fn numrs2::stats::HistBins::from(val: usize) -> Self
pub enum numrs2::prelude::IndexSpec
pub numrs2::prelude::IndexSpec::All
pub numrs2::prelude::IndexSpec::Ellipsis
pub numrs2::prelude::IndexSpec::Index(usize)
pub numrs2::prelude::IndexSpec::Indices(alloc::vec::Vec<usize>)
pub numrs2::prelude::IndexSpec::Mask(alloc::vec::Vec<bool>)
pub numrs2::prelude::IndexSpec::NewAxis
pub numrs2::prelude::IndexSpec::Slice(usize, core::option::Option<usize>, core::option::Option<usize>)
impl numrs2::indexing::IndexSpec
pub fn numrs2::indexing::IndexSpec::ellipsis() -> Self
pub fn numrs2::indexing::IndexSpec::from_indices(indices: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::indexing::IndexSpec::from_mask(mask: alloc::vec::Vec<bool>) -> Self
pub fn numrs2::indexing::IndexSpec::from_range(range: core::ops::range::Range<usize>) -> Self
pub fn numrs2::indexing::IndexSpec::newaxis() -> Self
pub fn numrs2::indexing::IndexSpec::slice(start: usize, end: core::option::Option<usize>, step: core::option::Option<usize>) -> Self
pub enum numrs2::prelude::LayoutStrategy
pub numrs2::prelude::LayoutStrategy::Blocked(usize)
pub numrs2::prelude::LayoutStrategy::CacheOblivious
pub numrs2::prelude::LayoutStrategy::ColumnMajor
pub numrs2::prelude::LayoutStrategy::Hilbert
pub numrs2::prelude::LayoutStrategy::Morton
pub numrs2::prelude::LayoutStrategy::RowMajor
pub enum numrs2::prelude::MemoryLayout
pub numrs2::prelude::MemoryLayout::ColumnMajor
pub numrs2::prelude::MemoryLayout::RowMajor
pub enum numrs2::prelude::MemoryOperation<T>
pub numrs2::prelude::MemoryOperation::Convolution
pub numrs2::prelude::MemoryOperation::Convolution::_phantom: core::marker::PhantomData<T>
pub numrs2::prelude::MemoryOperation::Convolution::input_size: usize
pub numrs2::prelude::MemoryOperation::Convolution::kernel_size: usize
pub numrs2::prelude::MemoryOperation::Convolution::output_size: usize
pub numrs2::prelude::MemoryOperation::MatrixMultiply
pub numrs2::prelude::MemoryOperation::MatrixMultiply::_phantom: core::marker::PhantomData<T>
pub numrs2::prelude::MemoryOperation::MatrixMultiply::k: usize
pub numrs2::prelude::MemoryOperation::MatrixMultiply::m: usize
pub numrs2::prelude::MemoryOperation::MatrixMultiply::n: usize
pub numrs2::prelude::MemoryOperation::VectorOperation
pub numrs2::prelude::MemoryOperation::VectorOperation::_phantom: core::marker::PhantomData<T>
pub numrs2::prelude::MemoryOperation::VectorOperation::length: usize
pub enum numrs2::prelude::NumRs2Error
pub numrs2::prelude::NumRs2Error::AllocationFailed(alloc::string::String)
pub numrs2::prelude::NumRs2Error::BlasError(i32)
pub numrs2::prelude::NumRs2Error::Computation(numrs2::error::ComputationError)
pub numrs2::prelude::NumRs2Error::ComputationError(alloc::string::String)
pub numrs2::prelude::NumRs2Error::ConversionError(alloc::string::String)
pub numrs2::prelude::NumRs2Error::Core(numrs2::error::CoreError)
pub numrs2::prelude::NumRs2Error::DeserializationError(alloc::string::String)
pub numrs2::prelude::NumRs2Error::DimensionMismatch(alloc::string::String)
pub numrs2::prelude::NumRs2Error::FeatureNotEnabled(alloc::string::String)
pub numrs2::prelude::NumRs2Error::IO(numrs2::error::IOError)
pub numrs2::prelude::NumRs2Error::IOError(alloc::string::String)
pub numrs2::prelude::NumRs2Error::IndexError(alloc::string::String)
pub numrs2::prelude::NumRs2Error::IndexOutOfBounds(alloc::string::String)
pub numrs2::prelude::NumRs2Error::InvalidOperation(alloc::string::String)
pub numrs2::prelude::NumRs2Error::LapackError(alloc::string::String)
pub numrs2::prelude::NumRs2Error::Memory(numrs2::error::MemoryError)
pub numrs2::prelude::NumRs2Error::NotImplemented(alloc::string::String)
pub numrs2::prelude::NumRs2Error::RuntimeError(alloc::string::String)
pub numrs2::prelude::NumRs2Error::SerializationError(alloc::string::String)
pub numrs2::prelude::NumRs2Error::ShapeMismatch
pub numrs2::prelude::NumRs2Error::ShapeMismatch::actual: alloc::vec::Vec<usize>
pub numrs2::prelude::NumRs2Error::ShapeMismatch::expected: alloc::vec::Vec<usize>
pub numrs2::prelude::NumRs2Error::TypeCastError(alloc::string::String)
pub numrs2::prelude::NumRs2Error::ValueError(alloc::string::String)
impl numrs2::NumRs2Error
pub fn numrs2::NumRs2Error::at_location(self, location: numrs2::error::ErrorLocation) -> numrs2::error::ErrorContext<Self>
pub fn numrs2::NumRs2Error::category(&self) -> numrs2::error::ErrorCategory
pub fn numrs2::NumRs2Error::is_recoverable(&self) -> bool
pub fn numrs2::NumRs2Error::severity(&self) -> numrs2::error::ErrorSeverity
pub fn numrs2::NumRs2Error::with_context<C: core::convert::Into<numrs2::error::OperationContext>>(self, context: C) -> numrs2::error::ErrorContext<Self>
impl core::convert::From<std::io::error::Error> for numrs2::NumRs2Error
pub fn numrs2::NumRs2Error::from(err: std::io::error::Error) -> Self
pub enum numrs2::prelude::OptimizationType
pub numrs2::prelude::OptimizationType::AlignmentOptimization
pub numrs2::prelude::OptimizationType::AllocationCoalescing
pub numrs2::prelude::OptimizationType::AllocatorSwitch
pub numrs2::prelude::OptimizationType::ArenaOptimization
pub numrs2::prelude::OptimizationType::DefragmentationCompaction
pub numrs2::prelude::OptimizationType::PoolingOptimization
pub enum numrs2::prelude::ParallelizationThreshold
pub numrs2::prelude::ParallelizationThreshold::Adaptive
pub numrs2::prelude::ParallelizationThreshold::AutoTuning
pub numrs2::prelude::ParallelizationThreshold::Benchmarked
pub numrs2::prelude::ParallelizationThreshold::Fixed(usize)
pub enum numrs2::prelude::PlacementStrategy
pub numrs2::prelude::PlacementStrategy::Aligned(usize)
pub numrs2::prelude::PlacementStrategy::CacheAware
pub numrs2::prelude::PlacementStrategy::Default
pub numrs2::prelude::PlacementStrategy::NumaAware
pub numrs2::prelude::PlacementStrategy::Packed
pub enum numrs2::prelude::ResolvedIndex
pub numrs2::prelude::ResolvedIndex::Multiple(alloc::vec::Vec<usize>)
pub numrs2::prelude::ResolvedIndex::Single(usize)
pub enum numrs2::prelude::SchedulingStrategy
pub numrs2::prelude::SchedulingStrategy::Adaptive
pub numrs2::prelude::SchedulingStrategy::Dynamic
pub numrs2::prelude::SchedulingStrategy::Guided
pub numrs2::prelude::SchedulingStrategy::Static
pub numrs2::prelude::SchedulingStrategy::WorkStealing
pub enum numrs2::prelude::SerializeFormat
pub numrs2::prelude::SerializeFormat::Binary
pub numrs2::prelude::SerializeFormat::Csv
pub numrs2::prelude::SerializeFormat::Json
pub numrs2::prelude::SerializeFormat::Npy
pub numrs2::prelude::SerializeFormat::Npz
pub numrs2::prelude::SerializeFormat::Pickle
pub enum numrs2::prelude::SliceOrIndex
pub numrs2::prelude::SliceOrIndex::Index(usize)
pub numrs2::prelude::SliceOrIndex::Slice(usize, core::option::Option<usize>, core::option::Option<usize>)
impl numrs2::views::SliceOrIndex
pub fn numrs2::views::SliceOrIndex::to_ndarray_slice(&self) -> ndarray::slice::Slice
pub enum numrs2::prelude::SliceSpec
pub numrs2::prelude::SliceSpec::Ellipsis
pub numrs2::prelude::SliceSpec::Index(isize)
pub numrs2::prelude::SliceSpec::NewAxis
pub numrs2::prelude::SliceSpec::Range
pub numrs2::prelude::SliceSpec::Range::start: core::option::Option<isize>
pub numrs2::prelude::SliceSpec::Range::step: core::option::Option<isize>
pub numrs2::prelude::SliceSpec::Range::stop: core::option::Option<isize>
impl numrs2::array_ops::SliceSpec
pub fn numrs2::array_ops::SliceSpec::from(start: isize) -> Self
pub fn numrs2::array_ops::SliceSpec::from_to(start: isize, stop: isize) -> Self
pub fn numrs2::array_ops::SliceSpec::full() -> Self
pub fn numrs2::array_ops::SliceSpec::range(start: core::option::Option<isize>, stop: core::option::Option<isize>, step: core::option::Option<isize>) -> Self
pub fn numrs2::array_ops::SliceSpec::step(step: isize) -> Self
pub fn numrs2::array_ops::SliceSpec::to(stop: isize) -> Self
pub enum numrs2::prelude::SparseMatrixFormat
pub numrs2::prelude::SparseMatrixFormat::COO
pub numrs2::prelude::SparseMatrixFormat::CSC
pub numrs2::prelude::SparseMatrixFormat::CSR
pub numrs2::prelude::SparseMatrixFormat::DIA
pub enum numrs2::prelude::SplitArg
pub numrs2::prelude::SplitArg::Indices(alloc::vec::Vec<usize>)
pub numrs2::prelude::SplitArg::Sections(usize)
impl core::convert::From<&[usize]> for numrs2::array_ops::SplitArg
pub fn numrs2::array_ops::SplitArg::from(indices: &[usize]) -> Self
impl core::convert::From<alloc::vec::Vec<usize>> for numrs2::array_ops::SplitArg
pub fn numrs2::array_ops::SplitArg::from(indices: alloc::vec::Vec<usize>) -> Self
impl core::convert::From<usize> for numrs2::array_ops::SplitArg
pub fn numrs2::array_ops::SplitArg::from(sections: usize) -> Self
pub enum numrs2::prelude::StringElement
pub enum numrs2::prelude::StringElement
pub numrs2::prelude::StringElement::Fixed
pub numrs2::prelude::StringElement::Fixed
pub numrs2::prelude::StringElement::Fixed::data: alloc::vec::Vec<u8>
pub numrs2::prelude::StringElement::Fixed::data: alloc::vec::Vec<u8>
pub numrs2::prelude::StringElement::Fixed::max_len: usize
pub numrs2::prelude::StringElement::Fixed::max_len: usize
pub numrs2::prelude::StringElement::Unicode(alloc::string::String)
pub numrs2::prelude::StringElement::Unicode(alloc::string::String)
impl numrs2::array_ops::string_ops::StringElement
impl numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::as_str(&self) -> numrs2::Result<&str>
pub fn numrs2::array_ops::string_ops::StringElement::as_str(&self) -> numrs2::Result<&str>
pub fn numrs2::array_ops::string_ops::StringElement::capacity(&self) -> usize
pub fn numrs2::array_ops::string_ops::StringElement::capacity(&self) -> usize
pub fn numrs2::array_ops::string_ops::StringElement::fixed(s: &str, max_len: usize) -> Self
pub fn numrs2::array_ops::string_ops::StringElement::fixed(s: &str, max_len: usize) -> Self
pub fn numrs2::array_ops::string_ops::StringElement::is_empty(&self) -> numrs2::Result<bool>
pub fn numrs2::array_ops::string_ops::StringElement::is_empty(&self) -> numrs2::Result<bool>
pub fn numrs2::array_ops::string_ops::StringElement::len(&self) -> numrs2::Result<usize>
pub fn numrs2::array_ops::string_ops::StringElement::len(&self) -> numrs2::Result<usize>
pub fn numrs2::array_ops::string_ops::StringElement::to_string(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::array_ops::string_ops::StringElement::to_string(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::array_ops::string_ops::StringElement::unicode<S: core::convert::Into<alloc::string::String>>(s: S) -> Self
pub fn numrs2::array_ops::string_ops::StringElement::unicode<S: core::convert::Into<alloc::string::String>>(s: S) -> Self
impl core::cmp::Ord for numrs2::array_ops::string_ops::StringElement
impl core::cmp::Ord for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::cmp(&self, other: &Self) -> core::cmp::Ordering
pub fn numrs2::array_ops::string_ops::StringElement::cmp(&self, other: &Self) -> core::cmp::Ordering
impl core::cmp::PartialOrd for numrs2::array_ops::string_ops::StringElement
impl core::cmp::PartialOrd for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering>
pub fn numrs2::array_ops::string_ops::StringElement::partial_cmp(&self, other: &Self) -> core::option::Option<core::cmp::Ordering>
impl core::default::Default for numrs2::array_ops::string_ops::StringElement
impl core::default::Default for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::default() -> Self
pub fn numrs2::array_ops::string_ops::StringElement::default() -> Self
impl core::fmt::Display for numrs2::array_ops::string_ops::StringElement
impl core::fmt::Display for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub fn numrs2::array_ops::string_ops::StringElement::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add for numrs2::array_ops::string_ops::StringElement
impl core::ops::arith::Add for numrs2::array_ops::string_ops::StringElement
pub type numrs2::array_ops::string_ops::StringElement::Output = numrs2::array_ops::string_ops::StringElement
pub type numrs2::array_ops::string_ops::StringElement::Output = numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::add(self, other: Self) -> Self
pub fn numrs2::array_ops::string_ops::StringElement::add(self, other: Self) -> Self
impl num_traits::identities::Zero for numrs2::array_ops::string_ops::StringElement
impl num_traits::identities::Zero for numrs2::array_ops::string_ops::StringElement
pub fn numrs2::array_ops::string_ops::StringElement::is_zero(&self) -> bool
pub fn numrs2::array_ops::string_ops::StringElement::is_zero(&self) -> bool
pub fn numrs2::array_ops::string_ops::StringElement::zero() -> Self
pub fn numrs2::array_ops::string_ops::StringElement::zero() -> Self
pub enum numrs2::prelude::TaskPriority
pub numrs2::prelude::TaskPriority::Critical = 3
pub numrs2::prelude::TaskPriority::High = 2
pub numrs2::prelude::TaskPriority::Low = 0
pub numrs2::prelude::TaskPriority::Normal = 1
pub enum numrs2::prelude::TaskResult<T>
pub numrs2::prelude::TaskResult::Cancelled
pub numrs2::prelude::TaskResult::Error(alloc::string::String)
pub numrs2::prelude::TaskResult::Success(T)
pub enum numrs2::prelude::ThreadingRequirements
pub numrs2::prelude::ThreadingRequirements::LockFree
pub numrs2::prelude::ThreadingRequirements::MultiThreadedRead
pub numrs2::prelude::ThreadingRequirements::MultiThreadedReadWrite
pub numrs2::prelude::ThreadingRequirements::SingleThreaded
pub enum numrs2::prelude::WorkloadPartitioning
pub numrs2::prelude::WorkloadPartitioning::CacheOptimizedChunks
pub numrs2::prelude::WorkloadPartitioning::DynamicPartitioning
pub numrs2::prelude::WorkloadPartitioning::EqualChunks
pub numrs2::prelude::WorkloadPartitioning::PowerOfTwoChunks
pub numrs2::prelude::WorkloadPartitioning::VariableChunks
pub struct numrs2::prelude::AccessStats
pub numrs2::prelude::AccessStats::estimated_miss_rate: f64
pub numrs2::prelude::AccessStats::random_accesses: u64
pub numrs2::prelude::AccessStats::sequential_accesses: u64
pub numrs2::prelude::AccessStats::strided_accesses: u64
pub numrs2::prelude::AccessStats::total_accesses: u64
impl numrs2::memory_optimize::access_patterns::AccessStats
pub fn numrs2::memory_optimize::access_patterns::AccessStats::cache_efficiency(&self) -> f64
pub fn numrs2::memory_optimize::access_patterns::AccessStats::new() -> Self
pub fn numrs2::memory_optimize::access_patterns::AccessStats::record_random(&mut self)
pub fn numrs2::memory_optimize::access_patterns::AccessStats::record_sequential(&mut self)
pub fn numrs2::memory_optimize::access_patterns::AccessStats::record_strided(&mut self)
pub fn numrs2::memory_optimize::access_patterns::AccessStats::update_miss_rate(&mut self)
pub struct numrs2::prelude::AlignedAllocator
impl numrs2::memory_alloc::aligned::AlignedAllocator
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::alignment(&self) -> usize
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate_array<T>(&self, count: usize) -> core::option::Option<core::ptr::non_null::NonNull<T>>
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate_for_type<T>(&self) -> core::option::Option<core::ptr::non_null::NonNull<T>>
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::as_mut_slice<T>(&mut self, ptr: core::ptr::non_null::NonNull<T>, count: usize) -> &mut [T]
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::as_slice<T>(&self, ptr: core::ptr::non_null::NonNull<T>, count: usize) -> &[T]
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::create_array<T: core::marker::Copy>(&self, values: &[T]) -> core::option::Option<core::ptr::non_null::NonNull<T>>
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, size: usize)
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::deallocate_array<T>(&self, ptr: core::ptr::non_null::NonNull<T>, count: usize)
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::is_zero_initialized(&self) -> bool
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::new(config: numrs2::memory_alloc::aligned::AlignmentConfig) -> Self
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::aligned::AlignedAllocator
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::aligned::AlignedAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::aligned::AlignedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout)
pub struct numrs2::prelude::AlignmentConfig
pub numrs2::prelude::AlignmentConfig::alignment: usize
pub numrs2::prelude::AlignmentConfig::zero_init: bool
impl numrs2::memory_alloc::aligned::AlignmentConfig
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::cache_line() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::new(alignment: usize, zero_init: bool) -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::page() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::simd_128() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::simd_256() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::simd_512() -> Self
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::zeroed(self) -> Self
impl core::default::Default for numrs2::memory_alloc::aligned::AlignmentConfig
pub fn numrs2::memory_alloc::aligned::AlignmentConfig::default() -> Self
pub struct numrs2::prelude::AllocationRequirements
pub numrs2::prelude::AllocationRequirements::alignment: usize
pub numrs2::prelude::AllocationRequirements::frequency: numrs2::traits::AllocationFrequency
pub numrs2::prelude::AllocationRequirements::lifetime: numrs2::traits::AllocationLifetime
pub numrs2::prelude::AllocationRequirements::simd_usage: bool
pub numrs2::prelude::AllocationRequirements::size: usize
pub numrs2::prelude::AllocationRequirements::threading: numrs2::traits::ThreadingRequirements
impl numrs2::traits::AllocationRequirements
pub fn numrs2::traits::AllocationRequirements::for_array<T>(len: usize) -> Self
pub fn numrs2::traits::AllocationRequirements::for_simd_operation<T>(len: usize, alignment: usize) -> Self
pub fn numrs2::traits::AllocationRequirements::for_temporary_buffer(size: usize) -> Self
pub struct numrs2::prelude::AllocationStats
pub numrs2::prelude::AllocationStats::active_allocations: usize
pub numrs2::prelude::AllocationStats::allocation_count: usize
pub numrs2::prelude::AllocationStats::bytes_allocated: usize
pub numrs2::prelude::AllocationStats::bytes_deallocated: usize
pub numrs2::prelude::AllocationStats::deallocation_count: usize
pub numrs2::prelude::AllocationStats::peak_usage: usize
pub struct numrs2::prelude::AmortizationSchedule<T>
pub numrs2::prelude::AmortizationSchedule::balances: alloc::vec::Vec<T>
pub numrs2::prelude::AmortizationSchedule::interests: alloc::vec::Vec<T>
pub numrs2::prelude::AmortizationSchedule::payments: alloc::vec::Vec<T>
pub numrs2::prelude::AmortizationSchedule::periods: alloc::vec::Vec<usize>
pub numrs2::prelude::AmortizationSchedule::principals: alloc::vec::Vec<T>
impl<T: num_traits::float::Float + core::clone::Clone> numrs2::financial::AmortizationSchedule<T>
pub fn numrs2::financial::AmortizationSchedule<T>::total_interest(&self) -> T
pub fn numrs2::financial::AmortizationSchedule<T>::total_payments(&self) -> T
pub struct numrs2::prelude::ArenaAllocator
impl numrs2::memory_alloc::arena::ArenaAllocator
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate_aligned(&self, size: usize, alignment: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate_object<T>(&self) -> core::option::Option<core::ptr::non_null::NonNull<T>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::available_size(&self) -> usize
pub fn numrs2::memory_alloc::arena::ArenaAllocator::get_alignment(&self) -> usize
pub fn numrs2::memory_alloc::arena::ArenaAllocator::new(config: numrs2::memory_alloc::arena::ArenaConfig) -> Self
pub fn numrs2::memory_alloc::arena::ArenaAllocator::reset(&self)
pub fn numrs2::memory_alloc::arena::ArenaAllocator::scoped(&self) -> numrs2::memory_alloc::arena::ScopedArena
pub fn numrs2::memory_alloc::arena::ArenaAllocator::total_size(&self) -> usize
impl core::clone::Clone for numrs2::memory_alloc::arena::ArenaAllocator
pub fn numrs2::memory_alloc::arena::ArenaAllocator::clone(&self) -> Self
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::arena::ArenaAllocator
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::arena::ArenaAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::arena::ArenaAllocator::deallocate(&self, _ptr: core::ptr::non_null::NonNull<u8>, _layout: core::alloc::layout::Layout)
pub struct numrs2::prelude::ArenaConfig
pub numrs2::prelude::ArenaConfig::alignment: usize
pub numrs2::prelude::ArenaConfig::allow_growth: bool
pub numrs2::prelude::ArenaConfig::growth_factor: f64
pub numrs2::prelude::ArenaConfig::initial_size: usize
impl core::default::Default for numrs2::memory_alloc::arena::ArenaConfig
pub fn numrs2::memory_alloc::arena::ArenaConfig::default() -> Self
pub struct numrs2::prelude::Array<T>
impl numrs2::array::Array<bool>
pub fn numrs2::array::Array<bool>::logical_and(&self, other: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array::Array<bool>::logical_not(&self) -> numrs2::array::Array<bool>
pub fn numrs2::array::Array<bool>::logical_or(&self, other: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array::Array<bool>::logical_xor(&self, other: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
impl numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::dot_simd(&self, other: &Self) -> numrs2::Result<f64>
pub fn numrs2::array::Array<f64>::norm_l1_simd(&self) -> f64
pub fn numrs2::array::Array<f64>::norm_l2_simd(&self) -> f64
impl<T: core::clone::Clone + core::ops::arith::Add<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::add(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::add_broadcast(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: core::clone::Clone + core::ops::arith::Add<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::add_scalar(&self, scalar: T) -> Self
impl<T: core::clone::Clone + core::ops::arith::Div<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::divide(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::divide_broadcast(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: core::clone::Clone + core::ops::arith::Div<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::divide_scalar(&self, scalar: T) -> Self
impl<T: core::clone::Clone + core::ops::arith::Mul<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::multiply(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::multiply_broadcast(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: core::clone::Clone + core::ops::arith::Mul<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::multiply_scalar(&self, scalar: T) -> Self
impl<T: core::clone::Clone + core::ops::arith::Sub<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::subtract(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::subtract_broadcast(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
impl<T: core::clone::Clone + core::ops::arith::Sub<Output = T>> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::subtract_scalar(&self, scalar: T) -> Self
impl<T: core::clone::Clone + for<'a> serde_core::de::Deserialize<'a> + core::str::traits::FromStr> numrs2::array::Array<T> where <T as core::str::traits::FromStr>::Err: core::fmt::Debug
pub fn numrs2::array::Array<T>::from_file<P: core::convert::AsRef<std::path::Path>>(path: P, format: numrs2::io::SerializeFormat) -> numrs2::Result<Self>
pub fn numrs2::array::Array<T>::from_string(s: &str, format: numrs2::io::SerializeFormat) -> numrs2::Result<Self>
impl<T: core::clone::Clone + num_traits::identities::Zero> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::choose(&self, choices: &[&Self], mode: core::option::Option<&str>) -> numrs2::Result<Self> where T: core::clone::Clone + alloc::string::ToString
pub fn numrs2::array::Array<T>::compress<U>(&self, condition: &numrs2::array::Array<U>, axis: core::option::Option<usize>) -> numrs2::Result<Self> where T: core::clone::Clone + alloc::string::ToString, U: core::clone::Clone + alloc::string::ToString
pub fn numrs2::array::Array<T>::diag(&self) -> numrs2::Result<Self> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::diagonal(&self, offset: isize, axis1: core::option::Option<usize>, axis2: core::option::Option<usize>) -> numrs2::Result<Self> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::get(&self, indices: &[usize]) -> numrs2::Result<T>
pub fn numrs2::array::Array<T>::index(&self, index_specs: &[numrs2::indexing::IndexSpec]) -> numrs2::Result<Self> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::set_mask(&mut self, mask: &numrs2::array::Array<bool>, values: &numrs2::array::Array<T>) -> numrs2::Result<()> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::take(&self, indices: &Self, axis: core::option::Option<usize>) -> numrs2::Result<Self> where T: core::clone::Clone + alloc::string::ToString
impl<T: core::clone::Clone + serde_core::ser::Serialize> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::to_file<P: core::convert::AsRef<std::path::Path>>(&self, path: P, format: numrs2::io::SerializeFormat) -> numrs2::Result<()>
pub fn numrs2::array::Array<T>::to_row_vectors(&self) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<T>>>
pub fn numrs2::array::Array<T>::to_string(&self, format: numrs2::io::SerializeFormat) -> numrs2::Result<alloc::string::String>
impl<T: core::clone::Clone> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::array(&self) -> &ndarray::Array<T, ndarray::aliases::IxDyn>
pub fn numrs2::array::Array<T>::array_mut(&mut self) -> &mut ndarray::Array<T, ndarray::aliases::IxDyn>
pub fn numrs2::array::Array<T>::base(&self) -> core::option::Option<&numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::broadcast_op<F, U, V>(&self, other: &numrs2::array::Array<U>, op: F) -> numrs2::Result<numrs2::array::Array<V>> where T: core::clone::Clone, U: core::clone::Clone, V: core::clone::Clone, F: core::ops::function::Fn(&numrs2::array::Array<T>, &numrs2::array::Array<U>) -> numrs2::array::Array<V>
pub fn numrs2::array::Array<T>::broadcast_shape(a_shape: &[usize], b_shape: &[usize]) -> numrs2::Result<alloc::vec::Vec<usize>>
pub fn numrs2::array::Array<T>::broadcast_to(&self, shape: &[usize]) -> numrs2::Result<Self> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::byte_strides(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::array::Array<T>::create_diagonal_matrix(v: &numrs2::array::Array<T>, k: isize) -> Self where T: num_traits::identities::Zero + core::clone::Clone
pub fn numrs2::array::Array<T>::create_diagonal_matrix_helper(v: &numrs2::array::Array<T>, k: isize) -> Self where T: num_traits::identities::Zero + core::clone::Clone
pub fn numrs2::array::Array<T>::diagflat(v: &numrs2::array::Array<T>, k: isize) -> Self where T: num_traits::identities::Zero + core::clone::Clone
pub fn numrs2::array::Array<T>::empty(shape: &[usize]) -> Self where T: core::default::Default + core::clone::Clone
pub fn numrs2::array::Array<T>::empty_like<U>(other: &numrs2::array::Array<U>) -> Self where T: core::default::Default + core::clone::Clone, U: core::clone::Clone
pub fn numrs2::array::Array<T>::empty_like_with<U>(other: &numrs2::array::Array<U>, shape: core::option::Option<&[usize]>) -> Self where T: core::default::Default + core::clone::Clone, U: core::clone::Clone
pub fn numrs2::array::Array<T>::eye(n_rows: usize, n_cols: usize, k: isize) -> Self where T: num_traits::identities::Zero + num_traits::identities::One + core::clone::Clone
pub fn numrs2::array::Array<T>::eye_square(n: usize) -> Self where T: num_traits::identities::Zero + num_traits::identities::One + core::clone::Clone
pub fn numrs2::array::Array<T>::flags(&self) -> numrs2::array::ArrayFlags
pub fn numrs2::array::Array<T>::flatten(&self, order: core::option::Option<&str>) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::from_ndarray(array: ndarray::Array<T, ndarray::aliases::IxDyn>) -> Self
pub fn numrs2::array::Array<T>::from_vec(vec: alloc::vec::Vec<T>) -> Self
pub fn numrs2::array::Array<T>::full(shape: &[usize], value: T) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::identity(n: usize) -> Self where T: num_traits::identities::Zero + num_traits::identities::One + core::clone::Clone
pub fn numrs2::array::Array<T>::itemsize(&self) -> usize
pub fn numrs2::array::Array<T>::map<F, U>(&self, f: F) -> numrs2::array::Array<U> where U: core::clone::Clone, F: core::ops::function::Fn(T) -> U, T: core::clone::Clone
pub fn numrs2::array::Array<T>::nbytes(&self) -> usize
pub fn numrs2::array::Array<T>::ndarray_view(&self) -> ndarray::ArrayView<'_, T, ndarray::aliases::IxDyn>
pub fn numrs2::array::Array<T>::ndarray_view_mut(&mut self) -> &mut Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::ndim(&self) -> usize
pub fn numrs2::array::Array<T>::ones(shape: &[usize]) -> Self where T: num_traits::identities::One + core::clone::Clone
pub fn numrs2::array::Array<T>::ones_like<U>(other: &numrs2::array::Array<U>) -> Self where T: num_traits::identities::One + core::clone::Clone, U: core::clone::Clone
pub fn numrs2::array::Array<T>::ones_like_with<U>(other: &numrs2::array::Array<U>, shape: core::option::Option<&[usize]>) -> Self where T: num_traits::identities::One + core::clone::Clone, U: core::clone::Clone
pub fn numrs2::array::Array<T>::owns_data(&self) -> bool
pub fn numrs2::array::Array<T>::par_map<F, U>(&self, f: F) -> numrs2::array::Array<U> where T: core::marker::Send + core::marker::Sync + core::clone::Clone, U: core::marker::Send + core::clone::Clone, F: core::ops::function::Fn(T) -> U + core::marker::Send + core::marker::Sync
pub fn numrs2::array::Array<T>::reshape(&self, shape: &[usize]) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::reshape_with(&self, shape: &[usize], copy: bool) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::reshape_with_option(&self, shape: &[usize], copy: bool) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::scalar_div(&self, scalar: T) -> Self where T: core::clone::Clone + core::ops::arith::Div<Output = T>
pub fn numrs2::array::Array<T>::scalar_mul(&self, scalar: T) -> Self where T: core::clone::Clone + core::ops::arith::Mul<Output = T>
pub fn numrs2::array::Array<T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::array::Array<T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::array::Array<T>::size(&self) -> usize
pub fn numrs2::array::Array<T>::slice(&self, axis: usize, index: usize) -> numrs2::Result<Self> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::strides(&self) -> alloc::vec::Vec<isize>
pub fn numrs2::array::Array<T>::sum_all(&self) -> T where T: core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero
pub fn numrs2::array::Array<T>::sum_axis(&self, axis: usize) -> numrs2::Result<Self> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero
pub fn numrs2::array::Array<T>::to_vec(&self) -> alloc::vec::Vec<T> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::transpose(&self) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::transpose_axis(&self, axis1: usize, axis2: usize) -> Self where T: core::clone::Clone
pub fn numrs2::array::Array<T>::tri(n: usize, m: core::option::Option<usize>, k: isize, value: core::option::Option<T>) -> Self where T: num_traits::identities::Zero + num_traits::identities::One + core::clone::Clone
pub fn numrs2::array::Array<T>::tril(&self, k: isize) -> Self where T: num_traits::identities::Zero + core::clone::Clone
pub fn numrs2::array::Array<T>::triu(&self, k: isize) -> Self where T: num_traits::identities::Zero + core::clone::Clone
pub fn numrs2::array::Array<T>::view_2d(&self) -> numrs2::Result<ndarray::aliases::ArrayView2<'_, T>> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::zeros(shape: &[usize]) -> Self where T: num_traits::identities::Zero + core::clone::Clone
pub fn numrs2::array::Array<T>::zeros_like<U>(other: &numrs2::array::Array<U>) -> Self where T: num_traits::identities::Zero + core::clone::Clone, U: core::clone::Clone
pub fn numrs2::array::Array<T>::zeros_like_with<U>(other: &numrs2::array::Array<U>, shape: core::option::Option<&[usize]>) -> Self where T: num_traits::identities::Zero + core::clone::Clone, U: core::clone::Clone
pub fn numrs2::array::Array<T>::zip_with<F, U, V>(&self, other: &numrs2::array::Array<U>, f: F) -> numrs2::Result<numrs2::array::Array<V>> where T: core::clone::Clone, U: core::clone::Clone, V: core::clone::Clone, F: core::ops::function::Fn(T, U) -> V
impl<T: core::clone::Clone> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::broadcast_view(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::create_strided_view(&self, shape: alloc::vec::Vec<usize>, strides: alloc::vec::Vec<isize>) -> numrs2::views::StridedArrayView<'_, T>
pub fn numrs2::array::Array<T>::diagonal_view(&self, offset: isize) -> numrs2::Result<numrs2::views::DiagonalView<'_, T>>
pub fn numrs2::array::Array<T>::sliced_view(&self, slices: &[numrs2::views::SliceOrIndex]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::strided_array_view(&self, strides: &[isize]) -> numrs2::Result<numrs2::views::StridedArrayView<'_, T>>
pub fn numrs2::array::Array<T>::strided_view(&self, strides: &[isize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::array::Array<T>::transposed_view(&self) -> numrs2::views::ArrayView<'_, T>
pub fn numrs2::array::Array<T>::view(&self) -> numrs2::views::ArrayView<'_, T>
pub fn numrs2::array::Array<T>::view_mut(&mut self) -> numrs2::views::ArrayViewMut<'_, T>
pub fn numrs2::array::Array<T>::window_view(&self, window_shape: &[usize], step: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::views::WindowView<'_, T>>
impl<T: core::clone::Clone> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::is_c_contiguous(&self) -> bool
pub fn numrs2::array::Array<T>::is_contiguous(&self) -> bool
pub fn numrs2::array::Array<T>::is_empty(&self) -> bool
pub fn numrs2::array::Array<T>::is_f_contiguous(&self) -> bool
pub fn numrs2::array::Array<T>::len(&self) -> usize
pub fn numrs2::array::Array<T>::to_c_layout(&self) -> Self
pub fn numrs2::array::Array<T>::to_f_layout(&self) -> Self
impl<T: core::clone::Clone> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::slice_view(&self, axis: usize, index: usize) -> numrs2::Result<numrs2::views::ArrayView<'_, T>>
impl<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::ops::arith::AddAssign + core::ops::arith::MulAssign + core::ops::arith::DivAssign + core::ops::arith::SubAssign + core::fmt::Display> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cond(&self) -> core::option::Option<T>
pub fn numrs2::array::Array<T>::is_well_conditioned(&self) -> bool
pub fn numrs2::array::Array<T>::rcond(&self) -> core::option::Option<T>
impl<T> numrs2::array::Array<T> where T: core::clone::Clone + core::cmp::PartialEq
pub fn numrs2::array::Array<T>::equal(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array::Array<T>::not_equal(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
impl<T> numrs2::array::Array<T> where T: core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::array::Array<T>::greater_equal(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array::Array<T>::greater_than(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array::Array<T>::less_equal(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::array::Array<T>::less_than(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
impl<T> numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + num_traits::identities::Zero
pub fn numrs2::array::Array<T>::dot(&self, other: &Self) -> numrs2::Result<T>
pub fn numrs2::array::Array<T>::matmul(&self, other: &Self) -> numrs2::Result<Self>
impl<T> numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero + core::ops::arith::Mul<Output = T> + num_traits::identities::One + 'static
pub fn numrs2::array::Array<T>::product(&self) -> T
pub fn numrs2::array::Array<T>::sum(&self) -> T
impl<T> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::cast::NumCast
pub fn numrs2::array::Array<T>::add_mixed<V, U>(&self, other: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<V>> where T: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, U: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, V: core::clone::Clone + num_traits::cast::NumCast + core::ops::arith::Add<Output = V> + core::fmt::Debug
pub fn numrs2::array::Array<T>::divide_mixed<V, U>(&self, other: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<V>> where T: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, U: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, V: core::clone::Clone + num_traits::cast::NumCast + core::ops::arith::Div<Output = V> + core::fmt::Debug
pub fn numrs2::array::Array<T>::multiply_mixed<V, U>(&self, other: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<V>> where T: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, U: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, V: core::clone::Clone + num_traits::cast::NumCast + core::ops::arith::Mul<Output = V> + core::fmt::Debug
pub fn numrs2::array::Array<T>::subtract_mixed<V, U>(&self, other: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<V>> where T: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, U: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, V: core::clone::Clone + num_traits::cast::NumCast + core::ops::arith::Sub<Output = V> + core::fmt::Debug
impl<T> numrs2::array::Array<T> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::array::Array<T>::apply_window(&self, window_type: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::fft(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<T>::fft2(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<T>::fftshift_real(&self) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::ifftshift_real(&self) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::power_spectrum(&self) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::rfft(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<T>::rfft2(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
impl<T> numrs2::array::Array<T> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::array::Array<T>::apply_window_enhanced(&self, window_type: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::fft_any_size(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<T>::real_fft_optimized(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<T>::stockwell_transform(&self, min_freq: core::option::Option<usize>, max_freq: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
impl<T> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::astype<U>(&self) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + numrs2::conversions::ConvertibleTo<U> + core::fmt::Debug, U: core::clone::Clone
pub fn numrs2::array::Array<T>::downcast<U>(&self) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug, U: core::clone::Clone + num_traits::cast::NumCast + core::cmp::PartialOrd + core::fmt::Debug
pub fn numrs2::array::Array<T>::to_complex<U>(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<U>>> where T: core::clone::Clone + num_traits::cast::NumCast, U: core::clone::Clone + num_traits::cast::NumCast + num_traits::identities::Zero
pub fn numrs2::array::Array<T>::upcast<U>(&self) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + num_traits::cast::AsPrimitive<U>, U: core::clone::Clone + 'static + core::marker::Copy
impl<T> numrs2::array::Array<num_complex::Complex<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::array::Array<num_complex::Complex<T>>::fftshift_complex(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::ifft(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::ifft2(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::ifftshift_complex(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::irfft(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::irfft2(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
impl numrs2::simd::SimdOps<f32> for numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_add(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_add_scalar(&self, scalar: f32) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_div(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_div_scalar(&self, scalar: f32) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_dot(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<f32>
pub fn numrs2::array::Array<f32>::simd_fma(&self, mul: &numrs2::array::Array<f32>, add: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_mean(&self) -> f32
pub fn numrs2::array::Array<f32>::simd_mul(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_mul_scalar(&self, scalar: f32) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_sub(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_sub_scalar(&self, scalar: f32) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_sum(&self) -> f32
impl numrs2::simd::SimdOps<f64> for numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::simd_add(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_add_scalar(&self, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::simd_div(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_div_scalar(&self, scalar: f64) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_dot(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<f64>
pub fn numrs2::array::Array<f64>::simd_fma(&self, mul: &numrs2::array::Array<f64>, add: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_mean(&self) -> f64
pub fn numrs2::array::Array<f64>::simd_mul(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_mul_scalar(&self, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::simd_sub(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_sub_scalar(&self, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::simd_sum(&self) -> f64
impl numrs2::simd_optimize::simd_traits::SimdArrayOps for numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_add(&self, other: &Self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_copy(&self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_dot(&self, other: &Self) -> numrs2::Result<f32>
pub fn numrs2::array::Array<f32>::simd_exp(&self) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_log(&self) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_matmul(&self, other: &Self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_mul(&self, other: &Self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_sin_cos(&self) -> (numrs2::array::Array<f32>, numrs2::array::Array<f32>)
pub fn numrs2::array::Array<f32>::simd_sum(&self) -> f32
impl<'b, T> core::ops::arith::Add<&'b numrs2::array::Array<T>> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::add(self, other: &'b numrs2::array::Array<T>) -> Self::Output
impl<'b, T> core::ops::arith::Div<&'b numrs2::array::Array<T>> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::div(self, other: &'b numrs2::array::Array<T>) -> Self::Output
impl<'b, T> core::ops::arith::Mul<&'b numrs2::array::Array<T>> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::mul(self, other: &'b numrs2::array::Array<T>) -> Self::Output
impl<'b, T> core::ops::arith::Rem<&'b numrs2::array::Array<T>> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Rem<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::rem(self, other: &'b numrs2::array::Array<T>) -> Self::Output
impl<'b, T> core::ops::arith::Sub<&'b numrs2::array::Array<T>> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::sub(self, other: &'b numrs2::array::Array<T>) -> Self::Output
impl<T: core::clone::Clone> core::convert::From<numrs2::array::Array<T>> for numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::from(arr: numrs2::array::Array<T>) -> Self
impl<T: core::clone::Clone> core::convert::From<numrs2::shared_array::SharedArray<T>> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::from(shared: numrs2::shared_array::SharedArray<T>) -> Self
impl<T: core::clone::Clone> numrs2::expr::LazyEval<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::lazy(&self) -> numrs2::expr::ArrayExpr<'_, T>
impl<T: core::fmt::Debug + core::clone::Clone> core::fmt::Debug for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::fmt::Display> core::fmt::Display for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: num_traits::float::Float + core::clone::Clone + 'static> numrs2::math::ElementWiseMath<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::abs(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::acos(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::acosh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::asin(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::asinh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::atan(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::atan2(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::atanh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cbrt(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::ceil(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::clip(&self, min: T, max: T) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cos(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cosh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::degrees(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::exp(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::expm1(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::floor(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::hypot(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log10(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log1p(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log2(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::logaddexp(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::logaddexp2(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::pow(&self, n: T) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::radians(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::round(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::safe_atan2(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::safe_hypot(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::safe_logaddexp(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::safe_logaddexp2(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::sign(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sin(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sinh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sqrt(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::tan(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::tanh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::trunc(&self) -> numrs2::array::Array<T>
impl<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + 'static> numrs2::linalg::vector_ops::RealVectorDotProduct<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::vdot(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<T>
impl<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug> numrs2::linalg::vector_ops::ComplexVectorDotProduct<T> for numrs2::array::Array<num_complex::Complex<T>>
pub fn numrs2::array::Array<num_complex::Complex<T>>::vdot(&self, other: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<num_complex::Complex<T>>
impl<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync + 'static> numrs2::stats::Statistics<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::max(&self) -> T
pub fn numrs2::array::Array<T>::mean(&self) -> T
pub fn numrs2::array::Array<T>::min(&self) -> T
pub fn numrs2::array::Array<T>::percentile(&self, q: T) -> T
pub fn numrs2::array::Array<T>::std(&self) -> T
pub fn numrs2::array::Array<T>::var(&self) -> T
impl<T> core::convert::TryFrom<numrs2::array::Array<T>> for numrs2::matrix::Matrix<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub type numrs2::matrix::Matrix<T>::Error = numrs2::NumRs2Error
pub fn numrs2::matrix::Matrix<T>::try_from(array: numrs2::array::Array<T>) -> numrs2::Result<Self>
impl<T> core::ops::arith::Add for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::add(self, other: numrs2::array::Array<T>) -> Self::Output
impl<T> core::ops::arith::Add<T> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::add(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Add<T> for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::add(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Div for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::div(self, other: numrs2::array::Array<T>) -> Self::Output
impl<T> core::ops::arith::Div<T> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::div(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Div<T> for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::div(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Mul for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::mul(self, other: numrs2::array::Array<T>) -> Self::Output
impl<T> core::ops::arith::Mul<T> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::mul(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Mul<T> for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::mul(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Neg for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Neg<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::neg(self) -> Self::Output
impl<T> core::ops::arith::Neg for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Neg<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::neg(self) -> Self::Output
impl<T> core::ops::arith::Rem for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Rem<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::rem(self, other: numrs2::array::Array<T>) -> Self::Output
impl<T> core::ops::arith::Sub for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sub(self, other: numrs2::array::Array<T>) -> Self::Output
impl<T> core::ops::arith::Sub<T> for &numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T>
pub type &numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn &numrs2::array::Array<T>::sub(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Sub<T> for numrs2::array::Array<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T>
pub type numrs2::array::Array<T>::Output = numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sub(self, scalar: T) -> Self::Output
impl<T> numrs2::axis_ops::AxisOps<T> for numrs2::array::Array<T> where T: core::clone::Clone + core::cmp::PartialOrd + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::cast::NumCast + core::fmt::Debug
pub fn numrs2::array::Array<T>::argmax_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array::Array<T>::argmin_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array::Array<T>::cumprod_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::array::Array<T>::cumsum_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::max_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::mean_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::min_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::prod_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::array::Array<T>::std_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float
pub fn numrs2::array::Array<T>::sum_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::var_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float
pub struct numrs2::prelude::ArrayExpr<'a, T: core::clone::Clone>
impl<'a, T: core::clone::Clone> numrs2::expr::ArrayExpr<'a, T>
pub fn numrs2::expr::ArrayExpr<'a, T>::new(array: &'a numrs2::array::Array<T>) -> Self
impl<'a, T: core::clone::Clone> numrs2::expr::Expr<T> for numrs2::expr::ArrayExpr<'a, T>
pub fn numrs2::expr::ArrayExpr<'a, T>::eval(&self) -> numrs2::array::Array<T>
pub fn numrs2::expr::ArrayExpr<'a, T>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::ArrayExpr<'a, T>::shape(&self) -> &[usize]
pub fn numrs2::expr::ArrayExpr<'a, T>::size(&self) -> usize
impl<'a> numrs2::expr::SimdEval<f64> for numrs2::expr::ArrayExpr<'a, f64>
pub struct numrs2::prelude::ArrayRequirements(_)
impl numrs2::array_ops::ArrayRequirements
pub const numrs2::array_ops::ArrayRequirements::CONTIGUOUS: Self
pub const numrs2::array_ops::ArrayRequirements::C_LAYOUT: Self
pub const numrs2::array_ops::ArrayRequirements::F_LAYOUT: Self
pub const numrs2::array_ops::ArrayRequirements::OWNDATA: Self
pub const numrs2::array_ops::ArrayRequirements::WRITEABLE: Self
pub fn numrs2::array_ops::ArrayRequirements::contains(&self, other: Self) -> bool
pub fn numrs2::array_ops::ArrayRequirements::empty() -> Self
pub fn numrs2::array_ops::ArrayRequirements::is_empty(&self) -> bool
impl core::ops::bit::BitAnd for numrs2::array_ops::ArrayRequirements
pub type numrs2::array_ops::ArrayRequirements::Output = numrs2::array_ops::ArrayRequirements
pub fn numrs2::array_ops::ArrayRequirements::bitand(self, rhs: Self) -> Self
impl core::ops::bit::BitOr for numrs2::array_ops::ArrayRequirements
pub type numrs2::array_ops::ArrayRequirements::Output = numrs2::array_ops::ArrayRequirements
pub fn numrs2::array_ops::ArrayRequirements::bitor(self, rhs: Self) -> Self
pub struct numrs2::prelude::ArrayView<'a, T>
pub struct numrs2::prelude::ArrayView<'a, T>
impl<'a, T: 'a> numrs2::views::ArrayView<'a, T>
pub fn numrs2::views::ArrayView<'a, T>::from_ndarray_view(view: ndarray::ArrayView<'a, T, ndarray::aliases::IxDyn>) -> Self
pub fn numrs2::views::ArrayView<'a, T>::get(&self, indices: &[usize]) -> numrs2::Result<T> where T: core::clone::Clone
pub fn numrs2::views::ArrayView<'a, T>::map<F, U>(&self, f: F) -> numrs2::array::Array<U> where F: core::ops::function::Fn(&T) -> U, U: core::clone::Clone
pub fn numrs2::views::ArrayView<'a, T>::ndim(&self) -> usize
pub fn numrs2::views::ArrayView<'a, T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::views::ArrayView<'a, T>::size(&self) -> usize
pub fn numrs2::views::ArrayView<'a, T>::slice_axis(&'a self, axis: ndarray::dimension::axis::Axis, indices: ndarray::slice::Slice) -> numrs2::views::ArrayView<'a, T>
pub fn numrs2::views::ArrayView<'a, T>::t(&'a self) -> numrs2::views::ArrayView<'a, T>
pub fn numrs2::views::ArrayView<'a, T>::to_owned(&self) -> numrs2::array::Array<T> where T: core::clone::Clone
pub fn numrs2::views::ArrayView<'a, T>::to_vec(&self) -> alloc::vec::Vec<T> where T: core::clone::Clone
pub fn numrs2::views::ArrayView<'a, T>::view(&self) -> &ndarray::ArrayView<'a, T, ndarray::aliases::IxDyn>
impl<'a, T> numrs2::arrays::ArrayView<'a, T>
pub fn numrs2::arrays::ArrayView<'a, T>::from_data(data: &'a [T], shape: numrs2::arrays::Shape) -> numrs2::Result<Self>
pub fn numrs2::arrays::ArrayView<'a, T>::get(&self, indices: &[usize]) -> numrs2::Result<&T>
pub fn numrs2::arrays::ArrayView<'a, T>::is_c_contiguous(&self) -> bool
pub fn numrs2::arrays::ArrayView<'a, T>::is_f_contiguous(&self) -> bool
pub fn numrs2::arrays::ArrayView<'a, T>::new(data: &'a [T], shape: numrs2::arrays::Shape, strides: alloc::vec::Vec<usize>, offset: usize) -> numrs2::Result<Self>
pub fn numrs2::arrays::ArrayView<'a, T>::reshape(&self, new_shape: numrs2::arrays::Shape) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>>
pub fn numrs2::arrays::ArrayView<'a, T>::shape(&self) -> &numrs2::arrays::Shape
pub fn numrs2::arrays::ArrayView<'a, T>::slice(&self, indices: &[numrs2::arrays::IndexSpec]) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>>
pub fn numrs2::arrays::ArrayView<'a, T>::strides(&self) -> &[usize]
pub fn numrs2::arrays::ArrayView<'a, T>::transpose(&self, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<numrs2::arrays::ArrayView<'a, T>>
impl<'a, T> numrs2::views::ArrayView<'a, T> where T: 'a + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug
pub fn numrs2::views::ArrayView<'a, T>::astype<U>(&self) -> numrs2::Result<numrs2::array::Array<U>> where U: core::clone::Clone + num_traits::cast::NumCast
pub fn numrs2::views::ArrayView<'a, T>::to_complex<U>(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<U>>> where U: core::clone::Clone + num_traits::cast::NumCast + num_traits::identities::Zero
impl<T: core::clone::Clone> numrs2::arrays::ArrayView<'_, T>
pub fn numrs2::arrays::ArrayView<'_, T>::to_vec(&self) -> alloc::vec::Vec<T>
impl<'a, T> core::ops::arith::Add for &numrs2::views::ArrayView<'a, T> where T: 'a + core::clone::Clone + core::ops::arith::Add<Output = T>
pub type &numrs2::views::ArrayView<'a, T>::Output = numrs2::array::Array<T>
pub fn &numrs2::views::ArrayView<'a, T>::add(self, rhs: &numrs2::views::ArrayView<'a, T>) -> Self::Output
impl<'a, T> core::ops::arith::Div for &numrs2::views::ArrayView<'a, T> where T: 'a + core::clone::Clone + core::ops::arith::Div<Output = T>
pub type &numrs2::views::ArrayView<'a, T>::Output = numrs2::array::Array<T>
pub fn &numrs2::views::ArrayView<'a, T>::div(self, rhs: &numrs2::views::ArrayView<'a, T>) -> Self::Output
impl<'a, T> core::ops::arith::Mul for &numrs2::views::ArrayView<'a, T> where T: 'a + core::clone::Clone + core::ops::arith::Mul<Output = T>
pub type &numrs2::views::ArrayView<'a, T>::Output = numrs2::array::Array<T>
pub fn &numrs2::views::ArrayView<'a, T>::mul(self, rhs: &numrs2::views::ArrayView<'a, T>) -> Self::Output
impl<'a, T> core::ops::arith::Sub for &numrs2::views::ArrayView<'a, T> where T: 'a + core::clone::Clone + core::ops::arith::Sub<Output = T>
pub type &numrs2::views::ArrayView<'a, T>::Output = numrs2::array::Array<T>
pub fn &numrs2::views::ArrayView<'a, T>::sub(self, rhs: &numrs2::views::ArrayView<'a, T>) -> Self::Output
pub struct numrs2::prelude::ArrayViewMut<'a, T>
impl<'a, T: 'a> numrs2::views::ArrayViewMut<'a, T>
pub fn numrs2::views::ArrayViewMut<'a, T>::from_ndarray_view_mut(view: ndarray::ArrayViewMut<'a, T, ndarray::aliases::IxDyn>) -> Self
pub fn numrs2::views::ArrayViewMut<'a, T>::get_mut(&mut self, indices: &[usize]) -> numrs2::Result<&mut T>
pub fn numrs2::views::ArrayViewMut<'a, T>::ndim(&self) -> usize
pub fn numrs2::views::ArrayViewMut<'a, T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()> where T: core::clone::Clone
pub fn numrs2::views::ArrayViewMut<'a, T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::views::ArrayViewMut<'a, T>::size(&self) -> usize
pub fn numrs2::views::ArrayViewMut<'a, T>::slice_axis_mut(&mut self, axis: ndarray::dimension::axis::Axis, indices: ndarray::slice::Slice) -> numrs2::views::ArrayViewMut<'_, T>
pub fn numrs2::views::ArrayViewMut<'a, T>::to_owned(&self) -> numrs2::array::Array<T> where T: core::clone::Clone
pub fn numrs2::views::ArrayViewMut<'a, T>::view_mut(&self) -> &ndarray::ArrayViewMut<'a, T, ndarray::aliases::IxDyn>
pub struct numrs2::prelude::BandedMatrix<T>
impl<T> numrs2::matrix::BandedMatrix<T> where T: core::clone::Clone + core::default::Default + num_traits::identities::Zero + core::cmp::PartialEq + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::matrix::BandedMatrix<T>::matvec(&self, vec: &[T]) -> numrs2::Result<alloc::vec::Vec<T>>
impl<T> numrs2::matrix::BandedMatrix<T> where T: core::clone::Clone + core::default::Default + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::matrix::BandedMatrix<T>::band_width(&self) -> usize
pub fn numrs2::matrix::BandedMatrix<T>::diagonal(&self) -> alloc::vec::Vec<T>
pub fn numrs2::matrix::BandedMatrix<T>::from_array(array: &numrs2::array::Array<T>, sub_diagonals: usize, super_diagonals: usize) -> numrs2::Result<Self>
pub fn numrs2::matrix::BandedMatrix<T>::get(&self, i: usize, j: usize) -> numrs2::Result<T>
pub fn numrs2::matrix::BandedMatrix<T>::is_in_band(&self, i: usize, j: usize) -> bool
pub fn numrs2::matrix::BandedMatrix<T>::is_square(&self) -> bool
pub fn numrs2::matrix::BandedMatrix<T>::ncols(&self) -> usize
pub fn numrs2::matrix::BandedMatrix<T>::new(rows: usize, cols: usize, sub_diagonals: usize, super_diagonals: usize) -> Self
pub fn numrs2::matrix::BandedMatrix<T>::nrows(&self) -> usize
pub fn numrs2::matrix::BandedMatrix<T>::set(&mut self, i: usize, j: usize, value: T) -> numrs2::Result<()>
pub fn numrs2::matrix::BandedMatrix<T>::sub_diagonals(&self) -> usize
pub fn numrs2::matrix::BandedMatrix<T>::super_diagonals(&self) -> usize
pub fn numrs2::matrix::BandedMatrix<T>::to_array(&self) -> numrs2::array::Array<T>
impl<T> core::fmt::Display for numrs2::matrix::BandedMatrix<T> where T: core::clone::Clone + core::fmt::Display + core::default::Default + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::matrix::BandedMatrix<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::prelude::BandwidthEstimate
pub numrs2::prelude::BandwidthEstimate::cache_friendly: bool
pub numrs2::prelude::BandwidthEstimate::estimated_time_ns: u64
pub numrs2::prelude::BandwidthEstimate::recommended_blocking: bool
pub numrs2::prelude::BandwidthEstimate::total_bytes: usize
pub struct numrs2::prelude::BandwidthOptimizer
impl numrs2::algorithms::cache_aware::BandwidthOptimizer
pub fn numrs2::algorithms::cache_aware::BandwidthOptimizer::estimate_bandwidth<T>(&self, operation: numrs2::algorithms::cache_aware::MemoryOperation<T>) -> numrs2::algorithms::cache_aware::BandwidthEstimate
pub fn numrs2::algorithms::cache_aware::BandwidthOptimizer::new(cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub struct numrs2::prelude::BinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::Expr<T>, R: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
impl<T, L, R, F> numrs2::expr::BinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::Expr<T>, R: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::new(left: L, right: R, op: F) -> numrs2::Result<Self>
impl<L, R, F> numrs2::expr::SimdEval<f64> for numrs2::expr::BinaryExpr<f64, L, R, F> where L: numrs2::expr::Expr<f64>, R: numrs2::expr::Expr<f64>, F: core::ops::function::Fn(f64, f64) -> f64
impl<T, L, R, F> numrs2::expr::Expr<T> for numrs2::expr::BinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::Expr<T>, R: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::shape(&self) -> &[usize]
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::size(&self) -> usize
pub struct numrs2::prelude::BinaryUfunc<F> where F: core::ops::function::Fn(f64, f64) -> f64
impl<F> numrs2::ufuncs::BinaryUfunc<F> where F: core::ops::function::Fn(f64, f64) -> f64
pub fn numrs2::ufuncs::BinaryUfunc<F>::call(&self, a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::BinaryUfunc<F>::call_scalar_left(&self, a: f64, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::BinaryUfunc<F>::call_scalar_right(&self, a: &numrs2::array::Array<f64>, b: f64) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::BinaryUfunc<F>::new(func: F, name: &'static str) -> Self
impl<F> core::fmt::Debug for numrs2::ufuncs::BinaryUfunc<F> where F: core::ops::function::Fn(f64, f64) -> f64
pub fn numrs2::ufuncs::BinaryUfunc<F>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::prelude::Block
pub numrs2::prelude::Block::end: usize
pub numrs2::prelude::Block::start: usize
impl numrs2::memory_optimize::access_patterns::Block
pub fn numrs2::memory_optimize::access_patterns::Block::is_empty(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::Block::iter(&self) -> core::ops::range::Range<usize>
pub fn numrs2::memory_optimize::access_patterns::Block::len(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::Block::new(start: usize, end: usize) -> Self
pub struct numrs2::prelude::BlockedIterator
impl numrs2::memory_optimize::access_patterns::BlockedIterator
pub fn numrs2::memory_optimize::access_patterns::BlockedIterator::for_type<T>(total: usize, cache: numrs2::memory_optimize::access_patterns::CacheConfig) -> Self
pub fn numrs2::memory_optimize::access_patterns::BlockedIterator::new(total: usize, block_size: usize) -> Self
impl core::iter::traits::exact_size::ExactSizeIterator for numrs2::memory_optimize::access_patterns::BlockedIterator
impl core::iter::traits::iterator::Iterator for numrs2::memory_optimize::access_patterns::BlockedIterator
pub type numrs2::memory_optimize::access_patterns::BlockedIterator::Item = numrs2::memory_optimize::access_patterns::Block
pub fn numrs2::memory_optimize::access_patterns::BlockedIterator::next(&mut self) -> core::option::Option<Self::Item>
pub fn numrs2::memory_optimize::access_patterns::BlockedIterator::size_hint(&self) -> (usize, core::option::Option<usize>)
pub struct numrs2::prelude::BroadcastEngine
impl numrs2::arrays::BroadcastEngine
pub fn numrs2::arrays::BroadcastEngine::add<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Add<Output = T>
pub fn numrs2::arrays::BroadcastEngine::add_scalar<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, scalar: T) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Add<Output = T>
pub fn numrs2::arrays::BroadcastEngine::binary_op<T, F>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>, op: F) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T + core::marker::Send + core::marker::Sync
pub fn numrs2::arrays::BroadcastEngine::broadcast_shape(&self, shape1: &numrs2::arrays::Shape, shape2: &numrs2::arrays::Shape) -> numrs2::Result<numrs2::arrays::Shape>
pub fn numrs2::arrays::BroadcastEngine::can_broadcast(&self, shape1: &numrs2::arrays::Shape, shape2: &numrs2::arrays::Shape) -> bool
pub fn numrs2::arrays::BroadcastEngine::divide<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::FloatingPoint + core::marker::Copy + core::ops::arith::Div<Output = T>
pub fn numrs2::arrays::BroadcastEngine::equal<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<bool>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialEq
pub fn numrs2::arrays::BroadcastEngine::greater<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<bool>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastEngine::less<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<bool>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastEngine::logical_and(&self, a: &numrs2::arrays::ArrayView<'_, bool>, b: &numrs2::arrays::ArrayView<'_, bool>) -> numrs2::Result<alloc::vec::Vec<bool>>
pub fn numrs2::arrays::BroadcastEngine::logical_or(&self, a: &numrs2::arrays::ArrayView<'_, bool>, b: &numrs2::arrays::ArrayView<'_, bool>) -> numrs2::Result<alloc::vec::Vec<bool>>
pub fn numrs2::arrays::BroadcastEngine::maximum<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastEngine::minimum<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastEngine::multiply<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Mul<Output = T>
pub fn numrs2::arrays::BroadcastEngine::multiply_scalar<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, scalar: T) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Mul<Output = T>
pub fn numrs2::arrays::BroadcastEngine::new(config: numrs2::arrays::BroadcastConfig) -> Self
pub fn numrs2::arrays::BroadcastEngine::power<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::FloatingPoint + core::marker::Copy
pub fn numrs2::arrays::BroadcastEngine::scalar_op<T, F>(&self, array: &numrs2::arrays::ArrayView<'_, T>, scalar: T, op: F) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::arrays::BroadcastEngine::subtract<T>(&self, a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Sub<Output = T>
impl core::default::Default for numrs2::arrays::BroadcastEngine
pub fn numrs2::arrays::BroadcastEngine::default() -> Self
pub struct numrs2::prelude::BroadcastOp
impl numrs2::arrays::BroadcastOp
pub fn numrs2::arrays::BroadcastOp::binary_op<T, F>(a: &numrs2::arrays::ArrayView<'_, T>, b: &numrs2::arrays::ArrayView<'_, T>, output: &mut [T], op: F) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::arrays::BroadcastOp::unary_op<T, F>(input: &numrs2::arrays::ArrayView<'_, T>, output: &mut [T], target_shape: &numrs2::arrays::Shape, op: F) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T) -> T
pub struct numrs2::prelude::BroadcastReduction
impl numrs2::arrays::BroadcastReduction
pub fn numrs2::arrays::BroadcastReduction::max<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastReduction::mean<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::FloatingPoint + core::marker::Copy + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T>
pub fn numrs2::arrays::BroadcastReduction::min<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::arrays::BroadcastReduction::new(config: numrs2::arrays::BroadcastConfig) -> Self
pub fn numrs2::arrays::BroadcastReduction::sum<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy + core::ops::arith::Add<Output = T>
pub struct numrs2::prelude::CSEOptimizer<T: core::clone::Clone>
impl<T: core::clone::Clone> numrs2::expr::CSEOptimizer<T>
pub fn numrs2::expr::CSEOptimizer<T>::cache(&self) -> &numrs2::expr::ExprCache<T>
pub fn numrs2::expr::CSEOptimizer<T>::cache_expr<E: numrs2::expr::SharedExpr<T>>(&self, expr: E, id: numrs2::expr::ExprId) -> numrs2::expr::CachedExpr<T, E>
pub fn numrs2::expr::CSEOptimizer<T>::clear(&mut self)
pub fn numrs2::expr::CSEOptimizer<T>::get_or_create_id(&mut self, key: &numrs2::expr::ExprKey) -> numrs2::expr::ExprId
pub fn numrs2::expr::CSEOptimizer<T>::new() -> Self
pub fn numrs2::expr::CSEOptimizer<T>::next_array_id(&mut self) -> u64
pub fn numrs2::expr::CSEOptimizer<T>::stats(&self) -> numrs2::expr::CSEStats
impl<T: core::clone::Clone> core::default::Default for numrs2::expr::CSEOptimizer<T>
pub fn numrs2::expr::CSEOptimizer<T>::default() -> Self
pub struct numrs2::prelude::CacheAwareArrayOps<T>
impl<T: numrs2::traits::NumericElement> numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::matvec_blocked(&self, matrix: &[T], vector: &[T], result: &mut [T], rows: usize, cols: usize) -> numrs2::Result<()> where T: core::marker::Copy + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::merge_sort_cache_oblivious(&self, data: &mut [T]) -> numrs2::Result<()> where T: core::marker::Copy + core::cmp::PartialOrd
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::new(cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::optimal_tile_size(&self, element_size: usize) -> (usize, usize)
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::optimize_stride_access<F>(&self, data: &mut [T], rows: usize, cols: usize, operation: F) -> numrs2::Result<()> where F: core::ops::function::FnMut(&mut T, usize, usize), T: core::marker::Copy
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::sum_blocked(&self, data: &[T]) -> T where T: core::marker::Copy + core::ops::arith::Add<Output = T>
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::transpose_blocked(&self, src: &[T], dst: &mut [T], rows: usize, cols: usize) -> numrs2::Result<()> where T: core::marker::Copy
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::with_default_config() -> Self
impl<T: numrs2::traits::NumericElement> core::default::Default for numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>
pub fn numrs2::algorithms::cache_aware::CacheAwareArrayOps<T>::default() -> Self
pub struct numrs2::prelude::CacheAwareConvolution<T>
impl<T: numrs2::traits::NumericElement + core::marker::Copy> numrs2::algorithms::cache_aware::CacheAwareConvolution<T>
pub fn numrs2::algorithms::cache_aware::CacheAwareConvolution<T>::conv2d_blocked(&self, input: &[T], kernel: &[T], output: &mut [T], input_height: usize, input_width: usize, kernel_height: usize, kernel_width: usize) -> numrs2::Result<()> where T: core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::algorithms::cache_aware::CacheAwareConvolution<T>::new(cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub fn numrs2::algorithms::cache_aware::CacheAwareConvolution<T>::separable_conv2d(&self, input: &[T], h_kernel: &[T], v_kernel: &[T], output: &mut [T], height: usize, width: usize) -> numrs2::Result<()> where T: core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub struct numrs2::prelude::CacheAwareFFT<T>
impl<T: numrs2::traits::FloatingPoint> numrs2::algorithms::cache_aware::CacheAwareFFT<T>
pub fn numrs2::algorithms::cache_aware::CacheAwareFFT<T>::fft_cache_oblivious(&self, data: &mut [num_complex::Complex<T>]) -> numrs2::Result<()>
pub fn numrs2::algorithms::cache_aware::CacheAwareFFT<T>::ifft_cache_oblivious(&self, data: &mut [num_complex::Complex<T>]) -> numrs2::Result<()>
pub fn numrs2::algorithms::cache_aware::CacheAwareFFT<T>::new(cache_config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub struct numrs2::prelude::CacheConfig
pub numrs2::prelude::CacheConfig::cache_line_size: usize
pub numrs2::prelude::CacheConfig::enable_blocking: bool
pub numrs2::prelude::CacheConfig::enable_cache_padding: bool
pub numrs2::prelude::CacheConfig::enable_prefetch: bool
pub numrs2::prelude::CacheConfig::l1_cache_size: usize
pub numrs2::prelude::CacheConfig::l2_cache_size: usize
pub numrs2::prelude::CacheConfig::l3_cache_size: usize
pub numrs2::prelude::CacheConfig::optimize_access_patterns: bool
impl core::default::Default for numrs2::memory_alloc::cache_optimization::CacheConfig
pub fn numrs2::memory_alloc::cache_optimization::CacheConfig::default() -> Self
pub struct numrs2::prelude::CacheOptimizedAllocator
impl numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::analyze_cache_performance(&self) -> alloc::vec::Vec<numrs2::memory_alloc::cache_optimization::CacheOptimizationRecommendation>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::fits_in_cache(&self, size: usize, cache_level: numrs2::memory_alloc::cache_optimization::CacheLevel) -> bool
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::get_cache_metrics(&self) -> numrs2::memory_alloc::cache_optimization::CacheMetrics
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::new(config: numrs2::memory_alloc::cache_optimization::CacheConfig) -> Self
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::optimal_block_size(&self, element_size: usize, cache_level: numrs2::memory_alloc::cache_optimization::CacheLevel) -> usize
impl core::default::Default for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::default() -> Self
impl core::fmt::Debug for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl numrs2::traits::MemoryAllocator for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub type numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::prelude::CachedExpr<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>>
impl<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>> numrs2::expr::CachedExpr<T, E>
pub fn numrs2::expr::CachedExpr<T, E>::cache(&self) -> &numrs2::expr::ExprCache<T>
pub fn numrs2::expr::CachedExpr<T, E>::id(&self) -> numrs2::expr::ExprId
pub fn numrs2::expr::CachedExpr<T, E>::invalidate(&self)
pub fn numrs2::expr::CachedExpr<T, E>::new(expr: E, cache: numrs2::expr::ExprCache<T>) -> Self
pub fn numrs2::expr::CachedExpr<T, E>::with_id(expr: E, id: numrs2::expr::ExprId, cache: numrs2::expr::ExprCache<T>) -> Self
impl<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExpr<T> for numrs2::expr::CachedExpr<T, E>
pub fn numrs2::expr::CachedExpr<T, E>::eval(&self) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::CachedExpr<T, E>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::CachedExpr<T, E>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::CachedExpr<T, E>::size(&self) -> usize
pub struct numrs2::prelude::CholeskyStableResult<T: core::clone::Clone>
pub numrs2::prelude::CholeskyStableResult::condition_number: T
pub numrs2::prelude::CholeskyStableResult::d: core::option::Option<numrs2::array::Array<T>>
pub numrs2::prelude::CholeskyStableResult::is_positive_definite: bool
pub numrs2::prelude::CholeskyStableResult::l: numrs2::array::Array<T>
pub numrs2::prelude::CholeskyStableResult::p: core::option::Option<numrs2::array::Array<f64>>
pub numrs2::prelude::CholeskyStableResult::pivoting_used: bool
pub struct numrs2::prelude::ColumnStats
pub numrs2::prelude::ColumnStats::max: f64
pub numrs2::prelude::ColumnStats::mean: f64
pub numrs2::prelude::ColumnStats::min: f64
pub numrs2::prelude::ColumnStats::sum: f64
pub struct numrs2::prelude::CubicSpline<T>
impl<T> numrs2::math_extended::CubicSpline<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialOrd + core::fmt::Debug + num_traits::float::Float
pub fn numrs2::math_extended::CubicSpline<T>::evaluate(&self, x: T) -> numrs2::Result<T>
pub fn numrs2::math_extended::CubicSpline<T>::evaluate_array(&self, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math_extended::CubicSpline<T>::new(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub struct numrs2::prelude::CustomDType<T: 'static>
impl<T: core::clone::Clone + core::default::Default + core::marker::Send + core::marker::Sync + 'static> numrs2::types::custom::CustomDType<T>
pub fn numrs2::types::custom::CustomDType<T>::new<S: core::convert::Into<alloc::string::String>>(name: S, size: usize, numeric: bool) -> Self
impl<T: core::fmt::Debug + core::clone::Clone + core::default::Default + core::marker::Send + core::marker::Sync + 'static> core::fmt::Debug for numrs2::types::custom::CustomDType<T>
pub fn numrs2::types::custom::CustomDType<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::fmt::Debug + core::clone::Clone + core::default::Default + core::marker::Send + core::marker::Sync + 'static> numrs2::types::custom::TypeDescriptor for numrs2::types::custom::CustomDType<T>
pub fn numrs2::types::custom::CustomDType<T>::default_value(&self) -> alloc::boxed::Box<dyn core::any::Any>
pub fn numrs2::types::custom::CustomDType<T>::is_numeric(&self) -> bool
pub fn numrs2::types::custom::CustomDType<T>::name(&self) -> &str
pub fn numrs2::types::custom::CustomDType<T>::parse_bytes(&self, _bytes: &[u8]) -> alloc::boxed::Box<dyn core::any::Any>
pub fn numrs2::types::custom::CustomDType<T>::size_in_bytes(&self) -> usize
pub fn numrs2::types::custom::CustomDType<T>::to_bytes(&self, value: &dyn core::any::Any) -> alloc::vec::Vec<u8>
pub struct numrs2::prelude::DateTime64
impl numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::from_iso_string(s: &str, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<Self>
pub fn numrs2::types::datetime::DateTime64::from_system_time(time: std::time::SystemTime, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<Self>
pub fn numrs2::types::datetime::DateTime64::new(value: i64, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::DateTime64::to_iso_string(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::types::datetime::DateTime64::to_system_time(&self) -> std::time::SystemTime
pub fn numrs2::types::datetime::DateTime64::to_unit(&self, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::DateTime64::unit(&self) -> numrs2::types::datetime::DateTimeUnit
pub fn numrs2::types::datetime::DateTime64::value(&self) -> i64
impl core::fmt::Display for numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Sub for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::DateTime64::sub(self, rhs: numrs2::types::datetime::DateTime64) -> Self::Output
impl core::ops::arith::Sub<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::str::traits::FromStr for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Err = numrs2::NumRs2Error
pub fn numrs2::types::datetime::DateTime64::from_str(s: &str) -> numrs2::Result<Self>
pub struct numrs2::prelude::DiagonalView<'a, T>
impl<'a, T: core::clone::Clone> numrs2::views::DiagonalView<'a, T>
pub fn numrs2::views::DiagonalView<'a, T>::get(&self, index: usize) -> core::option::Option<&T>
pub fn numrs2::views::DiagonalView<'a, T>::is_empty(&self) -> bool
pub fn numrs2::views::DiagonalView<'a, T>::iter(&self) -> impl core::iter::traits::iterator::Iterator<Item = &T>
pub fn numrs2::views::DiagonalView<'a, T>::len(&self) -> usize
pub fn numrs2::views::DiagonalView<'a, T>::new(data: &'a [T], rows: usize, cols: usize, offset: isize) -> numrs2::Result<Self>
pub fn numrs2::views::DiagonalView<'a, T>::to_vec(&self) -> alloc::vec::Vec<T>
pub struct numrs2::prelude::EnhancedAllocatorBridge<T: numrs2::memory_alloc::strategy::MemoryAllocator>
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::new(allocator: T) -> Self
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::traits::MemoryAllocator for numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub type numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::supports_layout(&self, _layout: core::alloc::layout::Layout) -> bool
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::prelude::ErrorState
pub numrs2::prelude::ErrorState::divide: numrs2::error_handling::ErrorAction
pub numrs2::prelude::ErrorState::invalid: numrs2::error_handling::ErrorAction
pub numrs2::prelude::ErrorState::over: numrs2::error_handling::ErrorAction
pub numrs2::prelude::ErrorState::under: numrs2::error_handling::ErrorAction
impl numrs2::error_handling::ErrorState
pub fn numrs2::error_handling::ErrorState::new(action: numrs2::error_handling::ErrorAction) -> Self
pub fn numrs2::error_handling::ErrorState::with_actions(divide: numrs2::error_handling::ErrorAction, over: numrs2::error_handling::ErrorAction, under: numrs2::error_handling::ErrorAction, invalid: numrs2::error_handling::ErrorAction) -> Self
impl core::default::Default for numrs2::error_handling::ErrorState
pub fn numrs2::error_handling::ErrorState::default() -> Self
pub struct numrs2::prelude::ErrorStateBuilder
impl numrs2::error_handling::ErrorStateBuilder
pub fn numrs2::error_handling::ErrorStateBuilder::divide(self, action: numrs2::error_handling::ErrorAction) -> Self
pub fn numrs2::error_handling::ErrorStateBuilder::enter(self) -> numrs2::error_handling::ErrorStateGuard
pub fn numrs2::error_handling::ErrorStateBuilder::invalid(self, action: numrs2::error_handling::ErrorAction) -> Self
pub fn numrs2::error_handling::ErrorStateBuilder::over(self, action: numrs2::error_handling::ErrorAction) -> Self
pub fn numrs2::error_handling::ErrorStateBuilder::under(self, action: numrs2::error_handling::ErrorAction) -> Self
pub struct numrs2::prelude::ErrorStateGuard
impl core::ops::drop::Drop for numrs2::error_handling::ErrorStateGuard
pub fn numrs2::error_handling::ErrorStateGuard::drop(&mut self)
pub struct numrs2::prelude::ExprBuilder<T, E> where T: core::clone::Clone, E: numrs2::expr::Expr<T>
impl<'a, T: core::clone::Clone> numrs2::expr::ExprBuilder<T, numrs2::expr::ArrayExpr<'a, T>>
pub fn numrs2::expr::ExprBuilder<T, numrs2::expr::ArrayExpr<'a, T>>::from_array(array: &'a numrs2::array::Array<T>) -> Self
impl<E: numrs2::expr::Expr<f64>> numrs2::expr::ExprBuilder<f64, E>
pub fn numrs2::expr::ExprBuilder<f64, E>::abs(self) -> numrs2::expr::ExprBuilder<f64, numrs2::expr::UnaryExpr<f64, E, impl core::ops::function::Fn(f64) -> f64>>
pub fn numrs2::expr::ExprBuilder<f64, E>::cos(self) -> numrs2::expr::ExprBuilder<f64, numrs2::expr::UnaryExpr<f64, E, impl core::ops::function::Fn(f64) -> f64>>
pub fn numrs2::expr::ExprBuilder<f64, E>::exp(self) -> numrs2::expr::ExprBuilder<f64, numrs2::expr::UnaryExpr<f64, E, impl core::ops::function::Fn(f64) -> f64>>
pub fn numrs2::expr::ExprBuilder<f64, E>::ln(self) -> numrs2::expr::ExprBuilder<f64, numrs2::expr::UnaryExpr<f64, E, impl core::ops::function::Fn(f64) -> f64>>
pub fn numrs2::expr::ExprBuilder<f64, E>::max(self) -> f64
pub fn numrs2::expr::ExprBuilder<f64, E>::min(self) -> f64
pub fn numrs2::expr::ExprBuilder<f64, E>::prod(self) -> f64
pub fn numrs2::expr::ExprBuilder<f64, E>::sin(self) -> numrs2::expr::ExprBuilder<f64, numrs2::expr::UnaryExpr<f64, E, impl core::ops::function::Fn(f64) -> f64>>
pub fn numrs2::expr::ExprBuilder<f64, E>::sqrt(self) -> numrs2::expr::ExprBuilder<f64, numrs2::expr::UnaryExpr<f64, E, impl core::ops::function::Fn(f64) -> f64>>
pub fn numrs2::expr::ExprBuilder<f64, E>::sum(self) -> f64
impl<T, E> numrs2::expr::ExprBuilder<T, E> where T: core::clone::Clone, E: numrs2::expr::Expr<T>
pub fn numrs2::expr::ExprBuilder<T, E>::add_scalar(self, scalar: T) -> numrs2::expr::ExprBuilder<T, numrs2::expr::ScalarExpr<T, E, impl core::ops::function::Fn(T, T) -> T>> where T: core::ops::arith::Add<Output = T>
pub fn numrs2::expr::ExprBuilder<T, E>::build(self) -> E
pub fn numrs2::expr::ExprBuilder<T, E>::eval(self) -> numrs2::array::Array<T>
pub fn numrs2::expr::ExprBuilder<T, E>::map<F: core::ops::function::Fn(T) -> T>(self, op: F) -> numrs2::expr::ExprBuilder<T, numrs2::expr::UnaryExpr<T, E, F>>
pub fn numrs2::expr::ExprBuilder<T, E>::mul_scalar(self, scalar: T) -> numrs2::expr::ExprBuilder<T, numrs2::expr::ScalarExpr<T, E, impl core::ops::function::Fn(T, T) -> T>> where T: core::ops::arith::Mul<Output = T>
pub fn numrs2::expr::ExprBuilder<T, E>::scalar<F: core::ops::function::Fn(T, T) -> T>(self, scalar: T, op: F) -> numrs2::expr::ExprBuilder<T, numrs2::expr::ScalarExpr<T, E, F>>
pub fn numrs2::expr::ExprBuilder<T, E>::zip_with<E2, F>(self, other: E2, op: F) -> numrs2::Result<numrs2::expr::ExprBuilder<T, numrs2::expr::BinaryExpr<T, E, E2, F>>> where E2: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub struct numrs2::prelude::ExprCache<T: core::clone::Clone>
impl<T: core::clone::Clone> numrs2::expr::ExprCache<T>
pub fn numrs2::expr::ExprCache<T>::clear(&self)
pub fn numrs2::expr::ExprCache<T>::contains(&self, id: &numrs2::expr::ExprId) -> bool
pub fn numrs2::expr::ExprCache<T>::get(&self, id: &numrs2::expr::ExprId) -> core::option::Option<numrs2::shared_array::SharedArray<T>>
pub fn numrs2::expr::ExprCache<T>::insert(&self, id: numrs2::expr::ExprId, value: numrs2::shared_array::SharedArray<T>)
pub fn numrs2::expr::ExprCache<T>::is_empty(&self) -> bool
pub fn numrs2::expr::ExprCache<T>::len(&self) -> usize
pub fn numrs2::expr::ExprCache<T>::new() -> Self
impl<T: core::clone::Clone> core::clone::Clone for numrs2::expr::ExprCache<T>
pub fn numrs2::expr::ExprCache<T>::clone(&self) -> Self
impl<T: core::clone::Clone> core::default::Default for numrs2::expr::ExprCache<T>
pub fn numrs2::expr::ExprCache<T>::default() -> Self
pub struct numrs2::prelude::ExprId(_)
impl numrs2::expr::ExprId
pub fn numrs2::expr::ExprId::from_raw(id: u64) -> Self
pub fn numrs2::expr::ExprId::new() -> Self
pub fn numrs2::expr::ExprId::raw(&self) -> u64
impl core::default::Default for numrs2::expr::ExprId
pub fn numrs2::expr::ExprId::default() -> Self
pub struct numrs2::prelude::FFT
impl numrs2::signal::FFT
pub fn numrs2::signal::FFT::apply_window<T>(x: &numrs2::array::Array<T>, window_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub fn numrs2::signal::FFT::fft<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::fft2<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::fftfreq<T>(n: usize, d: T) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub fn numrs2::signal::FFT::fftshift<T: core::clone::Clone>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::signal::FFT::ifft<T>(x: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::ifft2<T>(x: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::ifftshift<T: core::clone::Clone>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::signal::FFT::irfft<T>(x: &numrs2::array::Array<num_complex::Complex<T>>, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::irfft2<T>(x: &numrs2::array::Array<num_complex::Complex<T>>, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::power_spectrum<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::rfft<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::rfft2<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::rfftfreq<T>(n: usize, d: T) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub struct numrs2::prelude::FancyIndexEngine
impl numrs2::arrays::FancyIndexEngine
pub fn numrs2::arrays::FancyIndexEngine::advanced_index<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[numrs2::arrays::IndexSpec]) -> numrs2::Result<numrs2::arrays::FancyIndexResult<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::choose<T>(&self, choices: &[&numrs2::arrays::ArrayView<'_, T>], index_array: &[usize]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::index_with_arrays<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[alloc::vec::Vec<usize>]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::index_with_boolean<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, mask: &[bool]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::new(config: numrs2::arrays::FancyIndexConfig) -> Self
pub fn numrs2::arrays::FancyIndexEngine::nonzero<T, F>(&self, array: &numrs2::arrays::ArrayView<'_, T>, condition: F) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<usize>>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T) -> bool
pub fn numrs2::arrays::FancyIndexEngine::set_with_arrays<T>(&self, array: &mut [T], array_shape: &numrs2::arrays::Shape, indices: &[alloc::vec::Vec<usize>], values: &[T]) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::set_with_boolean<T>(&self, array: &mut [T], _array_shape: &numrs2::arrays::Shape, mask: &[bool], value: T) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::take<T>(&self, array: &numrs2::arrays::ArrayView<'_, T>, indices: &[usize], axis: usize) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::FancyIndexEngine::where_condition<T, F>(&self, array: &numrs2::arrays::ArrayView<'_, T>, condition: F) -> numrs2::Result<alloc::vec::Vec<bool>> where T: numrs2::traits::NumericElement + core::marker::Copy, F: core::ops::function::Fn(T) -> bool
impl core::default::Default for numrs2::arrays::FancyIndexEngine
pub fn numrs2::arrays::FancyIndexEngine::default() -> Self
pub struct numrs2::prelude::FancyIndexResult<T>
pub numrs2::prelude::FancyIndexResult::data: alloc::vec::Vec<T>
pub numrs2::prelude::FancyIndexResult::new_axes: alloc::vec::Vec<usize>
pub numrs2::prelude::FancyIndexResult::shape: numrs2::arrays::Shape
impl<T> numrs2::arrays::FancyIndexResult<T>
pub fn numrs2::arrays::FancyIndexResult<T>::to_view(&self) -> numrs2::Result<numrs2::arrays::ArrayView<'_, T>>
pub struct numrs2::prelude::Field
pub numrs2::prelude::Field::dtype: numrs2::types::structured::DType
pub numrs2::prelude::Field::name: alloc::string::String
impl numrs2::types::structured::Field
pub fn numrs2::types::structured::Field::new<S: core::convert::Into<alloc::string::String>>(name: S, dtype: numrs2::types::structured::DType) -> Self
impl core::fmt::Display for numrs2::types::structured::Field
pub fn numrs2::types::structured::Field::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::prelude::Generator<B: numrs2::random::generator::BitGenerator>
impl<B: numrs2::random::generator::BitGenerator> numrs2::random::generator::Generator<B>
pub fn numrs2::random::generator::Generator<B>::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::beta<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::bit_generator(&self) -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'_, B>>
pub fn numrs2::random::generator::Generator<B>::chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::integers<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::random::generator::Generator<B>::integers_simple<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::new(bit_generator: B) -> Self
pub fn numrs2::random::generator::Generator<B>::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::poisson<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + num_traits::cast::NumCast
pub fn numrs2::random::generator::Generator<B>::standard_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::weibull<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub struct numrs2::prelude::IntelligentAllocationStrategy
impl numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::new() -> Self
impl core::default::Default for numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::default() -> Self
impl numrs2::traits::AllocationStrategy for numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::select_allocator(&self, requirements: &numrs2::traits::AllocationRequirements) -> alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::strategy_stats(&self) -> numrs2::traits::StrategyStats
pub struct numrs2::prelude::LoadBalancer
impl numrs2::parallel::load_balancer::LoadBalancer
pub fn numrs2::parallel::load_balancer::LoadBalancer::current_metrics(&self) -> numrs2::parallel::load_balancer::WorkloadMetrics
pub fn numrs2::parallel::load_balancer::LoadBalancer::current_strategy(&self) -> numrs2::parallel::load_balancer::BalancingStrategy
pub fn numrs2::parallel::load_balancer::LoadBalancer::new(strategy: numrs2::parallel::load_balancer::BalancingStrategy, num_workers: usize) -> numrs2::Result<Self>
pub fn numrs2::parallel::load_balancer::LoadBalancer::num_workers(&self) -> usize
pub fn numrs2::parallel::load_balancer::LoadBalancer::select_worker(&self) -> numrs2::Result<usize>
pub fn numrs2::parallel::load_balancer::LoadBalancer::set_strategy(&self, new_strategy: numrs2::parallel::load_balancer::BalancingStrategy)
pub fn numrs2::parallel::load_balancer::LoadBalancer::update_worker_metrics(&self, worker_id: usize, queue_length: usize, cpu_utilization: f64, memory_usage: f64) -> numrs2::Result<()>
pub struct numrs2::prelude::MaskedArray<T>
impl<T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::identities::Zero + core::convert::From<f64> + core::convert::Into<f64>> numrs2::masked::MaskedArray<T>
pub fn numrs2::masked::MaskedArray<T>::max(&self) -> core::option::Option<T> where T: core::cmp::PartialOrd
pub fn numrs2::masked::MaskedArray<T>::mean(&self) -> core::option::Option<T>
pub fn numrs2::masked::MaskedArray<T>::min(&self) -> core::option::Option<T> where T: core::cmp::PartialOrd
pub fn numrs2::masked::MaskedArray<T>::sum(&self) -> core::option::Option<T>
impl<T: core::clone::Clone> numrs2::masked::MaskedArray<T>
pub fn numrs2::masked::MaskedArray<T>::compressed(&self) -> numrs2::array::Array<T> where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::count_masked(&self) -> usize
pub fn numrs2::masked::MaskedArray<T>::count_valid(&self) -> usize
pub fn numrs2::masked::MaskedArray<T>::filled(&self, fill_value: core::option::Option<T>) -> numrs2::array::Array<T> where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::get(&self, indices: &[usize]) -> numrs2::Result<T> where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::get_data(&self) -> &numrs2::array::Array<T>
pub fn numrs2::masked::MaskedArray<T>::get_fill_value(&self) -> T
pub fn numrs2::masked::MaskedArray<T>::get_mask(&self) -> &numrs2::array::Array<bool>
pub fn numrs2::masked::MaskedArray<T>::harden_mask(&self) -> Self where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::masked_all(data: numrs2::array::Array<T>, fill_value: core::option::Option<T>) -> numrs2::Result<Self> where T: core::clone::Clone + core::default::Default
pub fn numrs2::masked::MaskedArray<T>::masked_invalid(data: numrs2::array::Array<f64>, fill_value: core::option::Option<f64>) -> numrs2::Result<numrs2::masked::MaskedArray<f64>>
pub fn numrs2::masked::MaskedArray<T>::masked_values(data: numrs2::array::Array<T>, value: T, fill_value: core::option::Option<T>) -> numrs2::Result<Self> where T: core::clone::Clone + core::default::Default + core::cmp::PartialEq
pub fn numrs2::masked::MaskedArray<T>::masked_where(data: numrs2::array::Array<T>, condition: numrs2::array::Array<bool>, fill_value: core::option::Option<T>) -> numrs2::Result<Self> where T: core::clone::Clone + core::default::Default
pub fn numrs2::masked::MaskedArray<T>::ndim(&self) -> usize
pub fn numrs2::masked::MaskedArray<T>::new(data: numrs2::array::Array<T>, mask: core::option::Option<numrs2::array::Array<bool>>, fill_value: core::option::Option<T>) -> numrs2::Result<Self> where T: core::clone::Clone + core::default::Default
pub fn numrs2::masked::MaskedArray<T>::reshape(&self, shape: &[usize]) -> Self where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::set(&mut self, indices: &[usize], value: T, mask: core::option::Option<bool>) -> numrs2::Result<()> where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::set_fill_value(&mut self, value: T)
pub fn numrs2::masked::MaskedArray<T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::masked::MaskedArray<T>::size(&self) -> usize
pub fn numrs2::masked::MaskedArray<T>::soften_mask(&self) -> Self where T: core::clone::Clone
pub fn numrs2::masked::MaskedArray<T>::transpose(&self) -> Self where T: core::clone::Clone
impl<T: core::clone::Clone + core::fmt::Debug> core::fmt::Debug for numrs2::masked::MaskedArray<T>
pub fn numrs2::masked::MaskedArray<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::clone::Clone + core::fmt::Display + core::fmt::Debug> core::fmt::Display for numrs2::masked::MaskedArray<T>
pub fn numrs2::masked::MaskedArray<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::clone::Clone + core::ops::arith::Add<Output = T>> core::ops::arith::Add for &numrs2::masked::MaskedArray<T>
pub type &numrs2::masked::MaskedArray<T>::Output = numrs2::masked::MaskedArray<T>
pub fn &numrs2::masked::MaskedArray<T>::add(self, other: &numrs2::masked::MaskedArray<T>) -> numrs2::masked::MaskedArray<T>
impl<T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + num_traits::identities::Zero> core::ops::arith::Div for &numrs2::masked::MaskedArray<T>
pub type &numrs2::masked::MaskedArray<T>::Output = numrs2::masked::MaskedArray<T>
pub fn &numrs2::masked::MaskedArray<T>::div(self, other: &numrs2::masked::MaskedArray<T>) -> numrs2::masked::MaskedArray<T>
impl<T: core::clone::Clone + core::ops::arith::Mul<Output = T>> core::ops::arith::Mul for &numrs2::masked::MaskedArray<T>
pub type &numrs2::masked::MaskedArray<T>::Output = numrs2::masked::MaskedArray<T>
pub fn &numrs2::masked::MaskedArray<T>::mul(self, other: &numrs2::masked::MaskedArray<T>) -> numrs2::masked::MaskedArray<T>
impl<T: core::clone::Clone + core::ops::arith::Sub<Output = T>> core::ops::arith::Sub for &numrs2::masked::MaskedArray<T>
pub type &numrs2::masked::MaskedArray<T>::Output = numrs2::masked::MaskedArray<T>
pub fn &numrs2::masked::MaskedArray<T>::sub(self, other: &numrs2::masked::MaskedArray<T>) -> numrs2::masked::MaskedArray<T>
pub struct numrs2::prelude::Matrix<T>
impl<T> numrs2::matrix::Matrix<T> where T: core::clone::Clone + core::default::Default + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::cmp::PartialOrd
pub fn numrs2::matrix::Matrix<T>::dot(&self, other: &numrs2::matrix::Matrix<T>) -> numrs2::Result<numrs2::matrix::Matrix<T>>
impl<T> numrs2::matrix::Matrix<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::matrix::Matrix<T>::array(&self) -> &numrs2::array::Array<T>
pub fn numrs2::matrix::Matrix<T>::column(&self, j: usize) -> numrs2::Result<Self>
pub fn numrs2::matrix::Matrix<T>::diagonal(&self) -> Self
pub fn numrs2::matrix::Matrix<T>::eye(n: usize) -> Self where T: core::convert::From<u8> + core::clone::Clone + core::default::Default
pub fn numrs2::matrix::Matrix<T>::from_nested_vec(nested_vec: alloc::vec::Vec<alloc::vec::Vec<T>>) -> numrs2::Result<Self>
pub fn numrs2::matrix::Matrix<T>::from_vec(vec: alloc::vec::Vec<T>) -> Self
pub fn numrs2::matrix::Matrix<T>::get(&self, i: usize, j: usize) -> numrs2::Result<T>
pub fn numrs2::matrix::Matrix<T>::is_square(&self) -> bool
pub fn numrs2::matrix::Matrix<T>::is_symmetric(&self) -> bool where T: core::cmp::PartialEq
pub fn numrs2::matrix::Matrix<T>::ncols(&self) -> usize
pub fn numrs2::matrix::Matrix<T>::new(array: numrs2::array::Array<T>) -> numrs2::Result<Self>
pub fn numrs2::matrix::Matrix<T>::nrows(&self) -> usize
pub fn numrs2::matrix::Matrix<T>::ones(rows: usize, cols: usize) -> Self where T: core::convert::From<u8> + core::clone::Clone
pub fn numrs2::matrix::Matrix<T>::row(&self, i: usize) -> numrs2::Result<Self>
pub fn numrs2::matrix::Matrix<T>::set(&mut self, i: usize, j: usize, value: T) -> numrs2::Result<()>
pub fn numrs2::matrix::Matrix<T>::shape(&self) -> (usize, usize)
pub fn numrs2::matrix::Matrix<T>::size(&self) -> usize
pub fn numrs2::matrix::Matrix<T>::to_array(&self) -> numrs2::array::Array<T>
pub fn numrs2::matrix::Matrix<T>::to_nested_vec(&self) -> alloc::vec::Vec<alloc::vec::Vec<T>>
pub fn numrs2::matrix::Matrix<T>::transpose(&self) -> Self
pub fn numrs2::matrix::Matrix<T>::zeros(rows: usize, cols: usize) -> Self where T: core::default::Default + core::clone::Clone
impl<T: core::clone::Clone + core::default::Default + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::cmp::PartialOrd> core::ops::arith::Mul for &numrs2::matrix::Matrix<T>
pub type &numrs2::matrix::Matrix<T>::Output = numrs2::matrix::Matrix<T>
pub fn &numrs2::matrix::Matrix<T>::mul(self, other: &numrs2::matrix::Matrix<T>) -> numrs2::matrix::Matrix<T>
impl<T> core::convert::TryFrom<numrs2::array::Array<T>> for numrs2::matrix::Matrix<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub type numrs2::matrix::Matrix<T>::Error = numrs2::NumRs2Error
pub fn numrs2::matrix::Matrix<T>::try_from(array: numrs2::array::Array<T>) -> numrs2::Result<Self>
impl<T> core::fmt::Display for numrs2::matrix::Matrix<T> where T: core::clone::Clone + core::fmt::Display + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::matrix::Matrix<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T> core::ops::arith::Add for &numrs2::matrix::Matrix<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub type &numrs2::matrix::Matrix<T>::Output = numrs2::matrix::Matrix<T>
pub fn &numrs2::matrix::Matrix<T>::add(self, other: &numrs2::matrix::Matrix<T>) -> numrs2::matrix::Matrix<T>
impl<T> core::ops::arith::Div<T> for &numrs2::matrix::Matrix<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub type &numrs2::matrix::Matrix<T>::Output = numrs2::matrix::Matrix<T>
pub fn &numrs2::matrix::Matrix<T>::div(self, scalar: T) -> numrs2::matrix::Matrix<T>
impl<T> core::ops::arith::Sub for &numrs2::matrix::Matrix<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub type &numrs2::matrix::Matrix<T>::Output = numrs2::matrix::Matrix<T>
pub fn &numrs2::matrix::Matrix<T>::sub(self, other: &numrs2::matrix::Matrix<T>) -> numrs2::matrix::Matrix<T>
pub struct numrs2::prelude::MemoryOptimization
pub numrs2::prelude::MemoryOptimization::complexity: u8
pub numrs2::prelude::MemoryOptimization::description: alloc::string::String
pub numrs2::prelude::MemoryOptimization::estimated_savings: usize
pub numrs2::prelude::MemoryOptimization::optimization_type: numrs2::traits::OptimizationType
pub struct numrs2::prelude::MemoryUsage
pub numrs2::prelude::MemoryUsage::allocation_count: usize
pub numrs2::prelude::MemoryUsage::efficiency: f64
pub numrs2::prelude::MemoryUsage::fragmentation: f64
pub numrs2::prelude::MemoryUsage::total_bytes: usize
pub struct numrs2::prelude::MmapArray<T: core::marker::Copy>
impl<T: core::marker::Copy> numrs2::mmap::MmapArray<T>
pub fn numrs2::mmap::MmapArray<T>::access_stats(&self) -> core::option::Option<(numrs2::mmap::AccessPatternType, usize)>
pub fn numrs2::mmap::MmapArray<T>::config(&self) -> &numrs2::mmap::MmapConfig
pub fn numrs2::mmap::MmapArray<T>::flush(&mut self) -> numrs2::Result<()>
pub fn numrs2::mmap::MmapArray<T>::from_array<P: core::convert::AsRef<std::path::Path>>(array: &numrs2::array::Array<T>, path: &P) -> numrs2::Result<Self>
pub fn numrs2::mmap::MmapArray<T>::get(&self, indices: &[usize]) -> numrs2::Result<T>
pub fn numrs2::mmap::MmapArray<T>::ndim(&self) -> usize
pub fn numrs2::mmap::MmapArray<T>::new<P: core::convert::AsRef<std::path::Path>>(path: &P, shape: &[usize], create: bool) -> numrs2::Result<Self>
pub fn numrs2::mmap::MmapArray<T>::path(&self) -> &std::path::Path
pub fn numrs2::mmap::MmapArray<T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::mmap::MmapArray<T>::shape(&self) -> &[usize]
pub fn numrs2::mmap::MmapArray<T>::size(&self) -> usize
pub fn numrs2::mmap::MmapArray<T>::to_array(&self) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::mmap::MmapArray<T>::update_config(&mut self, config: numrs2::mmap::MmapConfig)
impl<T: core::marker::Copy + core::fmt::Debug> core::fmt::Display for numrs2::mmap::MmapArray<T>
pub fn numrs2::mmap::MmapArray<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::prelude::NumericalArrayAllocator
impl numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::new() -> Self
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::with_alignment(alignment: usize) -> Self
impl core::default::Default for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::default() -> Self
impl numrs2::traits::ArrayAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub type numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate_array<T>(&self, len: usize) -> core::result::Result<core::ptr::non_null::NonNull<T>, Self::Error>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate_simd_aligned<T>(&self, len: usize, alignment: usize) -> core::result::Result<core::ptr::non_null::NonNull<T>, Self::Error>
impl numrs2::traits::MemoryAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub type numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::prelude::OptimizationHints
pub numrs2::prelude::OptimizationHints::access_pattern: numrs2::memory_optimize::access_patterns::AccessPattern
pub numrs2::prelude::OptimizationHints::block_size: usize
pub numrs2::prelude::OptimizationHints::cache_efficiency: f64
pub numrs2::prelude::OptimizationHints::layout: numrs2::memory_optimize::access_patterns::MemoryLayout
pub numrs2::prelude::OptimizationHints::tile_size: core::option::Option<(usize, usize)>
pub numrs2::prelude::OptimizationHints::use_parallel: bool
impl numrs2::memory_optimize::access_patterns::OptimizationHints
pub fn numrs2::memory_optimize::access_patterns::OptimizationHints::analyze<T>(shape: &[usize], strides: &[usize]) -> Self
pub fn numrs2::memory_optimize::access_patterns::OptimizationHints::default_for<T>(total_elements: usize) -> Self
impl core::default::Default for numrs2::memory_optimize::access_patterns::OptimizationHints
pub fn numrs2::memory_optimize::access_patterns::OptimizationHints::default() -> Self
pub struct numrs2::prelude::OptimizedBlas
impl numrs2::linalg_optimized::OptimizedBlas
pub fn numrs2::linalg_optimized::OptimizedBlas::dot<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_optimized::OptimizedBlas::gemm<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, c: &mut numrs2::array::Array<T>, alpha: T, beta: T, trans_a: bool, trans_b: bool) -> numrs2::Result<()> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub fn numrs2::linalg_optimized::OptimizedBlas::gemv<T>(a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &mut numrs2::array::Array<T>, alpha: T, beta: T, trans: bool) -> numrs2::Result<()> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + 'static
pub struct numrs2::prelude::ParallelAlgorithmConfig
pub numrs2::prelude::ParallelAlgorithmConfig::block_size: usize
pub numrs2::prelude::ParallelAlgorithmConfig::chunk_size: usize
pub numrs2::prelude::ParallelAlgorithmConfig::num_threads: core::option::Option<usize>
pub numrs2::prelude::ParallelAlgorithmConfig::numa_aware: bool
pub numrs2::prelude::ParallelAlgorithmConfig::parallel_threshold: usize
impl core::default::Default for numrs2::parallel::parallel_algorithms::ParallelConfig
pub fn numrs2::parallel::parallel_algorithms::ParallelConfig::default() -> Self
pub struct numrs2::prelude::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone
impl<A> numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::aggregate_statistics(&self) -> numrs2::traits::AllocationStats
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::force_cleanup(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::garbage_collect_all(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::new(base_allocator: A, config: numrs2::parallel::parallel_allocator::ParallelAllocatorConfig) -> Self
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::total_cached_blocks(&self) -> usize
impl<A> core::fmt::Debug for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<A> numrs2::traits::MemoryAllocator for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub type numrs2::parallel::parallel_allocator::ParallelAllocator<A>::Error = numrs2::NumRs2Error
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl<A> numrs2::traits::SpecializedAllocator for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::allocation_error(&self, msg: &str) -> Self::Error
pub struct numrs2::prelude::ParallelAllocatorConfig
pub numrs2::prelude::ParallelAllocatorConfig::enable_thread_local_cache: bool
pub numrs2::prelude::ParallelAllocatorConfig::enable_tracking: bool
pub numrs2::prelude::ParallelAllocatorConfig::gc_interval: core::time::Duration
pub numrs2::prelude::ParallelAllocatorConfig::global_pool_size: usize
pub numrs2::prelude::ParallelAllocatorConfig::max_block_age: core::time::Duration
pub numrs2::prelude::ParallelAllocatorConfig::max_cached_blocks_per_thread: usize
pub numrs2::prelude::ParallelAllocatorConfig::numa_aware: bool
impl core::default::Default for numrs2::parallel::parallel_allocator::ParallelAllocatorConfig
pub fn numrs2::parallel::parallel_allocator::ParallelAllocatorConfig::default() -> Self
pub struct numrs2::prelude::ParallelArrayOps
impl numrs2::parallel::parallel_algorithms::ParallelArrayOps
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::new(config: numrs2::parallel::parallel_algorithms::ParallelConfig) -> numrs2::Result<Self>
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::parallel_binary_op<T, F>(&self, a: &[T], b: &[T], result: &mut [T], op: F) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T + core::marker::Send + core::marker::Sync + core::marker::Copy + 'static
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::parallel_prefix_sum<T>(&self, data: &[T], result: &mut [T]) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy + core::ops::arith::Add<Output = T>
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::parallel_reduce<T, F>(&self, data: &[T], init: T, op: F) -> numrs2::Result<T> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy, F: core::ops::function::Fn(T, T) -> T + core::marker::Send + core::marker::Sync + core::marker::Copy + 'static
pub fn numrs2::parallel::parallel_algorithms::ParallelArrayOps::parallel_sort<T>(&self, data: &mut [T]) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::cmp::Ord + core::marker::Copy
pub struct numrs2::prelude::ParallelConfig
pub numrs2::prelude::ParallelConfig::chunk_size: usize
pub numrs2::prelude::ParallelConfig::max_threads: core::option::Option<usize>
pub numrs2::prelude::ParallelConfig::min_parallel_size: usize
pub numrs2::prelude::ParallelConfig::scheduling_strategy: numrs2::parallel_optimize::scheduling::SchedulingStrategy
pub numrs2::prelude::ParallelConfig::use_parallel: bool
impl numrs2::parallel_optimize::ParallelConfig
pub fn numrs2::parallel_optimize::ParallelConfig::new() -> Self
pub fn numrs2::parallel_optimize::ParallelConfig::optimal_threads(&self, array_size: usize, element_cost: f64) -> usize
pub fn numrs2::parallel_optimize::ParallelConfig::optimized(array_size: usize, element_cost: f64) -> Self
pub fn numrs2::parallel_optimize::ParallelConfig::should_parallelize(&self, array_size: usize) -> bool
pub fn numrs2::parallel_optimize::ParallelConfig::with_chunk_size(self, chunk_size: usize) -> Self
pub fn numrs2::parallel_optimize::ParallelConfig::with_max_threads(self, max_threads: usize) -> Self
pub fn numrs2::parallel_optimize::ParallelConfig::with_min_size(self, min_size: usize) -> Self
pub fn numrs2::parallel_optimize::ParallelConfig::with_parallel(self, use_parallel: bool) -> Self
pub fn numrs2::parallel_optimize::ParallelConfig::with_scheduling(self, strategy: numrs2::parallel_optimize::scheduling::SchedulingStrategy) -> Self
impl core::default::Default for numrs2::parallel_optimize::ParallelConfig
pub fn numrs2::parallel_optimize::ParallelConfig::default() -> Self
pub struct numrs2::prelude::ParallelContext
impl numrs2::parallel::ParallelContext
pub fn numrs2::parallel::ParallelContext::load_balancer(&self) -> &alloc::sync::Arc<numrs2::parallel::load_balancer::LoadBalancer>
pub fn numrs2::parallel::ParallelContext::new() -> numrs2::Result<Self>
pub fn numrs2::parallel::ParallelContext::scheduler(&self) -> &alloc::sync::Arc<numrs2::parallel::scheduler::ParallelScheduler>
pub fn numrs2::parallel::ParallelContext::shutdown(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::ParallelContext::with_config(scheduler_config: numrs2::parallel::scheduler::SchedulerConfig, balancing_strategy: numrs2::parallel::load_balancer::BalancingStrategy, num_threads: usize) -> numrs2::Result<Self>
pub fn numrs2::parallel::ParallelContext::work_stealing_pool(&self) -> &alloc::sync::Arc<numrs2::parallel::work_stealing::WorkStealingPool>
pub fn numrs2::parallel::ParallelContext::workload_stats(&self) -> numrs2::parallel::load_balancer::WorkloadMetrics
impl core::default::Default for numrs2::parallel::ParallelContext
pub fn numrs2::parallel::ParallelContext::default() -> Self
pub struct numrs2::prelude::ParallelFFT<T>
impl<T: numrs2::traits::FloatingPoint + core::marker::Send + core::marker::Sync + core::marker::Copy> numrs2::parallel::parallel_algorithms::ParallelFFT<T>
pub fn numrs2::parallel::parallel_algorithms::ParallelFFT<T>::new(config: numrs2::parallel::parallel_algorithms::ParallelConfig) -> numrs2::Result<Self>
pub fn numrs2::parallel::parallel_algorithms::ParallelFFT<T>::parallel_fft(&self, data: &mut [num_complex::Complex<T>]) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_algorithms::ParallelFFT<T>::parallel_ifft(&self, data: &mut [num_complex::Complex<T>]) -> numrs2::Result<()>
pub struct numrs2::prelude::ParallelLinAlg
impl numrs2::linalg_parallel::ParallelLinAlg
pub fn numrs2::linalg_parallel::ParallelLinAlg::compute_load_balance_strategy<T>(a: &numrs2::array::Array<T>, operation: &str, num_threads: usize) -> alloc::string::String where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::linalg_parallel::ParallelLinAlg::optimal_block_size(m: usize, n: usize, num_threads: usize) -> (usize, usize)
pub fn numrs2::linalg_parallel::ParallelLinAlg::parallel_gemm<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, c: &mut numrs2::array::Array<T>, alpha: T, beta: T, trans_a: bool, trans_b: bool, num_threads: core::option::Option<usize>) -> numrs2::Result<()> where T: num_traits::float::Float + num_traits::NumAssign + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::linalg_parallel::ParallelLinAlg::parallel_lu<T>(a: &numrs2::array::Array<T>, num_threads: core::option::Option<usize>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<usize>)> where T: num_traits::float::Float + num_traits::NumAssign + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::linalg_parallel::ParallelLinAlg::parallel_matvec<T>(a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &mut numrs2::array::Array<T>, alpha: T, beta: T, trans: bool, num_threads: core::option::Option<usize>) -> numrs2::Result<()> where T: num_traits::float::Float + num_traits::NumAssign + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::linalg_parallel::ParallelLinAlg::parallel_qr<T>(a: &numrs2::array::Array<T>, num_threads: core::option::Option<usize>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::marker::Send + core::marker::Sync + 'static
pub struct numrs2::prelude::ParallelMatrixOps
impl numrs2::parallel::parallel_algorithms::ParallelMatrixOps
pub fn numrs2::parallel::parallel_algorithms::ParallelMatrixOps::new(config: numrs2::parallel::parallel_algorithms::ParallelConfig) -> numrs2::Result<Self>
pub fn numrs2::parallel::parallel_algorithms::ParallelMatrixOps::parallel_matmul<T>(&self, a: &[T], b: &[T], c: &mut [T], m: usize, n: usize, k: usize) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::parallel::parallel_algorithms::ParallelMatrixOps::parallel_transpose<T>(&self, src: &[T], dst: &mut [T], rows: usize, cols: usize) -> numrs2::Result<()> where T: numrs2::traits::NumericElement + core::marker::Send + core::marker::Sync + core::marker::Copy
pub struct numrs2::prelude::ParallelScheduler
impl numrs2::parallel::scheduler::ParallelScheduler
pub fn numrs2::parallel::scheduler::ParallelScheduler::new(config: numrs2::parallel::scheduler::SchedulerConfig) -> numrs2::Result<Self>
pub fn numrs2::parallel::scheduler::ParallelScheduler::num_threads(&self) -> usize
pub fn numrs2::parallel::scheduler::ParallelScheduler::queue_length(&self) -> usize
pub fn numrs2::parallel::scheduler::ParallelScheduler::shutdown(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::scheduler::ParallelScheduler::statistics(&self) -> numrs2::parallel::scheduler::SchedulerStats
pub fn numrs2::parallel::scheduler::ParallelScheduler::submit_task<F>(&self, task: F, priority: numrs2::parallel::scheduler::TaskPriority, estimated_duration: core::option::Option<core::time::Duration>, thread_affinity: core::option::Option<usize>) -> numrs2::Result<u64> where F: core::ops::function::FnOnce() -> numrs2::parallel::scheduler::TaskResult + core::marker::Send + 'static
pub fn numrs2::parallel::scheduler::ParallelScheduler::submit_urgent_task<F>(&self, task: F) -> numrs2::Result<u64> where F: core::ops::function::FnOnce() -> numrs2::parallel::scheduler::TaskResult + core::marker::Send + 'static
pub struct numrs2::prelude::Polynomial<T>
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::math_extended::Polynomial<T>::coefficients(&self) -> &[T]
pub fn numrs2::math_extended::Polynomial<T>::degree(&self) -> usize
pub fn numrs2::math_extended::Polynomial<T>::new(coefficients: alloc::vec::Vec<T>) -> Self
pub fn numrs2::math_extended::Polynomial<T>::to_array(&self) -> numrs2::array::Array<T>
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::Polynomial<T>::evaluate(&self, x: T) -> T
pub fn numrs2::math_extended::Polynomial<T>::evaluate_array(&self, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::math_extended::Polynomial<T>::monomial(degree: usize) -> Self
pub fn numrs2::math_extended::Polynomial<T>::one() -> Self
pub fn numrs2::math_extended::Polynomial<T>::zero() -> Self
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::Polynomial<T>::definite_integral(&self, a: T, b: T) -> T
pub fn numrs2::math_extended::Polynomial<T>::derivative(&self) -> Self
pub fn numrs2::math_extended::Polynomial<T>::integral(&self) -> Self
impl<T> numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq
pub fn numrs2::math_extended::Polynomial<T>::divide(&self, divisor: &Self) -> numrs2::Result<(Self, Self)>
impl<T> core::ops::arith::Add for numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::cmp::PartialEq
pub type numrs2::math_extended::Polynomial<T>::Output = numrs2::math_extended::Polynomial<T>
pub fn numrs2::math_extended::Polynomial<T>::add(self, other: numrs2::math_extended::Polynomial<T>) -> numrs2::math_extended::Polynomial<T>
impl<T> core::ops::arith::Mul for numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub type numrs2::math_extended::Polynomial<T>::Output = numrs2::math_extended::Polynomial<T>
pub fn numrs2::math_extended::Polynomial<T>::mul(self, other: numrs2::math_extended::Polynomial<T>) -> numrs2::math_extended::Polynomial<T>
impl<T> core::ops::arith::Sub for numrs2::math_extended::Polynomial<T> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Sub<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub type numrs2::math_extended::Polynomial<T>::Output = numrs2::math_extended::Polynomial<T>
pub fn numrs2::math_extended::Polynomial<T>::sub(self, other: numrs2::math_extended::Polynomial<T>) -> numrs2::math_extended::Polynomial<T>
pub struct numrs2::prelude::PolynomialInterpolation
impl numrs2::math_extended::PolynomialInterpolation
pub fn numrs2::math_extended::PolynomialInterpolation::lagrange<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T>
pub fn numrs2::math_extended::PolynomialInterpolation::newton<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T>
pub struct numrs2::prelude::PoolAllocator
impl numrs2::memory_alloc::pool::PoolAllocator
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate(&self) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::pool::PoolAllocator::available_blocks(&self) -> usize
pub fn numrs2::memory_alloc::pool::PoolAllocator::block_size(&self) -> usize
pub unsafe fn numrs2::memory_alloc::pool::PoolAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>)
pub fn numrs2::memory_alloc::pool::PoolAllocator::new(config: numrs2::memory_alloc::pool::PoolConfig) -> Self
pub fn numrs2::memory_alloc::pool::PoolAllocator::reset(&self)
pub fn numrs2::memory_alloc::pool::PoolAllocator::total_blocks(&self) -> usize
pub fn numrs2::memory_alloc::pool::PoolAllocator::used_blocks(&self) -> usize
impl numrs2::memory_alloc::strategy::MemoryAllocator for numrs2::memory_alloc::pool::PoolAllocator
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate(&self, size: usize) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::pool::PoolAllocator::allocate_layout(&self, layout: core::alloc::layout::Layout) -> core::option::Option<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::pool::PoolAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, _layout: core::alloc::layout::Layout)
pub struct numrs2::prelude::PoolConfig
pub numrs2::prelude::PoolConfig::auto_resize: bool
pub numrs2::prelude::PoolConfig::block_size: usize
pub numrs2::prelude::PoolConfig::growth_factor: f64
pub numrs2::prelude::PoolConfig::initial_blocks: usize
pub numrs2::prelude::PoolConfig::max_blocks: core::option::Option<usize>
impl core::default::Default for numrs2::memory_alloc::pool::PoolConfig
pub fn numrs2::memory_alloc::pool::PoolConfig::default() -> Self
pub struct numrs2::prelude::PrintOptions
pub numrs2::prelude::PrintOptions::edgeitems: usize
pub numrs2::prelude::PrintOptions::linewidth: usize
pub numrs2::prelude::PrintOptions::precision: usize
pub numrs2::prelude::PrintOptions::prefix: alloc::string::String
pub numrs2::prelude::PrintOptions::separator: alloc::string::String
pub numrs2::prelude::PrintOptions::sign: char
pub numrs2::prelude::PrintOptions::suffix: alloc::string::String
pub numrs2::prelude::PrintOptions::suppress: bool
pub numrs2::prelude::PrintOptions::threshold: usize
impl core::clone::Clone for numrs2::printing::PrintOptions
pub fn numrs2::printing::PrintOptions::clone(&self) -> Self
impl core::default::Default for numrs2::printing::PrintOptions
pub fn numrs2::printing::PrintOptions::default() -> Self
pub struct numrs2::prelude::QRPivotedResult<T: core::clone::Clone>
pub numrs2::prelude::QRPivotedResult::condition_number: T
pub numrs2::prelude::QRPivotedResult::p: numrs2::array::Array<f64>
pub numrs2::prelude::QRPivotedResult::q: numrs2::array::Array<T>
pub numrs2::prelude::QRPivotedResult::r: numrs2::array::Array<T>
pub numrs2::prelude::QRPivotedResult::rank: usize
pub struct numrs2::prelude::RandomState
impl numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::beta<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::cauchy<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::choice<T: core::clone::Clone>(&self, array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::dirichlet<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, alpha: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::geometric<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::get_rng(&self) -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'_, scirs2_core::random::prelude::StdRng>>
pub fn numrs2::random::state::RandomState::gumbel<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::hypergeometric<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, ngood: usize, nbad: usize, nsample: usize, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::integers<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::random::state::RandomState::laplace<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::logistic<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::logseries<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multinomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: usize, pvals: &[f64], shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multivariate_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multivariate_normal_with_rotation<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>, rotation: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::negative_binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: f64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::new() -> Self
pub fn numrs2::random::state::RandomState::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::pareto<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, alpha: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::permutation<T: num_traits::cast::NumCast + core::clone::Clone>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::pert<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, min: T, mode: T, max: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::poisson<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::state::RandomState::rayleigh<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::shuffle<T: core::clone::Clone>(&self, array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::state::RandomState::standard_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::student_t<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::triangular<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, low: T, mode: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::wald<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::weibull<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::with_seed(seed: u64) -> Self
pub fn numrs2::random::state::RandomState::zipf<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, a: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
impl numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::copula<T>(&self, corr: &numrs2::array::Array<T>, n: usize, copula_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::latin_hypercube<T>(&self, dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::maxwell<T>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::mixture_of_normals<T>(&self, weights: &[T], means: &[T], stds: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::multivariate_normal_cholesky<T>(&self, means: &[T], cov: &numrs2::array::Array<T>, size: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::noncentral_chisquare<T>(&self, df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::noncentral_f<T>(&self, dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::power<T>(&self, a: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::random_correlation_matrix<T>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::random::state::RandomState::sobol_sequence<T>(&self, dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::truncated_normal<T>(&self, mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::vonmises<T>(&self, mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
impl core::default::Default for numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::default() -> Self
pub struct numrs2::prelude::RecordArray
impl numrs2::types::structured::RecordArray
pub fn numrs2::types::structured::RecordArray::add_field(&mut self, field_name: &str, data: numrs2::array::Array<f64>) -> numrs2::Result<()>
pub fn numrs2::types::structured::RecordArray::dtype(&self) -> &numrs2::types::structured::DType
pub fn numrs2::types::structured::RecordArray::field(&self, field_name: &str) -> numrs2::Result<&numrs2::array::Array<f64>>
pub fn numrs2::types::structured::RecordArray::field_mut(&mut self, field_name: &str) -> numrs2::Result<&mut numrs2::array::Array<f64>>
pub fn numrs2::types::structured::RecordArray::field_names(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::types::structured::RecordArray::from_arrays(arrays: &std::collections::hash::map::HashMap<alloc::string::String, numrs2::array::Array<f64>>, shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::types::structured::RecordArray::ndim(&self) -> usize
pub fn numrs2::types::structured::RecordArray::new(shape: &[usize], fields: alloc::vec::Vec<numrs2::types::structured::Field>) -> Self
pub fn numrs2::types::structured::RecordArray::remove_field(&mut self, field_name: &str) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::types::structured::RecordArray::set_field(&mut self, index: &[usize], field_name: &str, value: f64) -> numrs2::Result<()>
pub fn numrs2::types::structured::RecordArray::shape(&self) -> &[usize]
pub fn numrs2::types::structured::RecordArray::size(&self) -> usize
impl core::fmt::Display for numrs2::types::structured::RecordArray
pub fn numrs2::types::structured::RecordArray::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::prelude::SVDStableResult<T: core::clone::Clone>
pub numrs2::prelude::SVDStableResult::condition_number: T
pub numrs2::prelude::SVDStableResult::rank: usize
pub numrs2::prelude::SVDStableResult::s: numrs2::array::Array<T>
pub numrs2::prelude::SVDStableResult::u: numrs2::array::Array<T>
pub numrs2::prelude::SVDStableResult::vt: numrs2::array::Array<T>
pub struct numrs2::prelude::ScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
impl<T, E, F> numrs2::expr::ScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::expr::ScalarExpr<T, E, F>::new(expr: E, scalar: T, op: F) -> Self
impl<E, F> numrs2::expr::SimdEval<f64> for numrs2::expr::ScalarExpr<f64, E, F> where E: numrs2::expr::Expr<f64>, F: core::ops::function::Fn(f64, f64) -> f64
impl<T, E, F> numrs2::expr::Expr<T> for numrs2::expr::ScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::expr::ScalarExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::ScalarExpr<T, E, F>::shape(&self) -> &[usize]
pub fn numrs2::expr::ScalarExpr<T, E, F>::size(&self) -> usize
pub struct numrs2::prelude::SchedulerConfig
pub numrs2::prelude::SchedulerConfig::cache_aware_scheduling: bool
pub numrs2::prelude::SchedulerConfig::enable_adaptive_scheduling: bool
pub numrs2::prelude::SchedulerConfig::enable_thread_affinity: bool
pub numrs2::prelude::SchedulerConfig::max_queue_size: usize
pub numrs2::prelude::SchedulerConfig::num_threads: usize
pub numrs2::prelude::SchedulerConfig::time_slice_ms: u64
pub numrs2::prelude::SchedulerConfig::work_stealing_threshold: usize
impl numrs2::parallel::scheduler::SchedulerConfig
pub fn numrs2::parallel::scheduler::SchedulerConfig::latency_optimized(num_cores: usize) -> Self
pub fn numrs2::parallel::scheduler::SchedulerConfig::optimal_for_cores(num_cores: usize) -> Self
pub fn numrs2::parallel::scheduler::SchedulerConfig::throughput_optimized(num_cores: usize) -> Self
pub struct numrs2::prelude::Shape
pub numrs2::prelude::Shape::dims: alloc::vec::Vec<usize>
impl numrs2::arrays::Shape
pub fn numrs2::arrays::Shape::broadcast_with(&self, other: &numrs2::arrays::Shape) -> numrs2::Result<numrs2::arrays::Shape>
pub fn numrs2::arrays::Shape::c_strides(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::arrays::Shape::f_strides(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::arrays::Shape::from_1d(size: usize) -> Self
pub fn numrs2::arrays::Shape::from_2d(rows: usize, cols: usize) -> Self
pub fn numrs2::arrays::Shape::is_broadcastable_with(&self, other: &numrs2::arrays::Shape) -> bool
pub fn numrs2::arrays::Shape::ndim(&self) -> usize
pub fn numrs2::arrays::Shape::new(dims: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::arrays::Shape::reshape(&self, new_dims: alloc::vec::Vec<usize>) -> numrs2::Result<numrs2::arrays::Shape>
pub fn numrs2::arrays::Shape::size(&self) -> usize
pub fn numrs2::arrays::Shape::transpose(&self, axes: core::option::Option<alloc::vec::Vec<usize>>) -> numrs2::Result<numrs2::arrays::Shape>
pub struct numrs2::prelude::SharedArray<T>
impl<T: core::clone::Clone> numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::add(&self, other: &Self) -> numrs2::Result<Self> where T: core::ops::arith::Add<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::as_arc_array(&self) -> &ndarray::ArcArray<T, ndarray::aliases::IxDyn>
pub fn numrs2::shared_array::SharedArray<T>::div(&self, other: &Self) -> numrs2::Result<Self> where T: core::ops::arith::Div<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::flatten(&self) -> Self
pub fn numrs2::shared_array::SharedArray<T>::from_arc_array(data: ndarray::ArcArray<T, ndarray::aliases::IxDyn>) -> Self
pub fn numrs2::shared_array::SharedArray<T>::from_array(arr: numrs2::array::Array<T>) -> Self
pub fn numrs2::shared_array::SharedArray<T>::from_vec(data: alloc::vec::Vec<T>) -> Self
pub fn numrs2::shared_array::SharedArray<T>::from_vec_with_shape(data: alloc::vec::Vec<T>, shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::shared_array::SharedArray<T>::full(shape: &[usize], value: T) -> Self
pub fn numrs2::shared_array::SharedArray<T>::get(&self, indices: &[usize]) -> core::option::Option<&T>
pub fn numrs2::shared_array::SharedArray<T>::get_mut(&mut self, indices: &[usize]) -> core::option::Option<&mut T>
pub fn numrs2::shared_array::SharedArray<T>::is_empty(&self) -> bool
pub fn numrs2::shared_array::SharedArray<T>::is_unique(&self) -> bool
pub fn numrs2::shared_array::SharedArray<T>::max(&self) -> core::option::Option<T> where T: core::cmp::PartialOrd + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::mean(&self) -> core::option::Option<T> where T: num_traits::float::Float + num_traits::cast::NumCast
pub fn numrs2::shared_array::SharedArray<T>::min(&self) -> core::option::Option<T> where T: core::cmp::PartialOrd + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::mul(&self, other: &Self) -> numrs2::Result<Self> where T: core::ops::arith::Mul<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::ndim(&self) -> usize
pub fn numrs2::shared_array::SharedArray<T>::ones(shape: &[usize]) -> Self where T: num_traits::identities::One
pub fn numrs2::shared_array::SharedArray<T>::ref_count(&self) -> usize
pub fn numrs2::shared_array::SharedArray<T>::reshape(&self, new_shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::shared_array::SharedArray<T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::shared_array::SharedArray<T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::shared_array::SharedArray<T>::size(&self) -> usize
pub fn numrs2::shared_array::SharedArray<T>::strides(&self) -> alloc::vec::Vec<isize>
pub fn numrs2::shared_array::SharedArray<T>::sub(&self, other: &Self) -> numrs2::Result<Self> where T: core::ops::arith::Sub<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::sum(&self) -> T where T: num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::to_owned_array(&self) -> numrs2::array::Array<T>
pub fn numrs2::shared_array::SharedArray<T>::to_vec(&self) -> alloc::vec::Vec<T>
pub fn numrs2::shared_array::SharedArray<T>::transpose(&self) -> Self
pub fn numrs2::shared_array::SharedArray<T>::view(&self) -> ndarray::ArrayView<'_, T, ndarray::aliases::IxDyn>
pub fn numrs2::shared_array::SharedArray<T>::zeros(shape: &[usize]) -> Self where T: num_traits::identities::Zero
impl<T: core::clone::Clone> numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::add_scalar(&self, scalar: T) -> Self where T: core::ops::arith::Add<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::div_scalar(&self, scalar: T) -> Self where T: core::ops::arith::Div<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::mul_scalar(&self, scalar: T) -> Self where T: core::ops::arith::Mul<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::neg(&self) -> Self where T: core::ops::arith::Neg<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::sub_scalar(&self, scalar: T) -> Self where T: core::ops::arith::Sub<Output = T> + core::marker::Copy
impl<T: core::clone::Clone> numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::shared_view(&self) -> numrs2::shared_array::SharedArrayView<T>
impl<T: core::clone::Clone + core::cmp::PartialEq> core::cmp::PartialEq for numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::eq(&self, other: &Self) -> bool
impl<T: core::clone::Clone> core::convert::From<alloc::vec::Vec<T>> for numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::from(vec: alloc::vec::Vec<T>) -> Self
impl<T: core::clone::Clone> core::convert::From<numrs2::array::Array<T>> for numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::from(arr: numrs2::array::Array<T>) -> Self
impl<T: core::clone::Clone> core::convert::From<numrs2::shared_array::SharedArray<T>> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::from(shared: numrs2::shared_array::SharedArray<T>) -> Self
impl<T: core::clone::Clone> core::ops::index::Index<&[usize]> for numrs2::shared_array::SharedArray<T>
pub type numrs2::shared_array::SharedArray<T>::Output = T
pub fn numrs2::shared_array::SharedArray<T>::index(&self, indices: &[usize]) -> &Self::Output
impl<T: core::fmt::Debug + core::clone::Clone> core::fmt::Debug for numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::fmt::Display + core::clone::Clone> core::fmt::Display for numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T> core::ops::arith::Add for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::add(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Add for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::add(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Add<&numrs2::shared_array::SharedArray<T>> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::add(self, rhs: &numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Add<T> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::add(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Add<T> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::add(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Add<numrs2::shared_array::SharedArray<T>> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::add(self, rhs: numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Div for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::div(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Div for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::div(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Div<&numrs2::shared_array::SharedArray<T>> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::div(self, rhs: &numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Div<T> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::div(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Div<T> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::div(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Div<numrs2::shared_array::SharedArray<T>> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::div(self, rhs: numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Mul for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::mul(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Mul for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::mul(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Mul<&numrs2::shared_array::SharedArray<T>> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::mul(self, rhs: &numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Mul<T> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::mul(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Mul<T> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::mul(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Mul<numrs2::shared_array::SharedArray<T>> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::mul(self, rhs: numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Neg for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Neg<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::neg(self) -> Self::Output
impl<T> core::ops::arith::Neg for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Neg<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::neg(self) -> Self::Output
impl<T> core::ops::arith::Sub for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::sub(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Sub for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::sub(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Sub<&numrs2::shared_array::SharedArray<T>> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::sub(self, rhs: &numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Sub<T> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::sub(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Sub<T> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::sub(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Sub<numrs2::shared_array::SharedArray<T>> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::sub(self, rhs: numrs2::shared_array::SharedArray<T>) -> Self::Output
pub struct numrs2::prelude::SharedArrayExpr<T: core::clone::Clone>
impl<T: core::clone::Clone> numrs2::expr::SharedArrayExpr<T>
pub fn numrs2::expr::SharedArrayExpr<T>::from_array(array: numrs2::array::Array<T>) -> Self
pub fn numrs2::expr::SharedArrayExpr<T>::new(array: numrs2::shared_array::SharedArray<T>) -> Self
impl<T: core::clone::Clone> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedArrayExpr<T>
pub fn numrs2::expr::SharedArrayExpr<T>::eval(&self) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::SharedArrayExpr<T>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedArrayExpr<T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedArrayExpr<T>::size(&self) -> usize
pub struct numrs2::prelude::SharedArrayView<T>
impl<T: core::clone::Clone> numrs2::shared_array::SharedArrayView<T>
pub fn numrs2::shared_array::SharedArrayView<T>::get(&self, indices: &[usize]) -> core::option::Option<&T>
pub fn numrs2::shared_array::SharedArrayView<T>::new(source: numrs2::shared_array::SharedArray<T>) -> Self
pub fn numrs2::shared_array::SharedArrayView<T>::shape(&self) -> &[usize]
pub fn numrs2::shared_array::SharedArrayView<T>::slice(source: numrs2::shared_array::SharedArray<T>, offset: alloc::vec::Vec<usize>, shape: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::shared_array::SharedArrayView<T>::to_shared_array(&self) -> numrs2::shared_array::SharedArray<T>
pub struct numrs2::prelude::SharedBinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::SharedExpr<T>, R: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
impl<T, L, R, F> numrs2::expr::SharedBinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::SharedExpr<T>, R: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::new(left: L, right: R, op: F) -> numrs2::Result<Self>
impl<T, L, R, F> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedBinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::SharedExpr<T>, R: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::size(&self) -> usize
pub struct numrs2::prelude::SharedExprBuilder<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>>
impl<T: core::clone::Clone + core::ops::arith::Add<Output = T>, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExprBuilder<T, E>
pub fn numrs2::expr::SharedExprBuilder<T, E>::add_scalar(self, scalar: T) -> numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedScalarExpr<T, E, fn(T, T) -> T>> where T: 'static
impl<T: core::clone::Clone + core::ops::arith::Div<Output = T>, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExprBuilder<T, E>
pub fn numrs2::expr::SharedExprBuilder<T, E>::div_scalar(self, scalar: T) -> numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedScalarExpr<T, E, fn(T, T) -> T>> where T: 'static
impl<T: core::clone::Clone + core::ops::arith::Mul<Output = T>, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExprBuilder<T, E>
pub fn numrs2::expr::SharedExprBuilder<T, E>::mul_scalar(self, scalar: T) -> numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedScalarExpr<T, E, fn(T, T) -> T>> where T: 'static
impl<T: core::clone::Clone + core::ops::arith::Sub<Output = T>, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExprBuilder<T, E>
pub fn numrs2::expr::SharedExprBuilder<T, E>::sub_scalar(self, scalar: T) -> numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedScalarExpr<T, E, fn(T, T) -> T>> where T: 'static
impl<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExprBuilder<T, E>
pub fn numrs2::expr::SharedExprBuilder<T, E>::eval(self) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::SharedExprBuilder<T, E>::into_expr(self) -> E
pub fn numrs2::expr::SharedExprBuilder<T, E>::map<F>(self, op: F) -> numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedUnaryExpr<T, E, F>> where F: core::ops::function::Fn(T) -> T + core::clone::Clone
impl<T: core::clone::Clone> numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedArrayExpr<T>>
pub fn numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedArrayExpr<T>>::from_array(array: numrs2::array::Array<T>) -> Self
pub fn numrs2::expr::SharedExprBuilder<T, numrs2::expr::SharedArrayExpr<T>>::from_shared_array(array: numrs2::shared_array::SharedArray<T>) -> Self
pub struct numrs2::prelude::SharedScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
impl<T, E, F> numrs2::expr::SharedScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::new(expr: E, scalar: T, op: F) -> Self
impl<T, E, F> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::size(&self) -> usize
pub struct numrs2::prelude::SharedUnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T) -> T + core::clone::Clone
impl<T, E, F> numrs2::expr::SharedUnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::new(expr: E, op: F) -> Self
impl<T, E, F> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedUnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::size(&self) -> usize
pub struct numrs2::prelude::SimdOpsResult
pub numrs2::prelude::SimdOpsResult::add: numrs2::array::Array<f64>
pub numrs2::prelude::SimdOpsResult::div: numrs2::array::Array<f64>
pub numrs2::prelude::SimdOpsResult::mul: numrs2::array::Array<f64>
pub numrs2::prelude::SimdOpsResult::sub: numrs2::array::Array<f64>
pub struct numrs2::prelude::SimdVectorResult
pub numrs2::prelude::SimdVectorResult::max: f32
pub numrs2::prelude::SimdVectorResult::mean: f32
pub numrs2::prelude::SimdVectorResult::min: f32
pub numrs2::prelude::SimdVectorResult::norm: f32
pub numrs2::prelude::SimdVectorResult::sum: f32
pub struct numrs2::prelude::SparseArray<T>
pub numrs2::prelude::SparseArray::data: std::collections::hash::map::HashMap<alloc::vec::Vec<usize>, T>
pub numrs2::prelude::SparseArray::shape: alloc::vec::Vec<usize>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Add<Output = T>
pub fn numrs2::sparse::SparseArray<T>::add(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Div<Output = T>
pub fn numrs2::sparse::SparseArray<T>::divide(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
pub fn numrs2::sparse::SparseArray<T>::divide_scalar(&self, scalar: T) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Mul<Output = T>
pub fn numrs2::sparse::SparseArray<T>::multiply(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
pub fn numrs2::sparse::SparseArray<T>::multiply_scalar(&self, scalar: T) -> numrs2::sparse::SparseArray<T>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Sub<Output = T>
pub fn numrs2::sparse::SparseArray<T>::subtract(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero
pub fn numrs2::sparse::SparseArray<T>::density(&self) -> f64
pub fn numrs2::sparse::SparseArray<T>::from_array(array: &numrs2::array::Array<T>) -> Self
pub fn numrs2::sparse::SparseArray<T>::get(&self, indices: &[usize]) -> numrs2::Result<T>
pub fn numrs2::sparse::SparseArray<T>::ndim(&self) -> usize
pub fn numrs2::sparse::SparseArray<T>::new(shape: &[usize]) -> Self
pub fn numrs2::sparse::SparseArray<T>::nnz(&self) -> usize
pub fn numrs2::sparse::SparseArray<T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseArray<T>::shape(&self) -> &[usize]
pub fn numrs2::sparse::SparseArray<T>::to_array(&self) -> numrs2::array::Array<T>
pub struct numrs2::prelude::SparseMatrix<T>
pub numrs2::prelude::SparseMatrix::array: numrs2::sparse::SparseArray<T>
pub numrs2::prelude::SparseMatrix::diag_offsets: core::option::Option<alloc::vec::Vec<isize>>
pub numrs2::prelude::SparseMatrix::format: numrs2::sparse::SparseMatrixFormat
pub numrs2::prelude::SparseMatrix::indices: core::option::Option<alloc::vec::Vec<usize>>
pub numrs2::prelude::SparseMatrix::indptr: core::option::Option<alloc::vec::Vec<usize>>
impl<T> numrs2::sparse::SparseMatrix<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::fmt::Debug
pub fn numrs2::sparse::SparseMatrix<T>::density(&self) -> f64
pub fn numrs2::sparse::SparseMatrix<T>::diag(diagonal: &[T]) -> numrs2::Result<Self>
pub fn numrs2::sparse::SparseMatrix<T>::eye(n: usize) -> numrs2::Result<Self> where T: num_traits::identities::One
pub fn numrs2::sparse::SparseMatrix<T>::from_array(array: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub fn numrs2::sparse::SparseMatrix<T>::get(&self, row: usize, col: usize) -> numrs2::Result<T>
pub fn numrs2::sparse::SparseMatrix<T>::new(shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::sparse::SparseMatrix<T>::nnz(&self) -> usize
pub fn numrs2::sparse::SparseMatrix<T>::set(&mut self, row: usize, col: usize, value: T) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseMatrix<T>::shape(&self) -> &[usize]
pub fn numrs2::sparse::SparseMatrix<T>::to_array(&self) -> numrs2::array::Array<T>
pub fn numrs2::sparse::SparseMatrix<T>::to_csc(&mut self) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseMatrix<T>::to_csr(&mut self) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseMatrix<T>::to_dia(&mut self) -> numrs2::Result<()>
impl<T> numrs2::sparse::SparseMatrix<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::fmt::Debug
pub fn numrs2::sparse::SparseMatrix<T>::matmul(&self, other: &numrs2::sparse::SparseMatrix<T>) -> numrs2::Result<numrs2::sparse::SparseMatrix<T>>
pub fn numrs2::sparse::SparseMatrix<T>::transpose(&self) -> numrs2::Result<numrs2::sparse::SparseMatrix<T>>
pub struct numrs2::prelude::SparseOpsAdvanced
impl numrs2::sparse_enhanced::SparseOpsAdvanced
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::condition_number_estimate<T>(a: &numrs2::sparse::SparseMatrix<T>, max_iter: usize, tol: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::incomplete_lu<T>(a: &numrs2::sparse::SparseMatrix<T>, _fill_factor: f64) -> numrs2::Result<(numrs2::sparse::SparseMatrix<T>, numrs2::sparse::SparseMatrix<T>)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::solve_bicgstab<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: T, max_iter: usize) -> numrs2::Result<(numrs2::array::Array<T>, usize, T)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::solve_cg<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: T, max_iter: usize) -> numrs2::Result<(numrs2::array::Array<T>, usize, T)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::solve_gmres<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: T, max_iter: usize, restart: usize) -> numrs2::Result<(numrs2::array::Array<T>, usize, T)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::spgemm<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::sparse::SparseMatrix<T>) -> numrs2::Result<numrs2::sparse::SparseMatrix<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::spmv_dense<T>(a: &numrs2::sparse::SparseMatrix<T>, x: &numrs2::array::Array<T>, y: &mut numrs2::array::Array<T>, alpha: T, beta: T) -> numrs2::Result<()> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub struct numrs2::prelude::SpecializedIndexing
impl numrs2::arrays::SpecializedIndexing
pub fn numrs2::arrays::SpecializedIndexing::index_with_coordinates<T>(array: &numrs2::arrays::ArrayView<'_, T>, coordinates: &[alloc::vec::Vec<usize>]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::SpecializedIndexing::meshgrid_index<T>(array: &numrs2::arrays::ArrayView<'_, T>, grid_indices: &[alloc::vec::Vec<usize>]) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub fn numrs2::arrays::SpecializedIndexing::multi_boolean_index<T>(array: &numrs2::arrays::ArrayView<'_, T>, conditions: &[alloc::vec::Vec<bool>], combine_op: numrs2::arrays::BooleanCombineOp) -> numrs2::Result<alloc::vec::Vec<T>> where T: numrs2::traits::NumericElement + core::marker::Copy
pub struct numrs2::prelude::StableDecompositions
impl numrs2::linalg_stable::StableDecompositions
pub fn numrs2::linalg_stable::StableDecompositions::cholesky_stable<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::linalg_stable::CholeskyStableResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::linalg_stable::StableDecompositions::qr_pivoted<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::linalg_stable::QRPivotedResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::linalg_stable::StableDecompositions::svd_stable<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::linalg_stable::SVDStableResult<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::linalg_stable::StableDecompositions::symmetric_eigendecomposition<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<(alloc::vec::Vec<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub struct numrs2::prelude::StdBitGenerator
impl numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::new(seed: u64) -> Self
pub fn numrs2::random::generator::StdBitGenerator::new_random() -> Self
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::StdBitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::StdBitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::StdBitGenerator::seed(&mut self, seed: u64)
pub struct numrs2::prelude::StrideOptimizer
impl numrs2::memory_optimize::access_patterns::StrideOptimizer
pub fn numrs2::memory_optimize::access_patterns::StrideOptimizer::bandwidth_efficiency(&self) -> f64
pub fn numrs2::memory_optimize::access_patterns::StrideOptimizer::new(shape: &[usize], strides: &[usize]) -> Self
pub fn numrs2::memory_optimize::access_patterns::StrideOptimizer::optimal_iteration_order(&self) -> &[usize]
pub fn numrs2::memory_optimize::access_patterns::StrideOptimizer::should_copy(&self) -> bool
pub struct numrs2::prelude::StridedArrayView<'a, T>
impl<'a, T: core::clone::Clone> numrs2::views::StridedArrayView<'a, T>
pub fn numrs2::views::StridedArrayView<'a, T>::get(&self, indices: &[usize]) -> core::option::Option<&T>
pub fn numrs2::views::StridedArrayView<'a, T>::iter(&self) -> impl core::iter::traits::iterator::Iterator<Item = T> + '_
pub fn numrs2::views::StridedArrayView<'a, T>::ndim(&self) -> usize
pub fn numrs2::views::StridedArrayView<'a, T>::new(data: &'a [T], shape: alloc::vec::Vec<usize>, strides: alloc::vec::Vec<isize>, offset: usize) -> Self
pub fn numrs2::views::StridedArrayView<'a, T>::shape(&self) -> &[usize]
pub fn numrs2::views::StridedArrayView<'a, T>::size(&self) -> usize
pub fn numrs2::views::StridedArrayView<'a, T>::strides(&self) -> &[isize]
pub fn numrs2::views::StridedArrayView<'a, T>::subview(&self, axis: usize, index: usize) -> core::option::Option<numrs2::views::StridedArrayView<'a, T>>
pub fn numrs2::views::StridedArrayView<'a, T>::to_owned(&self) -> numrs2::array::Array<T>
pub fn numrs2::views::StridedArrayView<'a, T>::to_vec(&self) -> alloc::vec::Vec<T>
pub struct numrs2::prelude::StructuredArray
impl numrs2::types::structured::StructuredArray
pub fn numrs2::types::structured::StructuredArray::data(&self) -> &[u8]
pub fn numrs2::types::structured::StructuredArray::dtype(&self) -> &numrs2::types::structured::DType
pub fn numrs2::types::structured::StructuredArray::field<T: core::clone::Clone + core::default::Default + 'static>(&self, field_name: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::types::structured::StructuredArray::from_arrays<T: core::clone::Clone + core::default::Default + 'static>(arrays: &std::collections::hash::map::HashMap<alloc::string::String, numrs2::array::Array<T>>, shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::types::structured::StructuredArray::ndim(&self) -> usize
pub fn numrs2::types::structured::StructuredArray::new(shape: &[usize], dtype: numrs2::types::structured::DType) -> Self
pub fn numrs2::types::structured::StructuredArray::set_field<T: core::clone::Clone + 'static>(&mut self, index: &[usize], field_name: &str, value: T) -> numrs2::Result<()>
pub fn numrs2::types::structured::StructuredArray::shape(&self) -> &[usize]
pub fn numrs2::types::structured::StructuredArray::size(&self) -> usize
impl core::fmt::Display for numrs2::types::structured::StructuredArray
pub fn numrs2::types::structured::StructuredArray::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::prelude::TestResult
pub numrs2::prelude::TestResult::max_abs_diff: core::option::Option<f64>
pub numrs2::prelude::TestResult::max_rel_diff: core::option::Option<f64>
pub numrs2::prelude::TestResult::message: alloc::string::String
pub numrs2::prelude::TestResult::mismatch_count: usize
pub numrs2::prelude::TestResult::passed: bool
impl numrs2::testing::TestResult
pub fn numrs2::testing::TestResult::comparison_result(passed: bool, message: &str, max_abs_diff: f64, max_rel_diff: f64, mismatch_count: usize) -> Self
pub fn numrs2::testing::TestResult::failure(message: &str) -> Self
pub fn numrs2::testing::TestResult::success(message: &str) -> Self
pub struct numrs2::prelude::ThreadLocalAllocator
impl numrs2::parallel::parallel_allocator::ThreadLocalAllocator
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::current_thread_statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub unsafe fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::garbage_collect_current_thread(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::initialize_current_thread<A>(&self, allocator: A) -> numrs2::Result<()> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + 'static
pub fn numrs2::parallel::parallel_allocator::ThreadLocalAllocator::new(config: numrs2::parallel::parallel_allocator::ParallelAllocatorConfig) -> Self
pub struct numrs2::prelude::Tile2D
pub numrs2::prelude::Tile2D::col_end: usize
pub numrs2::prelude::Tile2D::col_start: usize
pub numrs2::prelude::Tile2D::row_end: usize
pub numrs2::prelude::Tile2D::row_start: usize
impl numrs2::memory_optimize::access_patterns::Tile2D
pub fn numrs2::memory_optimize::access_patterns::Tile2D::cols(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::Tile2D::is_empty(&self) -> bool
pub fn numrs2::memory_optimize::access_patterns::Tile2D::len(&self) -> usize
pub fn numrs2::memory_optimize::access_patterns::Tile2D::new(row_start: usize, row_end: usize, col_start: usize, col_end: usize) -> Self
pub fn numrs2::memory_optimize::access_patterns::Tile2D::rows(&self) -> usize
pub struct numrs2::prelude::TiledIterator2D
impl numrs2::memory_optimize::access_patterns::TiledIterator2D
pub fn numrs2::memory_optimize::access_patterns::TiledIterator2D::for_type<T>(total_rows: usize, total_cols: usize, cache: numrs2::memory_optimize::access_patterns::CacheConfig) -> Self
pub fn numrs2::memory_optimize::access_patterns::TiledIterator2D::new(total_rows: usize, total_cols: usize, tile_rows: usize, tile_cols: usize) -> Self
impl core::iter::traits::exact_size::ExactSizeIterator for numrs2::memory_optimize::access_patterns::TiledIterator2D
impl core::iter::traits::iterator::Iterator for numrs2::memory_optimize::access_patterns::TiledIterator2D
pub type numrs2::memory_optimize::access_patterns::TiledIterator2D::Item = numrs2::memory_optimize::access_patterns::Tile2D
pub fn numrs2::memory_optimize::access_patterns::TiledIterator2D::next(&mut self) -> core::option::Option<Self::Item>
pub fn numrs2::memory_optimize::access_patterns::TiledIterator2D::size_hint(&self) -> (usize, core::option::Option<usize>)
pub struct numrs2::prelude::TimeDelta64
impl numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::abs(&self) -> Self
pub fn numrs2::types::datetime::TimeDelta64::from_duration(duration: core::time::Duration, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::TimeDelta64::neg(&self) -> Self
pub fn numrs2::types::datetime::TimeDelta64::new(value: i64, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::TimeDelta64::to_duration(&self) -> core::time::Duration
pub fn numrs2::types::datetime::TimeDelta64::to_unit(&self, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::TimeDelta64::unit(&self) -> numrs2::types::datetime::DateTimeUnit
pub fn numrs2::types::datetime::TimeDelta64::value(&self) -> i64
impl core::fmt::Display for numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Add<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Add<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Div for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = f64
pub fn numrs2::types::datetime::TimeDelta64::div(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Div<i64> for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::div(self, rhs: i64) -> Self::Output
impl core::ops::arith::Mul<i64> for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::mul(self, rhs: i64) -> Self::Output
impl core::ops::arith::Mul<numrs2::types::datetime::TimeDelta64> for i64
pub type i64::Output = numrs2::types::datetime::TimeDelta64
pub fn i64::mul(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Neg for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::neg(self) -> Self::Output
impl core::ops::arith::Sub for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Sub<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Sub<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
pub struct numrs2::prelude::Timezone
pub numrs2::prelude::Timezone::name: alloc::string::String
pub numrs2::prelude::Timezone::offset_minutes: i32
impl numrs2::types::datetime::Timezone
pub fn numrs2::types::datetime::Timezone::cet() -> Self
pub fn numrs2::types::datetime::Timezone::est() -> Self
pub fn numrs2::types::datetime::Timezone::fixed_offset(name: &str, hours: i32, minutes: i32) -> Self
pub fn numrs2::types::datetime::Timezone::jst() -> Self
pub fn numrs2::types::datetime::Timezone::pst() -> Self
pub fn numrs2::types::datetime::Timezone::utc() -> Self
impl core::fmt::Display for numrs2::types::datetime::Timezone
pub fn numrs2::types::datetime::Timezone::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::prelude::TimezoneDateTime
pub numrs2::prelude::TimezoneDateTime::timezone: numrs2::types::datetime::Timezone
pub numrs2::prelude::TimezoneDateTime::utc_datetime: numrs2::types::datetime::DateTime64
impl numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::from_iso_string_with_tz(s: &str, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<Self>
pub fn numrs2::types::datetime::TimezoneDateTime::from_local(local_datetime: numrs2::types::datetime::DateTime64, timezone: numrs2::types::datetime::Timezone) -> Self
pub fn numrs2::types::datetime::TimezoneDateTime::new(utc_datetime: numrs2::types::datetime::DateTime64, timezone: numrs2::types::datetime::Timezone) -> Self
pub fn numrs2::types::datetime::TimezoneDateTime::to_iso_string_with_tz(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::types::datetime::TimezoneDateTime::to_local(&self) -> numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::TimezoneDateTime::to_timezone(&self, new_timezone: numrs2::types::datetime::Timezone) -> Self
impl core::fmt::Display for numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Sub for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimezoneDateTime::sub(self, rhs: numrs2::types::datetime::TimezoneDateTime) -> Self::Output
impl core::ops::arith::Sub<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
pub struct numrs2::prelude::ToleranceConfig
pub numrs2::prelude::ToleranceConfig::atol: f64
pub numrs2::prelude::ToleranceConfig::equal_nan: bool
pub numrs2::prelude::ToleranceConfig::rtol: f64
impl core::default::Default for numrs2::testing::ToleranceConfig
pub fn numrs2::testing::ToleranceConfig::default() -> Self
pub struct numrs2::prelude::UnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T) -> T
impl<T, E, F> numrs2::expr::UnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T) -> T
pub fn numrs2::expr::UnaryExpr<T, E, F>::new(expr: E, op: F) -> Self
impl<E, F> numrs2::expr::SimdEval<f64> for numrs2::expr::UnaryExpr<f64, E, F> where E: numrs2::expr::Expr<f64>, F: core::ops::function::Fn(f64) -> f64
impl<T, E, F> numrs2::expr::Expr<T> for numrs2::expr::UnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T) -> T
pub fn numrs2::expr::UnaryExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::UnaryExpr<T, E, F>::shape(&self) -> &[usize]
pub fn numrs2::expr::UnaryExpr<T, E, F>::size(&self) -> usize
pub struct numrs2::prelude::UnaryUfunc<F> where F: core::ops::function::Fn(f64) -> f64
impl<F> numrs2::ufuncs::UnaryUfunc<F> where F: core::ops::function::Fn(f64) -> f64
pub fn numrs2::ufuncs::UnaryUfunc<F>::call(&self, a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::UnaryUfunc<F>::new(func: F, name: &'static str) -> Self
impl<F> core::fmt::Debug for numrs2::ufuncs::UnaryUfunc<F> where F: core::ops::function::Fn(f64) -> f64
pub fn numrs2::ufuncs::UnaryUfunc<F>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::prelude::UniqueResult<T>
pub numrs2::prelude::UniqueResult::counts: core::option::Option<numrs2::array::Array<usize>>
pub numrs2::prelude::UniqueResult::indices: core::option::Option<numrs2::array::Array<usize>>
pub numrs2::prelude::UniqueResult::inverse: core::option::Option<numrs2::array::Array<usize>>
pub numrs2::prelude::UniqueResult::values: numrs2::array::Array<T>
impl<T: core::clone::Clone> numrs2::unique::UniqueResult<T>
pub fn numrs2::unique::UniqueResult<T>::values(self) -> numrs2::array::Array<T>
pub fn numrs2::unique::UniqueResult<T>::values_counts(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>)>
pub fn numrs2::unique::UniqueResult<T>::values_indices(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>)>
pub fn numrs2::unique::UniqueResult<T>::values_indices_counts(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::unique::UniqueResult<T>::values_indices_inverse(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::unique::UniqueResult<T>::values_indices_inverse_counts(self) -> numrs2::Result<numrs2::unique::UniqueTuple<T>>
pub fn numrs2::unique::UniqueResult<T>::values_inverse(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>)>
pub fn numrs2::unique::UniqueResult<T>::values_inverse_counts(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub struct numrs2::prelude::WindowView<'a, T>
impl<'a, T: core::clone::Clone> numrs2::views::WindowView<'a, T>
pub fn numrs2::views::WindowView<'a, T>::get_window(&self, position: &[usize]) -> core::option::Option<alloc::vec::Vec<T>>
pub fn numrs2::views::WindowView<'a, T>::n_windows(&self) -> &[usize]
pub fn numrs2::views::WindowView<'a, T>::new(data: &'a [T], source_shape: alloc::vec::Vec<usize>, window_shape: alloc::vec::Vec<usize>, step: alloc::vec::Vec<usize>) -> numrs2::Result<Self>
pub fn numrs2::views::WindowView<'a, T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::views::WindowView<'a, T>::to_owned(&self) -> numrs2::array::Array<T>
pub struct numrs2::prelude::WorkStealingPool
impl numrs2::parallel::work_stealing::WorkStealingPool
pub fn numrs2::parallel::work_stealing::WorkStealingPool::active_workers(&self) -> usize
pub fn numrs2::parallel::work_stealing::WorkStealingPool::new(num_threads: usize) -> numrs2::Result<Self>
pub fn numrs2::parallel::work_stealing::WorkStealingPool::pending_tasks(&self) -> usize
pub fn numrs2::parallel::work_stealing::WorkStealingPool::shutdown(&self) -> numrs2::Result<()>
pub fn numrs2::parallel::work_stealing::WorkStealingPool::statistics(&self) -> numrs2::parallel::work_stealing::PoolStats
pub fn numrs2::parallel::work_stealing::WorkStealingPool::submit<T>(&self, task: T) -> numrs2::Result<()> where T: numrs2::parallel::work_stealing::Task<Output = numrs2::parallel::work_stealing::TaskResult<()>> + 'static
pub fn numrs2::parallel::work_stealing::WorkStealingPool::submit_urgent<T>(&self, task: T) -> numrs2::Result<()> where T: numrs2::parallel::work_stealing::Task<Output = numrs2::parallel::work_stealing::TaskResult<()>> + 'static
pub fn numrs2::parallel::work_stealing::WorkStealingPool::with_config(config: numrs2::parallel::work_stealing::WorkStealingConfig) -> numrs2::Result<Self>
pub struct numrs2::prelude::WorkloadMetrics
pub numrs2::prelude::WorkloadMetrics::active_tasks: u64
pub numrs2::prelude::WorkloadMetrics::avg_response_time: core::time::Duration
pub numrs2::prelude::WorkloadMetrics::cache_miss_rate: f64
pub numrs2::prelude::WorkloadMetrics::cpu_utilization: alloc::vec::Vec<f64>
pub numrs2::prelude::WorkloadMetrics::load_imbalance: f64
pub numrs2::prelude::WorkloadMetrics::memory_usage: alloc::vec::Vec<f64>
pub numrs2::prelude::WorkloadMetrics::queue_lengths: alloc::vec::Vec<usize>
pub numrs2::prelude::WorkloadMetrics::total_throughput: f64
pub numrs2::prelude::WorkloadMetrics::work_steals: u64
impl numrs2::parallel::load_balancer::WorkloadMetrics
pub fn numrs2::parallel::load_balancer::WorkloadMetrics::is_balanced(&self, threshold: f64) -> bool
pub fn numrs2::parallel::load_balancer::WorkloadMetrics::least_loaded_worker(&self) -> core::option::Option<usize>
pub fn numrs2::parallel::load_balancer::WorkloadMetrics::load_distribution_cv(&self) -> f64
pub fn numrs2::parallel::load_balancer::WorkloadMetrics::most_loaded_worker(&self) -> core::option::Option<usize>
pub const numrs2::prelude::NEWAXIS: numrs2::array_ops::SliceSpec
pub trait numrs2::prelude::AllocationStrategy: core::marker::Send + core::marker::Sync + core::fmt::Debug
pub fn numrs2::prelude::AllocationStrategy::select_allocator(&self, requirements: &numrs2::traits::AllocationRequirements) -> alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>
pub fn numrs2::prelude::AllocationStrategy::strategy_stats(&self) -> numrs2::traits::StrategyStats
impl numrs2::traits::AllocationStrategy for numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::select_allocator(&self, requirements: &numrs2::traits::AllocationRequirements) -> alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::strategy_stats(&self) -> numrs2::traits::StrategyStats
impl<A> numrs2::traits::AllocationStrategy for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error> + numrs2::traits::AllocationStrategy
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::select_allocator(&self, _requirements: &numrs2::traits::AllocationRequirements) -> alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::strategy_stats(&self) -> numrs2::traits::StrategyStats
pub trait numrs2::prelude::ArrayIndexing<T: numrs2::traits::NumericElement>
pub type numrs2::prelude::ArrayIndexing::Error: core::error::Error
pub type numrs2::prelude::ArrayIndexing::IndexResult
pub fn numrs2::prelude::ArrayIndexing::bool_index(&self, mask: &[bool]) -> numrs2::Result<Self::IndexResult>
pub fn numrs2::prelude::ArrayIndexing::fancy_index(&self, indices: &[&[usize]]) -> numrs2::Result<Self::IndexResult>
pub fn numrs2::prelude::ArrayIndexing::get(&self, indices: &[usize]) -> numrs2::Result<T>
pub fn numrs2::prelude::ArrayIndexing::index(&self, specs: &[numrs2::indexing::IndexSpec]) -> numrs2::Result<Self::IndexResult>
pub fn numrs2::prelude::ArrayIndexing::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::prelude::ArrayIndexing::slice(&self, axis: usize, start: usize, end: core::option::Option<usize>) -> numrs2::Result<Self::IndexResult>
pub trait numrs2::prelude::ArrayMath<T: numrs2::traits::NumericElement>: numrs2::traits::ArrayOps<T>
pub fn numrs2::prelude::ArrayMath::abs(&self) -> Self::Output where T: num_traits::sign::Signed
pub fn numrs2::prelude::ArrayMath::cos(&self) -> Self::Output where T: numrs2::traits::FloatingPoint
pub fn numrs2::prelude::ArrayMath::exp(&self) -> Self::Output where T: numrs2::traits::FloatingPoint
pub fn numrs2::prelude::ArrayMath::ln(&self) -> Self::Output where T: numrs2::traits::FloatingPoint
pub fn numrs2::prelude::ArrayMath::pow(&self, exponent: T) -> Self::Output where T: numrs2::traits::FloatingPoint
pub fn numrs2::prelude::ArrayMath::pow_array(&self, exponents: &Self) -> numrs2::Result<Self::Output> where T: numrs2::traits::FloatingPoint
pub fn numrs2::prelude::ArrayMath::sin(&self) -> Self::Output where T: numrs2::traits::FloatingPoint
pub fn numrs2::prelude::ArrayMath::sqrt(&self) -> Self::Output where T: numrs2::traits::FloatingPoint
pub fn numrs2::prelude::ArrayMath::tan(&self) -> Self::Output where T: numrs2::traits::FloatingPoint
pub trait numrs2::prelude::ArrayOps<T: numrs2::traits::NumericElement>
pub type numrs2::prelude::ArrayOps::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub type numrs2::prelude::ArrayOps::Output: numrs2::traits::ArrayOps<T>
pub fn numrs2::prelude::ArrayOps::add(&self, other: &Self) -> numrs2::Result<Self::Output>
pub fn numrs2::prelude::ArrayOps::add_broadcast(&self, other: &Self) -> numrs2::Result<Self::Output>
pub fn numrs2::prelude::ArrayOps::add_scalar(&self, scalar: T) -> Self::Output
pub fn numrs2::prelude::ArrayOps::div(&self, other: &Self) -> numrs2::Result<Self::Output>
pub fn numrs2::prelude::ArrayOps::div_scalar(&self, scalar: T) -> numrs2::Result<Self::Output>
pub fn numrs2::prelude::ArrayOps::mul(&self, other: &Self) -> numrs2::Result<Self::Output>
pub fn numrs2::prelude::ArrayOps::mul_broadcast(&self, other: &Self) -> numrs2::Result<Self::Output>
pub fn numrs2::prelude::ArrayOps::mul_scalar(&self, scalar: T) -> Self::Output
pub fn numrs2::prelude::ArrayOps::sub(&self, other: &Self) -> numrs2::Result<Self::Output>
pub trait numrs2::prelude::ArrayReduction<T: numrs2::traits::NumericElement>: core::marker::Sized
pub type numrs2::prelude::ArrayReduction::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::prelude::ArrayReduction::argmax(&self) -> usize where T: core::cmp::PartialOrd
pub fn numrs2::prelude::ArrayReduction::argmin(&self) -> usize where T: core::cmp::PartialOrd
pub fn numrs2::prelude::ArrayReduction::max(&self) -> T where T: core::cmp::PartialOrd
pub fn numrs2::prelude::ArrayReduction::mean(&self) -> T where T: core::ops::arith::Div<Output = T> + core::convert::From<usize>
pub fn numrs2::prelude::ArrayReduction::mean_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<Self>
pub fn numrs2::prelude::ArrayReduction::min(&self) -> T where T: core::cmp::PartialOrd
pub fn numrs2::prelude::ArrayReduction::std(&self) -> T where T: numrs2::traits::FloatingPoint
pub fn numrs2::prelude::ArrayReduction::std_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<Self>
pub fn numrs2::prelude::ArrayReduction::sum(&self) -> T
pub fn numrs2::prelude::ArrayReduction::sum_axis(&self, axis: usize) -> numrs2::Result<Self>
pub trait numrs2::prelude::AxisOps<T>
pub fn numrs2::prelude::AxisOps::argmax_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::prelude::AxisOps::argmin_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::prelude::AxisOps::cumprod_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::prelude::AxisOps::cumsum_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::AxisOps::max_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::AxisOps::mean_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::AxisOps::min_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::AxisOps::prod_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::prelude::AxisOps::std_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float
pub fn numrs2::prelude::AxisOps::sum_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::AxisOps::var_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float
impl<T> numrs2::axis_ops::AxisOps<T> for numrs2::array::Array<T> where T: core::clone::Clone + core::cmp::PartialOrd + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::cast::NumCast + core::fmt::Debug
pub fn numrs2::array::Array<T>::argmax_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array::Array<T>::argmin_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::array::Array<T>::cumprod_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::array::Array<T>::cumsum_axis(&self, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::max_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::mean_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::min_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::prod_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::ops::arith::Mul<Output = T> + num_traits::identities::One
pub fn numrs2::array::Array<T>::std_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float
pub fn numrs2::array::Array<T>::sum_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::var_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float
pub trait numrs2::prelude::BitGenerator
pub fn numrs2::prelude::BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::prelude::BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::prelude::BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::prelude::BitGenerator::seed(&mut self, seed: u64)
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::PCG64BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::PCG64BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::PCG64BitGenerator::seed(&mut self, seed: u64)
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::StdBitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::StdBitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::StdBitGenerator::seed(&mut self, seed: u64)
pub trait numrs2::prelude::CSESupport<T: core::clone::Clone>: numrs2::expr::SharedExpr<T> + core::marker::Sized
pub fn numrs2::prelude::CSESupport::with_cache(self, cache: numrs2::expr::ExprCache<T>) -> numrs2::expr::CachedExpr<T, Self>
pub fn numrs2::prelude::CSESupport::with_cache_id(self, id: numrs2::expr::ExprId, cache: numrs2::expr::ExprCache<T>) -> numrs2::expr::CachedExpr<T, Self>
impl<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>> numrs2::expr::CSESupport<T> for E
pub trait numrs2::prelude::ComplexElement: numrs2::traits::NumericElement
pub type numrs2::prelude::ComplexElement::Real: numrs2::traits::FloatingPoint
pub fn numrs2::prelude::ComplexElement::conj(&self) -> Self
pub fn numrs2::prelude::ComplexElement::imag(&self) -> Self::Real
pub fn numrs2::prelude::ComplexElement::magnitude(&self) -> Self::Real
pub fn numrs2::prelude::ComplexElement::new(real: Self::Real, imag: Self::Real) -> Self
pub fn numrs2::prelude::ComplexElement::phase(&self) -> Self::Real
pub fn numrs2::prelude::ComplexElement::real(&self) -> Self::Real
impl<T: numrs2::traits::FloatingPoint> numrs2::traits::ComplexElement for num_complex::Complex<T>
pub type num_complex::Complex<T>::Real = T
pub fn num_complex::Complex<T>::conj(&self) -> Self
pub fn num_complex::Complex<T>::imag(&self) -> Self::Real
pub fn num_complex::Complex<T>::magnitude(&self) -> Self::Real
pub fn num_complex::Complex<T>::new(real: Self::Real, imag: Self::Real) -> Self
pub fn num_complex::Complex<T>::phase(&self) -> Self::Real
pub fn num_complex::Complex<T>::real(&self) -> Self::Real
pub trait numrs2::prelude::ConvertibleTo<T>: core::marker::Sized
pub fn numrs2::prelude::ConvertibleTo::convert_to(&self) -> numrs2::Result<T>
impl<S, T> numrs2::conversions::ConvertibleTo<T> for S where S: core::clone::Clone + num_traits::cast::NumCast, T: core::clone::Clone + num_traits::cast::NumCast
pub fn S::convert_to(&self) -> numrs2::Result<T>
pub trait numrs2::prelude::ElementWiseMath<T>
pub fn numrs2::prelude::ElementWiseMath::abs(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::acos(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::acosh(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::asin(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::asinh(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::atan(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::atan2(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::atanh(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::cbrt(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::ceil(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::clip(&self, min: T, max: T) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::cos(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::cosh(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::degrees(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::exp(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::expm1(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::floor(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::hypot(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::log(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::log10(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::log1p(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::log2(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::logaddexp(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::logaddexp2(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::pow(&self, n: T) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::radians(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::round(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::safe_atan2(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::ElementWiseMath::safe_hypot(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::ElementWiseMath::safe_logaddexp(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::ElementWiseMath::safe_logaddexp2(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::ElementWiseMath::sign(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::sin(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::sinh(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::sqrt(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::tan(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::tanh(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ElementWiseMath::trunc(&self) -> numrs2::array::Array<T>
impl<T: num_traits::float::Float + core::clone::Clone + 'static> numrs2::math::ElementWiseMath<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::abs(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::acos(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::acosh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::asin(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::asinh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::atan(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::atan2(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::atanh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cbrt(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::ceil(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::clip(&self, min: T, max: T) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cos(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::cosh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::degrees(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::exp(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::expm1(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::floor(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::hypot(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log10(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log1p(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::log2(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::logaddexp(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::logaddexp2(&self, other: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::pow(&self, n: T) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::radians(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::round(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::safe_atan2(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::safe_hypot(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::safe_logaddexp(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::safe_logaddexp2(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::array::Array<T>::sign(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sin(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sinh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::sqrt(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::tan(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::tanh(&self) -> numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::trunc(&self) -> numrs2::array::Array<T>
pub trait numrs2::prelude::Expr<T: core::clone::Clone>
pub fn numrs2::prelude::Expr::can_fuse_with<E: numrs2::expr::Expr<T>>(&self, other: &E) -> bool
pub fn numrs2::prelude::Expr::eval(&self) -> numrs2::array::Array<T>
pub fn numrs2::prelude::Expr::eval_at(&self, index: usize) -> T
pub fn numrs2::prelude::Expr::shape(&self) -> &[usize]
pub fn numrs2::prelude::Expr::size(&self) -> usize
impl<'a, T: core::clone::Clone> numrs2::expr::Expr<T> for numrs2::expr::ArrayExpr<'a, T>
pub fn numrs2::expr::ArrayExpr<'a, T>::eval(&self) -> numrs2::array::Array<T>
pub fn numrs2::expr::ArrayExpr<'a, T>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::ArrayExpr<'a, T>::shape(&self) -> &[usize]
pub fn numrs2::expr::ArrayExpr<'a, T>::size(&self) -> usize
impl<T, C, Tr, Fa> numrs2::expr::Expr<T> for numrs2::expr::WhereExpr<T, C, Tr, Fa> where T: core::clone::Clone, C: numrs2::expr::Expr<bool>, Tr: numrs2::expr::Expr<T>, Fa: numrs2::expr::Expr<T>
pub fn numrs2::expr::WhereExpr<T, C, Tr, Fa>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::WhereExpr<T, C, Tr, Fa>::shape(&self) -> &[usize]
pub fn numrs2::expr::WhereExpr<T, C, Tr, Fa>::size(&self) -> usize
impl<T, E, F> numrs2::expr::Expr<T> for numrs2::expr::ScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::expr::ScalarExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::ScalarExpr<T, E, F>::shape(&self) -> &[usize]
pub fn numrs2::expr::ScalarExpr<T, E, F>::size(&self) -> usize
impl<T, E, F> numrs2::expr::Expr<T> for numrs2::expr::UnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T) -> T
pub fn numrs2::expr::UnaryExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::UnaryExpr<T, E, F>::shape(&self) -> &[usize]
pub fn numrs2::expr::UnaryExpr<T, E, F>::size(&self) -> usize
impl<T, E> numrs2::expr::Expr<T> for numrs2::expr::ClipExpr<T, E> where T: core::clone::Clone + core::cmp::PartialOrd, E: numrs2::expr::Expr<T>
pub fn numrs2::expr::ClipExpr<T, E>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::ClipExpr<T, E>::shape(&self) -> &[usize]
pub fn numrs2::expr::ClipExpr<T, E>::size(&self) -> usize
impl<T, L, R, F> numrs2::expr::Expr<T> for numrs2::expr::BinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::Expr<T>, R: numrs2::expr::Expr<T>, F: core::ops::function::Fn(T, T) -> T
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::shape(&self) -> &[usize]
pub fn numrs2::expr::BinaryExpr<T, L, R, F>::size(&self) -> usize
impl<T: core::clone::Clone> numrs2::expr::Expr<T> for numrs2::expr::BroadcastScalarExpr<T>
pub fn numrs2::expr::BroadcastScalarExpr<T>::eval_at(&self, _index: usize) -> T
pub fn numrs2::expr::BroadcastScalarExpr<T>::shape(&self) -> &[usize]
pub fn numrs2::expr::BroadcastScalarExpr<T>::size(&self) -> usize
pub trait numrs2::prelude::FloatingPoint: numrs2::traits::NumericElement + num_traits::float::Float
pub fn numrs2::prelude::FloatingPoint::epsilon() -> Self
pub fn numrs2::prelude::FloatingPoint::infinity() -> Self
pub fn numrs2::prelude::FloatingPoint::is_finite(&self) -> bool
pub fn numrs2::prelude::FloatingPoint::is_nan(&self) -> bool
pub fn numrs2::prelude::FloatingPoint::nan() -> Self
pub fn numrs2::prelude::FloatingPoint::neg_infinity() -> Self
impl numrs2::traits::FloatingPoint for f32
pub fn f32::epsilon() -> Self
pub fn f32::infinity() -> Self
pub fn f32::is_finite(&self) -> bool
pub fn f32::is_nan(&self) -> bool
pub fn f32::nan() -> Self
pub fn f32::neg_infinity() -> Self
impl numrs2::traits::FloatingPoint for f64
pub fn f64::epsilon() -> Self
pub fn f64::infinity() -> Self
pub fn f64::is_finite(&self) -> bool
pub fn f64::is_nan(&self) -> bool
pub fn f64::nan() -> Self
pub fn f64::neg_infinity() -> Self
pub trait numrs2::prelude::IntegerElement: numrs2::traits::NumericElement + num_traits::int::PrimInt
pub fn numrs2::prelude::IntegerElement::max_value() -> Self
pub fn numrs2::prelude::IntegerElement::min_value() -> Self
pub fn numrs2::prelude::IntegerElement::saturating_add(&self, other: &Self) -> Self
pub fn numrs2::prelude::IntegerElement::saturating_mul(&self, other: &Self) -> Self
impl numrs2::traits::IntegerElement for i32
pub fn i32::max_value() -> Self
pub fn i32::min_value() -> Self
pub fn i32::saturating_add(&self, other: &Self) -> Self
pub fn i32::saturating_mul(&self, other: &Self) -> Self
impl numrs2::traits::IntegerElement for i64
pub fn i64::max_value() -> Self
pub fn i64::min_value() -> Self
pub fn i64::saturating_add(&self, other: &Self) -> Self
pub fn i64::saturating_mul(&self, other: &Self) -> Self
pub trait numrs2::prelude::LazyEval<T: core::clone::Clone>
pub fn numrs2::prelude::LazyEval::lazy(&self) -> numrs2::expr::ArrayExpr<'_, T>
impl<T: core::clone::Clone> numrs2::expr::LazyEval<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::lazy(&self) -> numrs2::expr::ArrayExpr<'_, T>
pub trait numrs2::prelude::LinearAlgebra<T: numrs2::traits::FloatingPoint>: core::marker::Sized
pub type numrs2::prelude::LinearAlgebra::Error: core::error::Error
pub fn numrs2::prelude::LinearAlgebra::cond(&self) -> numrs2::Result<T>
pub fn numrs2::prelude::LinearAlgebra::det(&self) -> numrs2::Result<T>
pub fn numrs2::prelude::LinearAlgebra::inv(&self) -> numrs2::Result<Self>
pub fn numrs2::prelude::LinearAlgebra::matmul(&self, other: &Self) -> numrs2::Result<Self>
pub fn numrs2::prelude::LinearAlgebra::norm(&self, ord: core::option::Option<T>) -> numrs2::Result<T>
pub fn numrs2::prelude::LinearAlgebra::rank(&self) -> numrs2::Result<usize>
pub fn numrs2::prelude::LinearAlgebra::solve(&self, b: &Self) -> numrs2::Result<Self>
pub fn numrs2::prelude::LinearAlgebra::transpose(&self) -> Self
pub trait numrs2::prelude::MatrixDecomposition<T: numrs2::traits::FloatingPoint>: core::marker::Sized
pub type numrs2::prelude::MatrixDecomposition::DecompositionResult
pub type numrs2::prelude::MatrixDecomposition::Error: core::error::Error
pub fn numrs2::prelude::MatrixDecomposition::cholesky(&self) -> numrs2::Result<Self>
pub fn numrs2::prelude::MatrixDecomposition::eig(&self) -> numrs2::Result<Self::DecompositionResult>
pub fn numrs2::prelude::MatrixDecomposition::lu(&self) -> numrs2::Result<Self::DecompositionResult>
pub fn numrs2::prelude::MatrixDecomposition::qr(&self) -> numrs2::Result<Self::DecompositionResult>
pub fn numrs2::prelude::MatrixDecomposition::schur(&self) -> numrs2::Result<Self::DecompositionResult>
pub fn numrs2::prelude::MatrixDecomposition::svd(&self) -> numrs2::Result<Self::DecompositionResult>
pub trait numrs2::prelude::MemoryAllocator: core::marker::Send + core::marker::Sync + core::fmt::Debug
pub type numrs2::prelude::MemoryAllocator::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::prelude::MemoryAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::prelude::MemoryAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::prelude::MemoryAllocator::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::prelude::MemoryAllocator::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::prelude::MemoryAllocator::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::prelude::MemoryAllocator::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl numrs2::traits::MemoryAllocator for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub type numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl numrs2::traits::MemoryAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub type numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl<A> numrs2::traits::MemoryAllocator for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
pub type numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl<A> numrs2::traits::MemoryAllocator for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub type numrs2::parallel::parallel_allocator::ParallelAllocator<A>::Error = numrs2::NumRs2Error
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::traits::MemoryAllocator for numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub type numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::supports_layout(&self, _layout: core::alloc::layout::Layout) -> bool
pub trait numrs2::prelude::MemoryAware
pub fn numrs2::prelude::MemoryAware::memory_usage(&self) -> numrs2::traits::MemoryUsage
pub fn numrs2::prelude::MemoryAware::optimize_memory_layout(&mut self) -> numrs2::Result<()>
pub fn numrs2::prelude::MemoryAware::set_allocator(&mut self, allocator: alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>)
pub fn numrs2::prelude::MemoryAware::suggest_optimizations(&self) -> alloc::vec::Vec<numrs2::traits::MemoryOptimization>
pub trait numrs2::prelude::NumericElement: core::clone::Clone + core::marker::Send + core::marker::Sync + core::fmt::Debug + 'static
pub fn numrs2::prelude::NumericElement::from_f64(val: f64) -> core::option::Option<Self>
pub fn numrs2::prelude::NumericElement::is_zero(&self) -> bool
pub fn numrs2::prelude::NumericElement::one() -> Self
pub fn numrs2::prelude::NumericElement::to_f64(&self) -> core::option::Option<f64>
pub fn numrs2::prelude::NumericElement::zero() -> Self
impl numrs2::traits::NumericElement for f32
pub fn f32::from_f64(val: f64) -> core::option::Option<Self>
pub fn f32::is_zero(&self) -> bool
pub fn f32::one() -> Self
pub fn f32::to_f64(&self) -> core::option::Option<f64>
pub fn f32::zero() -> Self
impl numrs2::traits::NumericElement for f64
pub fn f64::from_f64(val: f64) -> core::option::Option<Self>
pub fn f64::is_zero(&self) -> bool
pub fn f64::one() -> Self
pub fn f64::to_f64(&self) -> core::option::Option<f64>
pub fn f64::zero() -> Self
impl numrs2::traits::NumericElement for i32
pub fn i32::from_f64(val: f64) -> core::option::Option<Self>
pub fn i32::is_zero(&self) -> bool
pub fn i32::one() -> Self
pub fn i32::to_f64(&self) -> core::option::Option<f64>
pub fn i32::zero() -> Self
impl numrs2::traits::NumericElement for i64
pub fn i64::from_f64(val: f64) -> core::option::Option<Self>
pub fn i64::is_zero(&self) -> bool
pub fn i64::one() -> Self
pub fn i64::to_f64(&self) -> core::option::Option<f64>
pub fn i64::zero() -> Self
impl<T: numrs2::traits::FloatingPoint> numrs2::traits::NumericElement for num_complex::Complex<T>
pub fn num_complex::Complex<T>::from_f64(val: f64) -> core::option::Option<Self>
pub fn num_complex::Complex<T>::is_zero(&self) -> bool
pub fn num_complex::Complex<T>::one() -> Self
pub fn num_complex::Complex<T>::to_f64(&self) -> core::option::Option<f64>
pub fn num_complex::Complex<T>::zero() -> Self
pub trait numrs2::prelude::SharedExpr<T: core::clone::Clone>: core::clone::Clone
pub fn numrs2::prelude::SharedExpr::eval(&self) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::prelude::SharedExpr::eval_at(&self, index: usize) -> T
pub fn numrs2::prelude::SharedExpr::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::prelude::SharedExpr::size(&self) -> usize
impl<T, E, F> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedScalarExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedScalarExpr<T, E, F>::size(&self) -> usize
impl<T, E, F> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedUnaryExpr<T, E, F> where T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedUnaryExpr<T, E, F>::size(&self) -> usize
impl<T, L, R, F> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedBinaryExpr<T, L, R, F> where T: core::clone::Clone, L: numrs2::expr::SharedExpr<T>, R: numrs2::expr::SharedExpr<T>, F: core::ops::function::Fn(T, T) -> T + core::clone::Clone
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedBinaryExpr<T, L, R, F>::size(&self) -> usize
impl<T: core::clone::Clone, E: numrs2::expr::SharedExpr<T>> numrs2::expr::SharedExpr<T> for numrs2::expr::CachedExpr<T, E>
pub fn numrs2::expr::CachedExpr<T, E>::eval(&self) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::CachedExpr<T, E>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::CachedExpr<T, E>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::CachedExpr<T, E>::size(&self) -> usize
impl<T: core::clone::Clone> numrs2::expr::SharedExpr<T> for numrs2::expr::SharedArrayExpr<T>
pub fn numrs2::expr::SharedArrayExpr<T>::eval(&self) -> numrs2::shared_array::SharedArray<T>
pub fn numrs2::expr::SharedArrayExpr<T>::eval_at(&self, index: usize) -> T
pub fn numrs2::expr::SharedArrayExpr<T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::expr::SharedArrayExpr<T>::size(&self) -> usize
pub trait numrs2::prelude::SpecializedAllocator: numrs2::traits::MemoryAllocator
pub fn numrs2::prelude::SpecializedAllocator::allocation_error(&self, msg: &str) -> Self::Error
impl numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::allocation_error(&self, msg: &str) -> Self::Error
impl numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocation_error(&self, msg: &str) -> Self::Error
impl<A> numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::allocation_error(&self, msg: &str) -> Self::Error
impl<A> numrs2::traits::SpecializedAllocator for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::allocation_error(&self, msg: &str) -> Self::Error
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::allocation_error(&self, msg: &str) -> Self::Error
pub trait numrs2::prelude::Statistics<T>
pub fn numrs2::prelude::Statistics::max(&self) -> T
pub fn numrs2::prelude::Statistics::mean(&self) -> T
pub fn numrs2::prelude::Statistics::min(&self) -> T
pub fn numrs2::prelude::Statistics::percentile(&self, q: T) -> T
pub fn numrs2::prelude::Statistics::std(&self) -> T
pub fn numrs2::prelude::Statistics::var(&self) -> T
impl<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync + 'static> numrs2::stats::Statistics<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::max(&self) -> T
pub fn numrs2::array::Array<T>::mean(&self) -> T
pub fn numrs2::array::Array<T>::min(&self) -> T
pub fn numrs2::array::Array<T>::percentile(&self, q: T) -> T
pub fn numrs2::array::Array<T>::std(&self) -> T
pub fn numrs2::array::Array<T>::var(&self) -> T
pub trait numrs2::prelude::Task: core::marker::Send + 'static
pub type numrs2::prelude::Task::Output: core::marker::Send + 'static
pub fn numrs2::prelude::Task::can_split(&self) -> bool
pub fn numrs2::prelude::Task::estimated_cost(&self) -> core::option::Option<u64>
pub fn numrs2::prelude::Task::execute(self: alloc::boxed::Box<Self>) -> Self::Output
pub fn numrs2::prelude::Task::split(self: alloc::boxed::Box<Self>) -> alloc::vec::Vec<alloc::boxed::Box<dyn numrs2::parallel::work_stealing::Task<Output = Self::Output>>> where Self: core::marker::Sized
impl<F> numrs2::parallel::work_stealing::Task for numrs2::parallel::work_stealing::ClosureTask<F, ()> where F: core::ops::function::FnOnce() + core::marker::Send + 'static
pub type numrs2::parallel::work_stealing::ClosureTask<F, ()>::Output = numrs2::parallel::work_stealing::TaskResult<()>
pub fn numrs2::parallel::work_stealing::ClosureTask<F, ()>::execute(self: alloc::boxed::Box<Self>) -> Self::Output
pub fn numrs2::prelude::abs(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::absolute(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::accrued_interest<T>(coupon_rate: T, face_value: T, days_since_last_coupon: T, days_in_coupon_period: T) -> T where T: num_traits::float::Float
pub fn numrs2::prelude::adaptive_array_sum(data: &ndarray::aliases::ArrayView1<'_, f64>) -> f64
pub fn numrs2::prelude::adaptive_threshold(array_size: usize, element_cost: f64) -> usize
pub fn numrs2::prelude::add(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::prelude::add_scalar(a: &numrs2::array::Array<f64>, b: f64) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::adv_compress<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::adv_extract<T: core::clone::Clone>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::adv_place<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>, values: &[T]) -> numrs2::Result<()>
pub fn numrs2::prelude::adv_put<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, indices: &numrs2::array::Array<usize>, values: &[T]) -> numrs2::Result<()>
pub fn numrs2::prelude::airy_ai<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::airy_bi<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::align_data<T: core::marker::Copy>(data: &mut [T], strategy: numrs2::memory_optimize::alignment::AlignmentStrategy)
pub fn numrs2::prelude::all<T>(a: &numrs2::array::Array<T>) -> bool where T: core::clone::Clone + core::cmp::PartialEq + core::fmt::Debug, bool: core::convert::From<T>
pub fn numrs2::prelude::allclose<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> bool where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::allclose_with_tol<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, rtol: T, atol: T) -> bool where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::amax<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::amin<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::amortization_schedule<T>(principal: T, rate: T, nper: usize) -> numrs2::Result<numrs2::financial::AmortizationSchedule<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::angle<T: num_traits::float::Float + core::clone::Clone>(complex_array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::any<T>(a: &numrs2::array::Array<T>) -> bool where T: core::clone::Clone + core::cmp::PartialEq + core::fmt::Debug, bool: core::convert::From<T>
pub fn numrs2::prelude::append<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, values: &[T], axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::apply_along_axis<T, U, F>(array: &numrs2::array::Array<T>, axis: usize, func: F) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + core::fmt::Debug + num_traits::identities::Zero, U: core::clone::Clone + core::fmt::Debug, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> U
pub fn numrs2::prelude::apply_along_axis<T, U, F>(array: &numrs2::array::Array<T>, axis: usize, func: F) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + core::fmt::Debug + num_traits::identities::Zero, U: core::clone::Clone + core::fmt::Debug, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> U
pub fn numrs2::prelude::apply_along_axis<T, U, F>(func: F, array: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<U>> where T: core::clone::Clone + num_traits::identities::Zero, U: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> U
pub fn numrs2::prelude::apply_over_axes<T, F>(array: &numrs2::array::Array<T>, axes: &[usize], func: F) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug, F: core::ops::function::Fn(&numrs2::array::Array<T>, usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::apply_over_axes<T, F>(array: &numrs2::array::Array<T>, axes: &[usize], func: F) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug, F: core::ops::function::Fn(&numrs2::array::Array<T>, usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::apply_over_axes<T, F>(func: F, array: &numrs2::array::Array<T>, axes: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::arange<T>(start: T, stop: T, step: T) -> numrs2::array::Array<T> where T: core::clone::Clone + core::cmp::PartialOrd + num_traits::cast::NumCast + core::ops::arith::Add<Output = T> + num_traits::identities::Zero + 'static
pub fn numrs2::prelude::arctan2(y: &numrs2::array::Array<f64>, x: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::prelude::argmax<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::argmin<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::argpartition<T>(array: &numrs2::array::Array<T>, kth: usize, axis: core::option::Option<isize>, _kind: core::option::Option<&str>, _order: core::option::Option<&[&str]>) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::argsort<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, _kind: core::option::Option<&str>, _order: core::option::Option<&[&str]>) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::around<T>(array: &numrs2::array::Array<T>, decimals: core::option::Option<i32>, out: core::option::Option<&mut numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::array_equal<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, equal_nan: core::option::Option<bool>) -> bool where T: core::clone::Clone + core::cmp::PartialEq + core::fmt::Debug + 'static
pub fn numrs2::prelude::array_from_strings<S: core::convert::AsRef<str>>(strings: &[S], dtype: &str, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::array_from_strings<S: core::convert::AsRef<str>>(strings: &[S], dtype: &str, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::array_split<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>, axis: usize) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::array_str<T>(array: &numrs2::array::Array<T>, precision: core::option::Option<usize>, threshold: core::option::Option<usize>, edgeitems: core::option::Option<usize>) -> alloc::string::String where T: core::clone::Clone + core::fmt::Display + core::fmt::Debug
pub fn numrs2::prelude::array_to_vec2d<T: core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<T>>>
pub fn numrs2::prelude::arrays_close<T>(actual: &numrs2::array::Array<T>, desired: &numrs2::array::Array<T>, rtol: f64, atol: f64) -> bool where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::as_strided<T>(array: &numrs2::array::Array<T>, shape: &[usize], strides: &[isize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::asanyarray<T>(a: &impl core::convert::AsRef<[T]>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::prelude::ascontiguousarray<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::prelude::asfortranarray<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone
pub fn numrs2::prelude::asmatrix<T>(data: numrs2::array::Array<T>) -> numrs2::Result<numrs2::matrix::Matrix<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::prelude::assert_array_all_finite<T>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::testing::TestResult> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::assert_array_almost_equal<T>(actual: &numrs2::array::Array<T>, desired: &numrs2::array::Array<T>, config: &numrs2::testing::ToleranceConfig) -> numrs2::Result<numrs2::testing::TestResult> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::assert_array_equal<T>(actual: &numrs2::array::Array<T>, desired: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::testing::TestResult> where T: core::cmp::PartialEq + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::assert_array_no_nan<T>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::testing::TestResult> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::assert_array_same_shape<T, U>(actual: &numrs2::array::Array<T>, desired: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::testing::TestResult> where T: core::clone::Clone, U: core::clone::Clone
pub fn numrs2::prelude::assert_scalar_almost_equal<T>(actual: T, desired: T, config: &numrs2::testing::ToleranceConfig) -> numrs2::Result<numrs2::testing::TestResult> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::associated_legendre_p<T>(l: i32, m: i32, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::astype<T: core::clone::Clone, U: core::clone::Clone + core::convert::From<T>>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<U>
pub fn numrs2::prelude::atleast_1d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::atleast_2d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::atleast_3d<T: core::clone::Clone + num_traits::identities::Zero>(arys: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::average<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, weights: core::option::Option<&numrs2::array::Array<T>>, axis: core::option::Option<usize>, returned: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::bartlett(m: usize) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::bessel_i<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::bessel_j<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::bessel_k<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::bessel_y<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::beta<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::betainc<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::bincount(array: &numrs2::array::Array<usize>, minlength: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::prelude::bincount<T, W>(x: &numrs2::array::Array<T>, weights: core::option::Option<&numrs2::array::Array<W>>, minlength: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<W>> where T: core::clone::Clone + num_traits::cast::ToPrimitive + core::cmp::PartialOrd + num_traits::identities::Zero, W: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::AddAssign + num_traits::cast::NumCast
pub fn numrs2::prelude::binomial_option_price<T>(spot_price: T, strike_price: T, time_to_expiry: T, risk_free_rate: T, volatility: T, steps: usize, option_type: &str, exercise_style: &str) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::bitwise_and<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::bit::BitAnd<Output = T>
pub fn numrs2::prelude::bitwise_not<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + core::ops::bit::Not<Output = T>
pub fn numrs2::prelude::bitwise_or<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::bit::BitOr<Output = T>
pub fn numrs2::prelude::bitwise_xor<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::bit::BitXor<Output = T>
pub fn numrs2::prelude::black_scholes<T>(spot_price: T, strike_price: T, time_to_expiry: T, risk_free_rate: T, volatility: T, option_type: &str) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::black_scholes_greeks<T>(spot_price: T, strike_price: T, time_to_expiry: T, risk_free_rate: T, volatility: T, option_type: &str) -> numrs2::Result<(T, T, T, T, T)> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::blackman(m: usize) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::block<T: core::clone::Clone>(blocks: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::bmat<T: core::clone::Clone>(obj: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::bmat_from_arrays<T: core::clone::Clone>(obj: &[alloc::vec::Vec<&numrs2::array::Array<T>>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::bmat_from_string<T: core::clone::Clone>(_description: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::bond_convexity<T>(cash_flows: &numrs2::array::Array<T>, periods: &numrs2::array::Array<T>, yield_rate: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::bond_duration<T>(cash_flows: &numrs2::array::Array<T>, periods: &numrs2::array::Array<T>, yield_rate: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::bond_equivalent_yield<T>(discount_rate: T, days_to_maturity: T) -> T where T: num_traits::float::Float
pub fn numrs2::prelude::bond_price<T>(cash_flows: &numrs2::array::Array<T>, periods: &numrs2::array::Array<T>, yield_rate: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::bond_yield<T>(price: T, cash_flows: &numrs2::array::Array<T>, periods: &numrs2::array::Array<T>, initial_guess: core::option::Option<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::broadcast_arrays<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::broadcast_arrays<T>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::broadcast_to<T: core::clone::Clone>(array: &numrs2::array::Array<T>, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::broadcast_to<T>(array: &numrs2::array::Array<T>, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::byte_strides<T>(array: &numrs2::array::Array<T>) -> alloc::vec::Vec<usize> where T: core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::c_<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::c_concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::cache_aware_binary_op<T, U, V, F>(a: &[T], b: &[U], result: &mut [V], f: F) where T: core::marker::Copy, U: core::marker::Copy, F: core::ops::function::Fn(T, U) -> V
pub fn numrs2::prelude::cache_aware_copy<T: core::marker::Copy>(src: &[T], dst: &mut [T])
pub fn numrs2::prelude::cache_aware_transform<T, U, F>(src: &[T], dst: &mut [U], f: F) where T: core::marker::Copy, F: core::ops::function::Fn(T) -> U
pub fn numrs2::prelude::can_operate_inplace<T>(_array: &numrs2::array::Array<T>) -> bool
pub fn numrs2::prelude::capitalize(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::cbrt(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::ceil(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::center(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::choose<T: core::clone::Clone + num_traits::identities::Zero>(a: &numrs2::array::Array<usize>, choices: &[&numrs2::array::Array<T>], mode: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::chunked_array_processing<F, R>(data: &ndarray::aliases::ArrayView1<'_, f64>, chunk_size: usize, processor: F) -> alloc::vec::Vec<R> where F: core::ops::function::Fn(&[f64]) -> R + core::marker::Send + core::marker::Sync, R: core::marker::Send
pub fn numrs2::prelude::clip<T>(array: &numrs2::array::Array<T>, min: core::option::Option<T>, max: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::cmp::PartialOrd + core::clone::Clone
pub fn numrs2::prelude::column_stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::complex_abs<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::complex_angle<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>, deg: bool) -> numrs2::array::Array<T>
pub fn numrs2::prelude::complex_conj<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<num_complex::Complex<T>>
pub fn numrs2::prelude::complex_imag<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::complex_real<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::compress<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>], axis: impl core::convert::Into<numrs2::array_ops::joining::AxisArg>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::conj<T: num_traits::float::Float + core::clone::Clone>(complex_array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<num_complex::Complex<T>>
pub fn numrs2::prelude::convolve<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, mode: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + core::marker::Send + core::marker::Sync
pub fn numrs2::prelude::convolve2d<T>(input: &numrs2::array::Array<T>, kernel: &numrs2::array::Array<T>, mode: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::marker::Send + core::marker::Sync
pub fn numrs2::prelude::copysign<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::corrcoef<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(x: &numrs2::array::Array<T>, y: core::option::Option<&numrs2::array::Array<T>>, rowvar: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::correlate<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, mode: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + core::marker::Send + core::marker::Sync
pub fn numrs2::prelude::correlate2d<T>(input: &numrs2::array::Array<T>, template: &numrs2::array::Array<T>, mode: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::marker::Send + core::marker::Sync
pub fn numrs2::prelude::count_nonzero<T>(a: &numrs2::array::Array<T>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::prelude::cov<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(x: &numrs2::array::Array<T>, y: core::option::Option<&numrs2::array::Array<T>>, rowvar: core::option::Option<bool>, bias: core::option::Option<bool>, ddof: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::cumipmt<T>(rate: T, nper: usize, pv: T, start_period: usize, end_period: usize, when: u8) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::cumprinc<T>(rate: T, nper: usize, pv: T, start_period: usize, end_period: usize, when: u8) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::cumprod<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, _out: core::option::Option<&mut numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Send + core::marker::Sync
pub fn numrs2::prelude::cumsum<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, _out: core::option::Option<&mut numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::prelude::cumulative_prod<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, _out: core::option::Option<&mut numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Send + core::marker::Sync
pub fn numrs2::prelude::cumulative_sum<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, _out: core::option::Option<&mut numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::prelude::datetime64(value: &str, unit: core::option::Option<&str>) -> numrs2::Result<numrs2::types::datetime::DateTime64>
pub fn numrs2::prelude::datetime_as_string(dt: &numrs2::types::datetime::DateTime64, unit: core::option::Option<&str>, _timezone: core::option::Option<&str>) -> numrs2::Result<alloc::string::String>
pub fn numrs2::prelude::datetime_data(dt: &numrs2::types::datetime::DateTime64) -> (alloc::string::String, i64)
pub fn numrs2::prelude::db<T>(cost: T, salvage: T, life: usize, period: usize, month: usize) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::ddb<T>(cost: T, salvage: T, life: usize, period: usize, factor: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::default_rng() -> numrs2::random::generator::Generator<numrs2::random::generator::StdBitGenerator>
pub fn numrs2::prelude::delete<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &[usize], axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::detect_layout(shape: &[usize], strides: &[usize]) -> numrs2::memory_optimize::access_patterns::MemoryLayout
pub fn numrs2::prelude::diag<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: impl core::convert::Into<core::option::Option<isize>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::diag_indices(n: usize, ndim: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>>
pub fn numrs2::prelude::diag_indices_from<T: core::clone::Clone>(arr: &numrs2::array::Array<T>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>>
pub fn numrs2::prelude::diagflat<T>(v: &numrs2::array::Array<T>, k: i32) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::diagonal<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, offset: impl core::convert::Into<core::option::Option<isize>>, axis1: impl core::convert::Into<core::option::Option<usize>>, axis2: impl core::convert::Into<core::option::Option<usize>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::diff<T>(array: &numrs2::array::Array<T>, n: usize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Sub<Output = T> + 'static
pub fn numrs2::prelude::diff_extended<T>(array: &numrs2::array::Array<T>, n: usize, axis: core::option::Option<usize>, prepend: core::option::Option<&numrs2::array::Array<T>>, append: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Sub<Output = T> + core::ops::arith::Add<Output = T> + 'static
pub fn numrs2::prelude::digamma<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::digitize<T>(array: &numrs2::array::Array<T>, bins: &numrs2::array::Array<T>, right: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::prelude::digitize<T>(x: &numrs2::array::Array<T>, bins: &numrs2::array::Array<T>, right: bool) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::prelude::divide(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::prelude::divide_scalar(a: &numrs2::array::Array<f64>, b: f64) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::divmod<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::dot(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<f64>
pub fn numrs2::prelude::dsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::dstack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::ediff1d<T>(array: &numrs2::array::Array<T>, to_end: core::option::Option<&numrs2::array::Array<T>>, to_begin: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::arith::Sub<Output = T>
pub fn numrs2::prelude::effect<T>(nominal_rate: T, nper: usize) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::ellipe<T>(m: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::ellipeinc<T>(phi: &numrs2::array::Array<T>, m: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::ellipf<T>(phi: &numrs2::array::Array<T>, m: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::ellipk<T>(m: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::empty<T: core::default::Default + core::clone::Clone>(shape: &[usize]) -> numrs2::array::Array<T>
pub fn numrs2::prelude::endswith(arr: &numrs2::array_ops::string_ops::StringArray, suffix: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::equal<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + core::cmp::PartialEq + core::fmt::Debug
pub fn numrs2::prelude::erf<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::erfc<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::erfcinv<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::erfinv<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::errstate() -> numrs2::error_handling::ErrorStateBuilder
pub fn numrs2::prelude::exp(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::exp1<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::exp2(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::expand_dims<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::expi<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::expm1(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::extract<T: core::clone::Clone + alloc::string::ToString, U: core::clone::Clone + alloc::string::ToString>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::extract<T: core::clone::Clone>(array: &numrs2::array::Array<T>, condition: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::fast_sum<T: num_traits::float::Float + core::marker::Send + core::marker::Sync>(array: &numrs2::array::Array<T>) -> T
pub fn numrs2::prelude::fill_diagonal<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, val: T, wrap: bool) -> numrs2::Result<()>
pub fn numrs2::prelude::flatnonzero<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<usize>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::prelude::flatten<T: core::clone::Clone>(array: &numrs2::array::Array<T>, order: core::option::Option<char>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::flip<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::fliplr<T: core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::flipud<T: core::clone::Clone>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::floor(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::fma(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>, c: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::prelude::fmod<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::fresnel<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::frexp<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<i32>) where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::from_ndarray<T, D>(ndarr: &ndarray::Array<T, D>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast, D: ndarray::dimension::dimension_trait::Dimension
pub fn numrs2::prelude::from_polar<T: num_traits::float::Float>(magnitude: &numrs2::array::Array<T>, angle: &numrs2::array::Array<T>, deg: bool) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>>
pub fn numrs2::prelude::frombuffer<T: core::clone::Clone + core::default::Default>(buffer: &[u8], dtype_size: usize, count: isize, offset: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::fromfunction<T, F>(function: F, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&[usize]) -> T
pub fn numrs2::prelude::fromiter<T: core::clone::Clone, I: core::iter::traits::iterator::Iterator<Item = T>>(iter: I, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::frommemmap<T: core::marker::Copy + core::clone::Clone + core::default::Default>(path: &std::path::Path, mode: &str, offset: core::option::Option<usize>, shape: core::option::Option<&[usize]>, order: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::fromstring<T>(string: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: core::str::traits::FromStr + core::clone::Clone + num_traits::identities::Zero, <T as core::str::traits::FromStr>::Err: core::fmt::Display
pub fn numrs2::prelude::fv<T>(rate: T, nper: T, pmt: T, pv: T, when: i32) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::fv_array<T>(rate: &numrs2::array::Array<T>, nper: &numrs2::array::Array<T>, pmt: &numrs2::array::Array<T>, pv: &numrs2::array::Array<T>, when: i32) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::gamma<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::gammainc<T>(a: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::gammaln<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::gcd<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq + core::ops::arith::Rem<Output = T> + core::marker::Copy
pub fn numrs2::prelude::geomspace<T: num_traits::float::Float + core::clone::Clone + 'static>(start: T, stop: T, num: usize) -> numrs2::array::Array<T>
pub fn numrs2::prelude::geomspace<T>(start: T, stop: T, num: usize, endpoint: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::get_default_allocator() -> alloc::boxed::Box<dyn numrs2::memory_alloc::strategy::MemoryAllocator>
pub fn numrs2::prelude::get_global_allocator_strategy() -> numrs2::memory_alloc::strategy::AllocStrategy
pub fn numrs2::prelude::get_optimization_info() -> alloc::string::String
pub fn numrs2::prelude::get_printoptions() -> numrs2::printing::PrintOptions
pub fn numrs2::prelude::get_simd_implementation_name() -> alloc::string::String
pub fn numrs2::prelude::geterr() -> numrs2::error_handling::ErrorState
pub fn numrs2::prelude::geterrcall() -> core::option::Option<numrs2::error_handling::ErrorCallback>
pub fn numrs2::prelude::global_parallel_context() -> numrs2::Result<alloc::sync::Arc<numrs2::parallel::ParallelContext>>
pub fn numrs2::prelude::gradient<T>(f: &numrs2::array::Array<T>, varargs: core::option::Option<numrs2::math::GradientSpacing<T>>, axis: core::option::Option<alloc::vec::Vec<usize>>, edge_order: usize) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: num_traits::float::Float + core::clone::Clone + 'static
pub fn numrs2::prelude::greater<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + core::cmp::PartialOrd + core::fmt::Debug
pub fn numrs2::prelude::greater_equal<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + core::cmp::PartialOrd + core::fmt::Debug
pub fn numrs2::prelude::hamming(m: usize) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::handle_error(error_type: numrs2::error_handling::FloatingPointError, message: &str) -> bool
pub fn numrs2::prelude::hanning(m: usize) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::heaviside<T>(x: &numrs2::array::Array<T>, h0: core::option::Option<T>) -> numrs2::array::Array<T> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::histogram<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync + 'static>(a: &numrs2::array::Array<T>, bins: usize, range: core::option::Option<(T, T)>, weights: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>)>
pub fn numrs2::prelude::histogram_dd<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Display>(sample: &numrs2::array::Array<T>, bins: &[usize], range: core::option::Option<alloc::vec::Vec<(T, T)>>, weights: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<(numrs2::array::Array<T>, alloc::vec::Vec<numrs2::array::Array<T>>)>
pub fn numrs2::prelude::hsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::hstack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::hypot(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::prelude::i0<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::imag<T: num_traits::float::Float + core::clone::Clone>(complex_array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::implied_volatility<T>(market_price: T, spot_price: T, strike_price: T, time_to_expiry: T, risk_free_rate: T, option_type: &str, initial_vol: core::option::Option<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::in1d<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash>(ar1: &numrs2::array::Array<T>, ar2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::indexing_put<T: core::clone::Clone + alloc::string::ToString>(array: &mut numrs2::array::Array<T>, indices: &numrs2::array::Array<T>, values: &numrs2::array::Array<T>, mode: core::option::Option<&str>) -> numrs2::Result<()>
pub fn numrs2::prelude::indexing_putmask<T: core::clone::Clone + alloc::string::ToString, U: core::clone::Clone + alloc::string::ToString>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<U>, values: &numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::prelude::indices_grid<T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + num_traits::cast::NumCast>(shape: &[usize]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::init_global_allocator(strategy: numrs2::memory_alloc::strategy::AllocStrategy)
pub fn numrs2::prelude::initialize_parallel_context() -> numrs2::Result<()>
pub fn numrs2::prelude::inner<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + 'static>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<T>
pub fn numrs2::prelude::insert<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &[usize], values: &[T], axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::interp<T>(x: &numrs2::array::Array<T>, xp: &numrs2::array::Array<T>, fp: &numrs2::array::Array<T>, left: core::option::Option<T>, right: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::interp<T>(x: &numrs2::array::Array<T>, xp: &numrs2::array::Array<T>, fp: &numrs2::array::Array<T>, left: core::option::Option<T>, right: core::option::Option<T>, period: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::float::Float
pub fn numrs2::prelude::intersect1d<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::cmp::Ord>(ar1: &numrs2::array::Array<T>, ar2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::invert<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + core::ops::bit::Not<Output = T>
pub fn numrs2::prelude::ipmt<T>(rate: T, per: usize, nper: usize, pv: T, fv: T, when: u8) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::irr<T>(values: &numrs2::array::Array<T>, guess: core::option::Option<T>, tol: core::option::Option<T>, maxiter: core::option::Option<usize>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::irr_multiple_series<T>(values_matrix: &numrs2::array::Array<T>, guess: core::option::Option<T>, tol: core::option::Option<T>, maxiter: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::is_finite_array<T>(array: &numrs2::array::Array<T>) -> bool where T: num_traits::float::Float
pub fn numrs2::prelude::isclose<T>(a: T, b: T, rtol: T, atol: T) -> bool where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::isclose_array<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, rtol: T, atol: T) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::iscomplex<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<bool>
pub fn numrs2::prelude::iscomplexobj<T: num_traits::float::Float>(_array: &numrs2::array::Array<num_complex::Complex<T>>) -> bool
pub fn numrs2::prelude::iscontiguous<T>(_a: &numrs2::array::Array<T>) -> bool
pub fn numrs2::prelude::isfinite<T>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<bool> where T: num_traits::float::Float
pub fn numrs2::prelude::isfortran<T>(a: &numrs2::array::Array<T>) -> bool where T: core::clone::Clone
pub fn numrs2::prelude::isin<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash>(element: &numrs2::array::Array<T>, test_elements: &numrs2::array::Array<T>, assume_unique: bool, invert: bool) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::isinf<T>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<bool> where T: num_traits::float::Float
pub fn numrs2::prelude::isnan<T>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<bool> where T: num_traits::float::Float
pub fn numrs2::prelude::isreal<T: num_traits::float::Float>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<bool>
pub fn numrs2::prelude::isrealobj<T: num_traits::float::Float>(_array: &numrs2::array::Array<T>) -> bool
pub fn numrs2::prelude::ix_<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::ix_<T: core::clone::Clone>(sequences: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::jacobi_elliptic<T>(u: &numrs2::array::Array<T>, m: T) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::kaiser(m: usize, beta: f64) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::kron<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::lambertw<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::lambertwm1<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::lcm<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq + core::ops::arith::Rem<Output = T> + core::ops::arith::Div<Output = T> + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub fn numrs2::prelude::ldexp<T, I>(x: &numrs2::array::Array<T>, exp: &numrs2::array::Array<I>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone, I: core::clone::Clone + num_traits::cast::NumCast
pub fn numrs2::prelude::left_shift<T, U>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::bit::Shl<U, Output = T>, U: core::clone::Clone
pub fn numrs2::prelude::left_shift_scalar<T, U>(x: &numrs2::array::Array<T>, shift: U) -> numrs2::array::Array<T> where T: core::clone::Clone + core::ops::bit::Shl<U, Output = T>, U: core::clone::Clone
pub fn numrs2::prelude::legendre_p<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::less<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + core::cmp::PartialOrd + core::fmt::Debug
pub fn numrs2::prelude::less_equal<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + core::cmp::PartialOrd + core::fmt::Debug
pub fn numrs2::prelude::lexsort<T: core::clone::Clone + core::cmp::PartialOrd + num_traits::identities::Zero>(keys: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::prelude::linspace<T: num_traits::float::Float + core::clone::Clone + 'static>(start: T, stop: T, num: usize) -> numrs2::array::Array<T>
pub fn numrs2::prelude::ljust(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::log(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::log10(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::log1p(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::log2(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::logical_and(x1: &numrs2::array::Array<bool>, x2: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::logical_not(x: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::logical_or(x1: &numrs2::array::Array<bool>, x2: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::logical_xor(x1: &numrs2::array::Array<bool>, x2: &numrs2::array::Array<bool>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::logspace<T: num_traits::float::Float + core::clone::Clone + 'static>(start: T, stop: T, num: usize, base: core::option::Option<T>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::logspace<T>(start: T, stop: T, num: usize, endpoint: bool, base: T) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::lower(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::lstrip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::lu_optimized<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<usize>)> where T: num_traits::float::Float + num_traits::NumAssign + core::clone::Clone + core::fmt::Debug + num_traits::cast::NumCast + core::iter::traits::accum::Sum + core::marker::Send + core::marker::Sync + ndarray::impl_ops::ScalarOperand + 'static
pub fn numrs2::prelude::mask_indices<F>(shape: &[usize], mask_fn: F) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>> where F: core::ops::function::Fn(&[usize]) -> bool
pub fn numrs2::prelude::matrix<T>(data: numrs2::array::Array<T>) -> numrs2::Result<numrs2::matrix::Matrix<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::prelude::matrix_from_nested<T>(nested_vec: alloc::vec::Vec<alloc::vec::Vec<T>>) -> numrs2::Result<numrs2::matrix::Matrix<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::prelude::matrix_from_scalar<T>(scalar: T) -> numrs2::matrix::Matrix<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::cmp::PartialEq + core::default::Default + core::cmp::PartialOrd
pub fn numrs2::prelude::max<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::max_along_axis<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::default::Default + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::maximum(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::prelude::may_share_memory<T>(_a: &numrs2::array::Array<T>, _b: &numrs2::array::Array<T>) -> bool
pub fn numrs2::prelude::mean<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::cast::NumCast
pub fn numrs2::prelude::median<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::prelude::memory_optimize_layout<T: core::marker::Copy>(data: &mut [T], strategy: numrs2::memory_optimize::cache_layout::LayoutStrategy)
pub fn numrs2::prelude::meshgrid<T>(xi: &[&numrs2::array::Array<T>], indexing: &str, sparse: bool) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::prelude::mgrid<T>(slices: &[(T, T, T)]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd + num_traits::cast::FromPrimitive + 'static
pub fn numrs2::prelude::min<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::min_along_axis<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::default::Default + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::minimum(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::prelude::mirr<T>(values: &numrs2::array::Array<T>, finance_rate: T, reinvest_rate: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::mod_format(arr: &numrs2::array_ops::string_ops::StringArray, values: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::mode<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, nan_policy: core::option::Option<&str>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd + core::fmt::Display + num_traits::cast::NumCast
pub fn numrs2::prelude::modf<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::modified_duration<T>(macaulay_duration: T, yield_rate: T) -> T where T: num_traits::float::Float
pub fn numrs2::prelude::moveaxis<T: core::clone::Clone>(array: &numrs2::array::Array<T>, source: &[usize], destination: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::msort<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::multiply(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::prelude::multiply_scalar(a: &numrs2::array::Array<f64>, b: f64) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::nan_to_num<T>(array: &numrs2::array::Array<T>, nan: core::option::Option<T>, posinf: core::option::Option<T>, neginf: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::nanmax<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::prelude::nanmean<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Div<Output = T> + num_traits::identities::Zero
pub fn numrs2::prelude::nanmin<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::prelude::nanstd<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, ddof: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + num_traits::identities::Zero
pub fn numrs2::prelude::nansum<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero
pub fn numrs2::prelude::nanvar<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, ddof: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + num_traits::identities::Zero
pub fn numrs2::prelude::negative(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::nextafter<T>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::nominal<T>(effective_rate: T, nper: usize) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::nonzero<T>(array: &numrs2::array::Array<T>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::prelude::norm<T: num_traits::float::Float + core::clone::Clone + core::fmt::Display + core::ops::arith::AddAssign + 'static>(a: &numrs2::array::Array<T>, ord: core::option::Option<T>) -> numrs2::Result<T>
pub fn numrs2::prelude::norm_l1(a: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::prelude::norm_l2(a: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::prelude::not_equal<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>> where T: core::clone::Clone + core::cmp::PartialEq + core::fmt::Debug
pub fn numrs2::prelude::nper<T>(rate: T, pmt: T, pv: T, fv: T, when: i32) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::nper_array<T>(rate: &numrs2::array::Array<T>, pmt: &numrs2::array::Array<T>, pv: &numrs2::array::Array<T>, fv: &numrs2::array::Array<T>, when: i32) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::npv<T>(rate: T, values: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::npv_multiple_series<T>(rate: T, values_matrix: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::npv_rates<T>(rates: &numrs2::array::Array<T>, values: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::ogrid<T>(slices: &[(T, T, T)]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd + num_traits::cast::FromPrimitive + 'static
pub fn numrs2::prelude::ones<T: num_traits::identities::One + core::clone::Clone>(shape: &[usize]) -> numrs2::array::Array<T>
pub fn numrs2::prelude::optimize_layout<T: core::clone::Clone>(array: &numrs2::array::Array<T>, layout: numrs2::util::MemoryLayout) -> numrs2::array::Array<T>
pub fn numrs2::prelude::optimize_parallel_computation(array_size: usize, element_cost: f64, scheduling: numrs2::parallel_optimize::scheduling::SchedulingStrategy) -> usize
pub fn numrs2::prelude::optimize_placement<T: core::marker::Copy>(data: &mut [T], strategy: numrs2::memory_optimize::memory_placement::PlacementStrategy)
pub fn numrs2::prelude::optimize_scheduling(array_size: usize, element_cost: f64, strategy: numrs2::parallel_optimize::scheduling::SchedulingStrategy, num_threads: usize) -> usize
pub fn numrs2::prelude::outer<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::packbits(array: &numrs2::array::Array<u8>, axis: core::option::Option<isize>, bitorder: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<u8>>
pub fn numrs2::prelude::pad<T>(array: &numrs2::array::Array<T>, pad_width: &[(usize, usize)], mode: &str, constant_values: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::parallel_column_statistics(data: &ndarray::aliases::ArrayView2<'_, f64>) -> alloc::vec::Vec<numrs2::optimized_ops::ColumnStats>
pub fn numrs2::prelude::parallel_map<T, U, F>(array: &numrs2::array::Array<T>, f: F) -> numrs2::array::Array<U> where T: core::marker::Send + core::marker::Sync + core::clone::Clone, U: core::marker::Send + core::clone::Clone, F: core::ops::function::Fn(T) -> U + core::marker::Send + core::marker::Sync
pub fn numrs2::prelude::partition<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>, kth: usize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::partition<T>(array: &numrs2::array::Array<T>, kth: usize, axis: core::option::Option<isize>, _kind: core::option::Option<&str>, _order: core::option::Option<&[&str]>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::prelude::partition_workload(array_size: usize, partitioning: numrs2::parallel_optimize::workload::WorkloadPartitioning, num_threads: usize) -> alloc::vec::Vec<core::ops::range::Range<usize>>
pub fn numrs2::prelude::percentile<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, q: &numrs2::array::Array<T>, method: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::piecewise<T, F>(x: &numrs2::array::Array<T>, condlist: &[&numrs2::array::Array<bool>], funclist: &[&F], fill_value: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero, F: core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::place<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>, values: &[T]) -> numrs2::Result<()>
pub fn numrs2::prelude::pmt<T>(rate: T, nper: T, pv: T, fv: T, when: i32) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::pmt_array<T>(rate: &numrs2::array::Array<T>, nper: &numrs2::array::Array<T>, pv: &numrs2::array::Array<T>, fv: &numrs2::array::Array<T>, when: i32) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::poly<T>(roots: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::prelude::polyadd<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::cmp::PartialEq
pub fn numrs2::prelude::polychebyshev<T>(degree: usize, kind: u8) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::prelude::polycompanion<T>(c: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Neg<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq
pub fn numrs2::prelude::polycompose<T>(p: &numrs2::array::Array<T>, q: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::prelude::polyder<T>(c: &numrs2::array::Array<T>, m: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::prelude::polydiv<T>(u: &numrs2::array::Array<T>, v: &numrs2::array::Array<T>) -> numrs2::Result<(numrs2::math_extended::Polynomial<T>, numrs2::math_extended::Polynomial<T>)> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq
pub fn numrs2::prelude::polyextrap<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, new_x: &numrs2::array::Array<T>, degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::prelude::polyfit<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, degree: usize) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::prelude::polyfit_weighted<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, degree: usize, weights: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::math_extended::Polynomial<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::fmt::Debug + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::prelude::polyfromroots<T>(roots: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::prelude::polygcd<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + num_traits::float::Float
pub fn numrs2::prelude::polygrid2d<T>(c: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::prelude::polyhermite<T>(degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::prelude::polyint<T>(c: &numrs2::array::Array<T>, m: usize, k: core::option::Option<&[T]>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::prelude::polyjacobi<T>(degree: usize, alpha: T, beta: T) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T> + num_traits::float::Float
pub fn numrs2::prelude::polylaguerre<T>(degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::prelude::polylegendre<T>(degree: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::convert::From<i32> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::prelude::polylog<T>(s: T, z: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::polymul<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::prelude::polymulx<T>(c: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::polypower<T>(c: &numrs2::array::Array<T>, pow: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::prelude::polyresidual<T>(c: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<T> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::cmp::PartialEq
pub fn numrs2::prelude::polyscale<T>(c: &numrs2::array::Array<T>, domain: &numrs2::array::Array<T>, window: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + core::cmp::PartialEq + num_traits::float::Float
pub fn numrs2::prelude::polysub<T>(p1: &numrs2::array::Array<T>, p2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Sub<Output = T> + core::cmp::PartialEq + core::ops::arith::Neg<Output = T>
pub fn numrs2::prelude::polytrim<T>(c: &numrs2::array::Array<T>, tol: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialOrd + num_traits::float::Float
pub fn numrs2::prelude::polyval2d<T>(c: &numrs2::array::Array<T>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T>
pub fn numrs2::prelude::polyvander<T>(x: &numrs2::array::Array<T>, deg: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Mul<Output = T>
pub fn numrs2::prelude::polyvander2d<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, deg: (usize, usize)) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Mul<Output = T>
pub fn numrs2::prelude::power(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::prelude::power_scalar(a: &numrs2::array::Array<f64>, b: f64) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::ppmt<T>(rate: T, per: usize, nper: usize, pv: T, fv: T, when: u8) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::prod<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool, initial: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Mul<Output = T>
pub fn numrs2::prelude::promote_types<T, U>() -> core::any::TypeId where T: 'static, U: 'static
pub fn numrs2::prelude::ptp<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::default::Default + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::put<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, indices: &[usize], values: &[T]) -> numrs2::Result<()>
pub fn numrs2::prelude::put_along_axis<T: core::clone::Clone + alloc::string::ToString>(array: &mut numrs2::array::Array<T>, indices: &numrs2::array::Array<T>, values: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<()>
pub fn numrs2::prelude::putmask<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>, mask: &numrs2::array::Array<bool>, values: &numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::prelude::pv<T>(rate: T, nper: T, pmt: T, fv: T, when: i32) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::pv_array<T>(rate: &numrs2::array::Array<T>, nper: &numrs2::array::Array<T>, pmt: &numrs2::array::Array<T>, fv: &numrs2::array::Array<T>, when: i32) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::quantile<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, q: &numrs2::array::Array<T>, method: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::r_<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::r_concatenate<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::rate<T>(nper: T, pmt: T, pv: T, fv: T, when: i32, guess: core::option::Option<T>, tol: core::option::Option<T>, maxiter: core::option::Option<usize>) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::rate_array<T>(nper: &numrs2::array::Array<T>, pmt: &numrs2::array::Array<T>, pv: &numrs2::array::Array<T>, fv: &numrs2::array::Array<T>, when: i32, guess: core::option::Option<T>, tol: core::option::Option<T>, maxiter: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::prelude::ravel<T: core::clone::Clone>(array: &numrs2::array::Array<T>, order: core::option::Option<char>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::ravel_multi_index(multi_index: &[&numrs2::array::Array<usize>], dims: &[usize], mode: core::option::Option<&str>, order: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::prelude::ravel_multi_index(multi_index: &[numrs2::array::Array<usize>], dims: &[usize], mode: &str) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::prelude::real<T: num_traits::float::Float + core::clone::Clone>(complex_array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::array::Array<T>
pub fn numrs2::prelude::real_if_close<T>(a: &numrs2::array::Array<num_complex::Complex<T>>, tol: core::option::Option<T>) -> numrs2::array::Array<T> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::reciprocal(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::remainder<T>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::repeat<T: core::clone::Clone>(array: &numrs2::array::Array<T>, repeats: usize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::replace(arr: &numrs2::array_ops::string_ops::StringArray, old: &str, new: &str, count: core::option::Option<usize>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::require<T: core::clone::Clone>(array: &numrs2::array::Array<T>, requirements: core::option::Option<numrs2::array_ops::ArrayRequirements>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::reset_global_allocator()
pub fn numrs2::prelude::reset_printoptions()
pub fn numrs2::prelude::resize<T>(array: &numrs2::array::Array<T>, new_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::right_shift<T, U>(x1: &numrs2::array::Array<T>, x2: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::bit::Shr<U, Output = T>, U: core::clone::Clone
pub fn numrs2::prelude::right_shift_scalar<T, U>(x: &numrs2::array::Array<T>, shift: U) -> numrs2::array::Array<T> where T: core::clone::Clone + core::ops::bit::Shr<U, Output = T>, U: core::clone::Clone
pub fn numrs2::prelude::rjust(arr: &numrs2::array_ops::string_ops::StringArray, width: usize, fillchar: core::option::Option<char>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::roll<T: core::clone::Clone + core::marker::Send + core::marker::Sync>(array: &numrs2::array::Array<T>, shift: isize, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::rollaxis<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, axis: usize, start: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::rollaxis<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, axis: usize, start: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::rot90<T: core::clone::Clone>(array: &numrs2::array::Array<T>, k: impl core::convert::Into<core::option::Option<i32>>, axes: impl core::convert::Into<core::option::Option<(usize, usize)>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::round(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::row_stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::rstrip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::s_(specs: &[numrs2::array_ops::SliceSpec]) -> alloc::vec::Vec<numrs2::array_ops::SliceSpec>
pub fn numrs2::prelude::searchsorted<T: core::clone::Clone + core::cmp::PartialOrd>(a: &numrs2::array::Array<T>, v: &numrs2::array::Array<T>, side: core::option::Option<&str>, sorter: core::option::Option<&numrs2::array::Array<usize>>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::prelude::searchsorted<T>(sorted_array: &numrs2::array::Array<T>, values: &numrs2::array::Array<T>, side: &str) -> numrs2::Result<numrs2::array::Array<usize>> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd
pub fn numrs2::prelude::select<T: core::clone::Clone + num_traits::identities::Zero>(condlist: &[&numrs2::array::Array<bool>], choicelist: &[&numrs2::array::Array<T>], default: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::set_printoptions(precision: core::option::Option<usize>, threshold: core::option::Option<usize>, edgeitems: core::option::Option<usize>, linewidth: core::option::Option<usize>, suppress: core::option::Option<bool>)
pub fn numrs2::prelude::set_strides<T>(array: &numrs2::array::Array<T>, strides: &[isize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::setdiff1d<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::cmp::Ord>(ar1: &numrs2::array::Array<T>, ar2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::seterr(all: core::option::Option<numrs2::error_handling::ErrorAction>, divide: core::option::Option<numrs2::error_handling::ErrorAction>, over: core::option::Option<numrs2::error_handling::ErrorAction>, under: core::option::Option<numrs2::error_handling::ErrorAction>, invalid: core::option::Option<numrs2::error_handling::ErrorAction>) -> numrs2::error_handling::ErrorState
pub fn numrs2::prelude::seterrcall(callback: core::option::Option<numrs2::error_handling::ErrorCallback>)
pub fn numrs2::prelude::setxor1d<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::cmp::Ord>(ar1: &numrs2::array::Array<T>, ar2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::shares_memory<T>(_a: &numrs2::array::Array<T>, _b: &numrs2::array::Array<T>) -> bool
pub fn numrs2::prelude::shichi<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::should_use_parallel(data_size: usize) -> bool
pub fn numrs2::prelude::shutdown_parallel_context() -> numrs2::Result<()>
pub fn numrs2::prelude::sici<T>(x: &numrs2::array::Array<T>) -> (numrs2::array::Array<T>, numrs2::array::Array<T>) where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::simd_elementwise_ops(a: &ndarray::aliases::ArrayView1<'_, f64>, b: &ndarray::aliases::ArrayView1<'_, f64>) -> numrs2::Result<numrs2::optimized_ops::SimdOpsResult>
pub fn numrs2::prelude::simd_matmul(a: &ndarray::aliases::ArrayView2<'_, f32>, b: &ndarray::aliases::ArrayView2<'_, f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::prelude::simd_vector_ops(v: &ndarray::aliases::ArrayView1<'_, f32>) -> numrs2::optimized_ops::SimdVectorResult
pub fn numrs2::prelude::sinc<T>(x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::sliding_window_view<T>(array: &numrs2::array::Array<T>, window_shape: &[usize], step: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::sln<T>(cost: T, salvage: T, life: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::sort<T: core::clone::Clone + core::cmp::PartialOrd>(array: &numrs2::array::Array<T>, kind: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::sort<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, _kind: core::option::Option<&str>, _order: core::option::Option<&[&str]>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::cmp::PartialOrd + core::clone::Clone + num_traits::identities::Zero
pub fn numrs2::prelude::sort_complex<T>(array: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: core::clone::Clone + core::cmp::PartialOrd + num_traits::float::Float
pub fn numrs2::prelude::spherical_harmonic<T>(l: i32, m: i32, theta: &numrs2::array::Array<T>, phi: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::split<T: core::clone::Clone>(array: &numrs2::array::Array<T>, indices: &[usize], axis: usize) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::sqrt(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::squeeze<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::stack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>], axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::startswith(arr: &numrs2::array_ops::string_ops::StringArray, prefix: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::prelude::std<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, ddof: usize, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + num_traits::cast::NumCast
pub fn numrs2::prelude::string_add(arr1: &numrs2::array_ops::string_ops::StringArray, arr2: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_count(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::prelude::string_find(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::prelude::string_join(sep: &str, arr: &[alloc::vec::Vec<alloc::string::String>]) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_multiply(arr: &numrs2::array_ops::string_ops::StringArray, times: &numrs2::array::Array<i32>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::string_rfind(arr: &numrs2::array_ops::string_ops::StringArray, sub: &str, start: core::option::Option<usize>, end: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<i32>>
pub fn numrs2::prelude::string_split(arr: &numrs2::array_ops::string_ops::StringArray, sep: core::option::Option<&str>, maxsplit: core::option::Option<usize>) -> numrs2::Result<alloc::vec::Vec<alloc::vec::Vec<alloc::string::String>>>
pub fn numrs2::prelude::strip(arr: &numrs2::array_ops::string_ops::StringArray, chars: core::option::Option<&str>) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::struve_h<T>(n: i32, x: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::subtract(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::prelude::subtract_scalar(a: &numrs2::array::Array<f64>, b: f64) -> numrs2::array::Array<f64>
pub fn numrs2::prelude::sum<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + num_traits::identities::Zero
pub fn numrs2::prelude::swapaxes<T: core::clone::Clone>(array: &numrs2::array::Array<T>, axis1: usize, axis2: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::syd<T>(cost: T, salvage: T, life: usize, per: usize) -> numrs2::Result<T> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::prelude::take<T: core::clone::Clone + alloc::string::ToString + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &numrs2::array::Array<T>, axis: core::option::Option<usize>, mode: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::take_along_axis<T: core::clone::Clone + alloc::string::ToString>(array: &numrs2::array::Array<T>, indices: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::take_along_axis<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, indices: &numrs2::array::Array<usize>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::task<F>(closure: F) -> numrs2::parallel::work_stealing::ClosureTask<F, ()> where F: core::ops::function::FnOnce() + core::marker::Send + 'static
pub fn numrs2::prelude::tensordot<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, axes: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::test_summary(results: &[numrs2::testing::TestResult]) -> alloc::string::String
pub fn numrs2::prelude::tile<T: core::clone::Clone>(array: &numrs2::array::Array<T>, reps: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::timedelta64(value: i64, unit: &str) -> numrs2::Result<numrs2::types::datetime::TimeDelta64>
pub fn numrs2::prelude::title(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::to_complex<T: num_traits::float::Float>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<num_complex::Complex<T>>
pub fn numrs2::prelude::to_ndarray<T>(arr: &numrs2::array::Array<T>) -> numrs2::Result<ndarray::aliases::ArrayD<T>> where T: core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::trace<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::ops::arith::AddAssign>(a: &numrs2::array::Array<T>) -> numrs2::Result<T>
pub fn numrs2::prelude::transpose_optimized<T>(a: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::prelude::trapz<T>(y: &numrs2::array::Array<T>, x: core::option::Option<&numrs2::array::Array<T>>, dx: T, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone
pub fn numrs2::prelude::tri<T>(n: usize, m: core::option::Option<usize>, k: core::option::Option<isize>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::prelude::tril<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: isize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::tril_indices(n: usize, k: isize, m: core::option::Option<usize>) -> numrs2::Result<(numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::prelude::tril_indices_from<T: core::clone::Clone>(arr: &numrs2::array::Array<T>, k: core::option::Option<isize>) -> numrs2::Result<(numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::prelude::trim_zeros<T>(array: &numrs2::array::Array<T>, trim: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + core::cmp::PartialEq
pub fn numrs2::prelude::triu<T: core::clone::Clone + num_traits::identities::Zero>(array: &numrs2::array::Array<T>, k: isize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::triu_indices(n: usize, k: isize, m: core::option::Option<usize>) -> numrs2::Result<(numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::prelude::triu_indices_from<T: core::clone::Clone>(arr: &numrs2::array::Array<T>, k: core::option::Option<isize>) -> numrs2::Result<(numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::prelude::union1d<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::cmp::Ord>(ar1: &numrs2::array::Array<T>, ar2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::unique<T>(a: &numrs2::array::Array<T>, axis: core::option::Option<usize>, return_index: core::option::Option<bool>, return_inverse: core::option::Option<bool>, return_counts: core::option::Option<bool>) -> numrs2::Result<numrs2::unique::UniqueResult<T>> where T: core::clone::Clone + core::hash::Hash + core::cmp::Eq + core::fmt::Debug + num_traits::identities::Zero
pub fn numrs2::prelude::unique_axis<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::cmp::Ord + core::fmt::Debug + num_traits::identities::Zero>(ar: &numrs2::array::Array<T>, axis: core::option::Option<usize>, return_index: bool, return_inverse: bool, return_counts: bool) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::prelude::unique_optimized<T>(a: &numrs2::array::Array<T>, axis: core::option::Option<usize>, return_index: core::option::Option<bool>, return_inverse: core::option::Option<bool>, return_counts: core::option::Option<bool>) -> numrs2::Result<numrs2::unique_optimized::UniqueResult<T>> where T: core::clone::Clone + core::hash::Hash + core::cmp::Eq + core::fmt::Debug + num_traits::identities::Zero + core::marker::Send + core::marker::Sync
pub fn numrs2::prelude::unique_with_options<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::cmp::Ord + core::fmt::Debug>(ar: &numrs2::array::Array<T>, return_index: bool, return_inverse: bool, return_counts: bool) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::prelude::unpackbits(packed: &numrs2::array::Array<u8>, axis: core::option::Option<isize>, count: core::option::Option<usize>, bitorder: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<u8>>
pub fn numrs2::prelude::unravel_index(indices: &numrs2::array::Array<usize>, dims: &[usize]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>>
pub fn numrs2::prelude::unravel_index(indices: &numrs2::array::Array<usize>, shape: &[usize], order: core::option::Option<&str>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<usize>>>
pub fn numrs2::prelude::upper(arr: &numrs2::array_ops::string_ops::StringArray) -> numrs2::Result<numrs2::array_ops::string_ops::StringArray>
pub fn numrs2::prelude::vander<T>(x: &numrs2::array::Array<T>, n: core::option::Option<usize>, increasing: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::identities::Zero + num_traits::identities::One + core::ops::arith::Mul<Output = T>
pub fn numrs2::prelude::var<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<isize>, ddof: usize, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::ops::arith::Add<Output = T> + core::ops::arith::Sub<Output = T> + core::ops::arith::Mul<Output = T> + core::ops::arith::Div<Output = T> + num_traits::cast::NumCast
pub fn numrs2::prelude::vdot<T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + 'static>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<T>
pub fn numrs2::prelude::vec2d_to_array<T: core::clone::Clone>(vec: alloc::vec::Vec<alloc::vec::Vec<T>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::vec_to_array<T: core::clone::Clone>(vec: alloc::vec::Vec<T>, shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::vectorize<T, U, F>(func: F) -> impl core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::array::Array<U> where T: core::clone::Clone + core::fmt::Debug, U: core::clone::Clone + core::fmt::Debug, F: core::ops::function::Fn(T) -> U + core::clone::Clone
pub fn numrs2::prelude::vectorize<T, U, F>(func: F) -> impl core::ops::function::Fn(&numrs2::array::Array<T>) -> numrs2::array::Array<U> where T: core::clone::Clone + core::fmt::Debug, U: core::clone::Clone + core::fmt::Debug, F: core::ops::function::Fn(T) -> U + core::clone::Clone
pub fn numrs2::prelude::vsplit<T: core::clone::Clone>(array: &numrs2::array::Array<T>, sections_or_indices: impl core::convert::Into<numrs2::array_ops::SplitArg>) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::prelude::vstack<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::where_cond<T: core::clone::Clone + core::fmt::Display + core::marker::Send + core::marker::Sync>(condition: &numrs2::array::Array<bool>, x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::prelude::zeros<T: num_traits::identities::Zero + core::clone::Clone>(shape: &[usize]) -> numrs2::array::Array<T>
pub fn numrs2::prelude::zeta<T>(s: &numrs2::array::Array<T>) -> numrs2::array::Array<T> where T: core::clone::Clone + num_traits::float::Float + core::fmt::Debug
pub type numrs2::prelude::Result<T> = core::result::Result<T, numrs2::NumRs2Error>
pub type numrs2::prelude::StringArray = numrs2::array::Array<numrs2::array_ops::string_ops::StringElement>
pub type numrs2::prelude::StringArray = numrs2::array::Array<numrs2::array_ops::string_ops::StringElement>
pub mod numrs2::printing
pub struct numrs2::printing::PrintOptions
pub numrs2::printing::PrintOptions::edgeitems: usize
pub numrs2::printing::PrintOptions::linewidth: usize
pub numrs2::printing::PrintOptions::precision: usize
pub numrs2::printing::PrintOptions::prefix: alloc::string::String
pub numrs2::printing::PrintOptions::separator: alloc::string::String
pub numrs2::printing::PrintOptions::sign: char
pub numrs2::printing::PrintOptions::suffix: alloc::string::String
pub numrs2::printing::PrintOptions::suppress: bool
pub numrs2::printing::PrintOptions::threshold: usize
impl core::clone::Clone for numrs2::printing::PrintOptions
pub fn numrs2::printing::PrintOptions::clone(&self) -> Self
impl core::default::Default for numrs2::printing::PrintOptions
pub fn numrs2::printing::PrintOptions::default() -> Self
pub fn numrs2::printing::array_str<T>(array: &numrs2::array::Array<T>, precision: core::option::Option<usize>, threshold: core::option::Option<usize>, edgeitems: core::option::Option<usize>) -> alloc::string::String where T: core::clone::Clone + core::fmt::Display + core::fmt::Debug
pub fn numrs2::printing::format_float(value: f64) -> alloc::string::String
pub fn numrs2::printing::format_int<T: core::fmt::Display>(value: T) -> alloc::string::String
pub fn numrs2::printing::get_printoptions() -> numrs2::printing::PrintOptions
pub fn numrs2::printing::reset_printoptions()
pub fn numrs2::printing::set_printoptions(precision: core::option::Option<usize>, threshold: core::option::Option<usize>, edgeitems: core::option::Option<usize>, linewidth: core::option::Option<usize>, suppress: core::option::Option<bool>)
pub mod numrs2::random
pub mod numrs2::random::advanced_distributions
pub struct numrs2::random::advanced_distributions::Maxwell
impl numrs2::random::advanced_distributions::Maxwell
pub fn numrs2::random::advanced_distributions::Maxwell::new(scale: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::Maxwell::sample(&self) -> f64
pub struct numrs2::random::advanced_distributions::NonCentralChiSquared
impl numrs2::random::advanced_distributions::NonCentralChiSquared
pub fn numrs2::random::advanced_distributions::NonCentralChiSquared::new(df: f64, nonc: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::NonCentralChiSquared::sample(&self) -> f64
pub struct numrs2::random::advanced_distributions::NonCentralF
impl numrs2::random::advanced_distributions::NonCentralF
pub fn numrs2::random::advanced_distributions::NonCentralF::new(df1: f64, df2: f64, nonc: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::NonCentralF::sample(&self) -> f64
pub struct numrs2::random::advanced_distributions::VonMises
impl numrs2::random::advanced_distributions::VonMises
pub fn numrs2::random::advanced_distributions::VonMises::new(mu: f64, kappa: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::VonMises::sample(&self) -> f64
pub struct numrs2::random::advanced_distributions::Wald
impl numrs2::random::advanced_distributions::Wald
pub fn numrs2::random::advanced_distributions::Wald::new(mean: f64, shape: f64) -> numrs2::Result<Self>
pub fn numrs2::random::advanced_distributions::Wald::sample(&self) -> f64
pub fn numrs2::random::advanced_distributions::maxwell<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::advanced_distributions::noncentral_chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::advanced_distributions::noncentral_f<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::advanced_distributions::vonmises<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::advanced_distributions::wald<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::random::distributions
pub fn numrs2::random::distributions::bernoulli<T>(p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::beta<T>(a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::binomial<T>(n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::distributions::cauchy<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::chisquare<T>(df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::dirichlet<T>(alpha: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::exponential<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::gamma<T>(shape_param: T, scale: T, output_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::geometric<T>(p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::distributions::get_global_random_state() -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'static, numrs2::random::state::RandomState>>
pub fn numrs2::random::distributions::gumbel<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::hypergeometric<T>(ngood: usize, nbad: usize, nsample: usize, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::distributions::integers<T>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive, <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::random::distributions::laplace<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::logistic<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::lognormal<T>(mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::logseries<T>(p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::distributions::maxwell<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::multinomial<T>(n: usize, pvals: &[f64], shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::distributions::multivariate_normal<T>(mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::multivariate_normal_with_rotation<T>(mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>, rotation: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::negative_binomial<T>(n: f64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::distributions::noncentral_chisquare<T>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::noncentral_f<T>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::normal<T>(mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::pareto<T>(alpha: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::pert<T>(min: T, mode: T, max: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::poisson<T>(lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::distributions::rayleigh<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::set_seed(seed: u64)
pub fn numrs2::random::distributions::standard_normal<T>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::student_t<T>(df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::triangular<T>(low: T, mode: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::truncated_normal<T>(mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::uniform<T>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast
pub fn numrs2::random::distributions::vonmises<T>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::wald<T>(mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::weibull<T>(shape_param: T, scale: T, output_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions::zipf<T>(a: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub mod numrs2::random::distributions_enhanced
pub fn numrs2::random::distributions_enhanced::copula<T>(corr: &numrs2::array::Array<T>, n: usize, copula_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions_enhanced::latin_hypercube<T>(dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions_enhanced::maxwell<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions_enhanced::mixture_of_normals<T>(weights: &[T], means: &[T], stds: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions_enhanced::multivariate_normal_cholesky<T>(means: &[T], cov: &numrs2::array::Array<T>, size: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions_enhanced::noncentral_chisquare<T>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions_enhanced::noncentral_f<T>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions_enhanced::power<T>(a: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions_enhanced::random_correlation_matrix<T>(n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::random::distributions_enhanced::sobol_sequence<T>(dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::distributions_enhanced::truncated_normal<T>(mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::random::distributions_enhanced::vonmises<T>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub mod numrs2::random::generator
pub struct numrs2::random::generator::Generator<B: numrs2::random::generator::BitGenerator>
impl<B: numrs2::random::generator::BitGenerator> numrs2::random::generator::Generator<B>
pub fn numrs2::random::generator::Generator<B>::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::beta<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::bit_generator(&self) -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'_, B>>
pub fn numrs2::random::generator::Generator<B>::chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::integers<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::random::generator::Generator<B>::integers_simple<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::new(bit_generator: B) -> Self
pub fn numrs2::random::generator::Generator<B>::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::poisson<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + num_traits::cast::NumCast
pub fn numrs2::random::generator::Generator<B>::standard_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::weibull<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub struct numrs2::random::generator::PCG64BitGenerator
impl numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::get_inc(&self) -> u128
pub fn numrs2::random::generator::PCG64BitGenerator::get_state(&self) -> u128
pub fn numrs2::random::generator::PCG64BitGenerator::new(seed: u64) -> Self
pub fn numrs2::random::generator::PCG64BitGenerator::new_random() -> Self
pub fn numrs2::random::generator::PCG64BitGenerator::with_state_and_inc(state: u128, inc: u128) -> Self
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::PCG64BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::PCG64BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::PCG64BitGenerator::seed(&mut self, seed: u64)
pub struct numrs2::random::generator::StdBitGenerator
impl numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::new(seed: u64) -> Self
pub fn numrs2::random::generator::StdBitGenerator::new_random() -> Self
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::StdBitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::StdBitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::StdBitGenerator::seed(&mut self, seed: u64)
pub trait numrs2::random::generator::BitGenerator
pub fn numrs2::random::generator::BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::BitGenerator::seed(&mut self, seed: u64)
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::PCG64BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::PCG64BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::PCG64BitGenerator::seed(&mut self, seed: u64)
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::StdBitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::StdBitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::StdBitGenerator::seed(&mut self, seed: u64)
pub fn numrs2::random::generator::default_rng() -> numrs2::random::generator::Generator<numrs2::random::generator::StdBitGenerator>
pub fn numrs2::random::generator::pcg64_rng() -> numrs2::random::generator::Generator<numrs2::random::generator::PCG64BitGenerator>
pub fn numrs2::random::generator::pcg64_seed_rng(seed: u64) -> numrs2::random::generator::Generator<numrs2::random::generator::PCG64BitGenerator>
pub fn numrs2::random::generator::seed_rng(seed: u64) -> numrs2::random::generator::Generator<numrs2::random::generator::StdBitGenerator>
pub mod numrs2::random::legacy
pub struct numrs2::random::legacy::Generator
impl numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::choice<T: core::clone::Clone>(&self, array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::new() -> Self
pub fn numrs2::random::legacy::Generator::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::permutation<T: num_traits::cast::NumCast + core::clone::Clone>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::legacy::Generator::shuffle<T: core::clone::Clone>(&self, array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::legacy::Generator::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::with_seed(seed: u64) -> Self
impl core::default::Default for numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::default() -> Self
pub fn numrs2::random::legacy::choice<T: core::clone::Clone>(array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::rand<T>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::legacy::randn<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::seed(seed: u64)
pub fn numrs2::random::legacy::shuffle<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::legacy::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::random::random_base
pub struct numrs2::random::random_base::Generator
impl numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::choice<T: core::clone::Clone>(&self, array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::new() -> Self
pub fn numrs2::random::legacy::Generator::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::permutation<T: num_traits::cast::NumCast + core::clone::Clone>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::legacy::Generator::shuffle<T: core::clone::Clone>(&self, array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::legacy::Generator::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::with_seed(seed: u64) -> Self
impl core::default::Default for numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::default() -> Self
pub fn numrs2::random::random_base::choice<T: core::clone::Clone>(array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::random_base::rand<T>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::random_base::randn<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::random_base::seed(seed: u64)
pub fn numrs2::random::random_base::shuffle<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::random_base::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::random::state
pub struct numrs2::random::state::RandomState
impl numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::beta<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::cauchy<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::choice<T: core::clone::Clone>(&self, array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::dirichlet<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, alpha: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::geometric<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::get_rng(&self) -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'_, scirs2_core::random::prelude::StdRng>>
pub fn numrs2::random::state::RandomState::gumbel<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::hypergeometric<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, ngood: usize, nbad: usize, nsample: usize, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::integers<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::random::state::RandomState::laplace<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::logistic<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::logseries<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multinomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: usize, pvals: &[f64], shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multivariate_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multivariate_normal_with_rotation<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>, rotation: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::negative_binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: f64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::new() -> Self
pub fn numrs2::random::state::RandomState::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::pareto<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, alpha: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::permutation<T: num_traits::cast::NumCast + core::clone::Clone>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::pert<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, min: T, mode: T, max: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::poisson<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::state::RandomState::rayleigh<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::shuffle<T: core::clone::Clone>(&self, array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::state::RandomState::standard_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::student_t<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::triangular<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, low: T, mode: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::wald<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::weibull<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::with_seed(seed: u64) -> Self
pub fn numrs2::random::state::RandomState::zipf<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, a: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
impl numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::copula<T>(&self, corr: &numrs2::array::Array<T>, n: usize, copula_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::latin_hypercube<T>(&self, dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::maxwell<T>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::mixture_of_normals<T>(&self, weights: &[T], means: &[T], stds: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::multivariate_normal_cholesky<T>(&self, means: &[T], cov: &numrs2::array::Array<T>, size: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::noncentral_chisquare<T>(&self, df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::noncentral_f<T>(&self, dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::power<T>(&self, a: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::random_correlation_matrix<T>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::random::state::RandomState::sobol_sequence<T>(&self, dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::truncated_normal<T>(&self, mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::vonmises<T>(&self, mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
impl core::default::Default for numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::default() -> Self
pub struct numrs2::random::Generator<B: numrs2::random::generator::BitGenerator>
impl<B: numrs2::random::generator::BitGenerator> numrs2::random::generator::Generator<B>
pub fn numrs2::random::generator::Generator<B>::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::beta<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::bit_generator(&self) -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'_, B>>
pub fn numrs2::random::generator::Generator<B>::chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::integers<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::random::generator::Generator<B>::integers_simple<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::new(bit_generator: B) -> Self
pub fn numrs2::random::generator::Generator<B>::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::poisson<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + num_traits::float::Float + num_traits::cast::NumCast
pub fn numrs2::random::generator::Generator<B>::standard_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::generator::Generator<B>::weibull<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub struct numrs2::random::LegacyGenerator
impl numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::choice<T: core::clone::Clone>(&self, array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::new() -> Self
pub fn numrs2::random::legacy::Generator::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::permutation<T: num_traits::cast::NumCast + core::clone::Clone>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::legacy::Generator::shuffle<T: core::clone::Clone>(&self, array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::legacy::Generator::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::with_seed(seed: u64) -> Self
impl core::default::Default for numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::default() -> Self
pub struct numrs2::random::PCG64BitGenerator
impl numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::get_inc(&self) -> u128
pub fn numrs2::random::generator::PCG64BitGenerator::get_state(&self) -> u128
pub fn numrs2::random::generator::PCG64BitGenerator::new(seed: u64) -> Self
pub fn numrs2::random::generator::PCG64BitGenerator::new_random() -> Self
pub fn numrs2::random::generator::PCG64BitGenerator::with_state_and_inc(state: u128, inc: u128) -> Self
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::PCG64BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::PCG64BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::PCG64BitGenerator::seed(&mut self, seed: u64)
pub struct numrs2::random::RandomState
impl numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::beta<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::cauchy<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::choice<T: core::clone::Clone>(&self, array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::dirichlet<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, alpha: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::geometric<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::get_rng(&self) -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'_, scirs2_core::random::prelude::StdRng>>
pub fn numrs2::random::state::RandomState::gumbel<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::hypergeometric<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, ngood: usize, nbad: usize, nsample: usize, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::integers<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::random::state::RandomState::laplace<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::logistic<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::logseries<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multinomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: usize, pvals: &[f64], shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multivariate_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::multivariate_normal_with_rotation<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>, rotation: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::negative_binomial<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, n: f64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::new() -> Self
pub fn numrs2::random::state::RandomState::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::pareto<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, alpha: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::permutation<T: num_traits::cast::NumCast + core::clone::Clone>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::pert<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, min: T, mode: T, max: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::poisson<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::state::RandomState::rayleigh<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::shuffle<T: core::clone::Clone>(&self, array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::state::RandomState::standard_normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::student_t<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::triangular<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, low: T, mode: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::wald<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::weibull<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::state::RandomState::with_seed(seed: u64) -> Self
pub fn numrs2::random::state::RandomState::zipf<T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug>(&self, a: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
impl numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::copula<T>(&self, corr: &numrs2::array::Array<T>, n: usize, copula_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::latin_hypercube<T>(&self, dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::maxwell<T>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::mixture_of_normals<T>(&self, weights: &[T], means: &[T], stds: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::multivariate_normal_cholesky<T>(&self, means: &[T], cov: &numrs2::array::Array<T>, size: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::noncentral_chisquare<T>(&self, df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::noncentral_f<T>(&self, dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::power<T>(&self, a: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::random_correlation_matrix<T>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::random::state::RandomState::sobol_sequence<T>(&self, dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::truncated_normal<T>(&self, mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::state::RandomState::vonmises<T>(&self, mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
impl core::default::Default for numrs2::random::state::RandomState
pub fn numrs2::random::state::RandomState::default() -> Self
pub struct numrs2::random::StdBitGenerator
impl numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::new(seed: u64) -> Self
pub fn numrs2::random::generator::StdBitGenerator::new_random() -> Self
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::StdBitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::StdBitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::StdBitGenerator::seed(&mut self, seed: u64)
pub trait numrs2::random::BitGenerator
pub fn numrs2::random::BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::BitGenerator::seed(&mut self, seed: u64)
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::PCG64BitGenerator
pub fn numrs2::random::generator::PCG64BitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::PCG64BitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::PCG64BitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::PCG64BitGenerator::seed(&mut self, seed: u64)
impl numrs2::random::generator::BitGenerator for numrs2::random::generator::StdBitGenerator
pub fn numrs2::random::generator::StdBitGenerator::next_f64(&mut self) -> f64
pub fn numrs2::random::generator::StdBitGenerator::next_u32(&mut self) -> u32
pub fn numrs2::random::generator::StdBitGenerator::next_u64(&mut self) -> u64
pub fn numrs2::random::generator::StdBitGenerator::seed(&mut self, seed: u64)
pub fn numrs2::random::bernoulli<T>(p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::beta<T>(a: T, b: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::binomial<T>(n: u64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::cauchy<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::chisquare<T>(df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::choice<T: core::clone::Clone>(array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::copula<T>(corr: &numrs2::array::Array<T>, n: usize, copula_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::default_rng() -> numrs2::random::generator::Generator<numrs2::random::generator::StdBitGenerator>
pub fn numrs2::random::dirichlet<T>(alpha: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::exponential<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::gamma<T>(shape_param: T, scale: T, output_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::geometric<T>(p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::get_global_random_state() -> numrs2::Result<std::sync::poison::mutex::MutexGuard<'static, numrs2::random::state::RandomState>>
pub fn numrs2::random::gumbel<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::hypergeometric<T>(ngood: usize, nbad: usize, nsample: usize, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::integers<T>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + core::convert::Into<i64> + core::convert::TryFrom<i64> + num_traits::cast::ToPrimitive, <T as core::convert::TryFrom<i64>>::Error: core::fmt::Debug
pub fn numrs2::random::laplace<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::latin_hypercube<T>(dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::logistic<T>(loc: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::lognormal<T>(mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::logseries<T>(p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::maxwell<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::maxwell<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::mixture_of_normals<T>(weights: &[T], means: &[T], stds: &[T], shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::multinomial<T>(n: usize, pvals: &[f64], shape: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::multivariate_normal<T>(mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::multivariate_normal_cholesky<T>(means: &[T], cov: &numrs2::array::Array<T>, size: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::multivariate_normal_with_rotation<T>(mean: &[T], cov: &numrs2::array::Array<T>, size: core::option::Option<&[usize]>, rotation: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::negative_binomial<T>(n: f64, p: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::noncentral_chisquare<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::noncentral_chisquare<T>(df: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::noncentral_f<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::noncentral_f<T>(dfnum: T, dfden: T, nonc: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::normal<T>(mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::pareto<T>(alpha: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::pcg64_rng() -> numrs2::random::generator::Generator<numrs2::random::generator::PCG64BitGenerator>
pub fn numrs2::random::pcg64_seed_rng(seed: u64) -> numrs2::random::generator::Generator<numrs2::random::generator::PCG64BitGenerator>
pub fn numrs2::random::pert<T>(min: T, mode: T, max: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::poisson<T>(lam: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub fn numrs2::random::power<T>(a: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::rand<T>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::randn<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::random_correlation_matrix<T>(n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::random::rayleigh<T>(scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::seed(seed: u64)
pub fn numrs2::random::seed_rng(seed: u64) -> numrs2::random::state::RandomState
pub fn numrs2::random::set_seed(seed: u64)
pub fn numrs2::random::shuffle<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::sobol_sequence<T>(dim: usize, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::standard_normal<T>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::student_t<T>(df: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::triangular<T>(low: T, mode: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::truncated_normal<T>(mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::truncated_normal<T>(mean: T, std: T, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display + rand::distr::uniform::SampleUniform
pub fn numrs2::random::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::uniform<T>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::cast::ToPrimitive + num_traits::cast::NumCast
pub fn numrs2::random::vonmises<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::vonmises<T>(mu: T, kappa: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::wald<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::wald<T>(mean: T, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::weibull<T>(shape_param: T, scale: T, output_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display
pub fn numrs2::random::zipf<T>(a: f64, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug
pub mod numrs2::random_base
pub struct numrs2::random_base::Generator
impl numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::bernoulli<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, p: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::choice<T: core::clone::Clone>(&self, array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::exponential<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, scale: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::gamma<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, shape_param: T, scale: T, size_shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::lognormal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, sigma: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::new() -> Self
pub fn numrs2::random::legacy::Generator::normal<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(&self, mean: T, std: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::permutation<T: num_traits::cast::NumCast + core::clone::Clone>(&self, n: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::random<T>(&self, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random::legacy::Generator::shuffle<T: core::clone::Clone>(&self, array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random::legacy::Generator::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(&self, low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random::legacy::Generator::with_seed(seed: u64) -> Self
impl core::default::Default for numrs2::random::legacy::Generator
pub fn numrs2::random::legacy::Generator::default() -> Self
pub fn numrs2::random_base::choice<T: core::clone::Clone>(array: &numrs2::array::Array<T>, size: core::option::Option<usize>, replace: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random_base::rand<T>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + rand::distr::uniform::SampleUniform + num_traits::cast::NumCast
pub fn numrs2::random_base::randn<T: num_traits::float::Float + num_traits::cast::NumCast + core::clone::Clone + core::fmt::Debug + core::fmt::Display>(shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::random_base::seed(seed: u64)
pub fn numrs2::random_base::shuffle<T: core::clone::Clone>(array: &mut numrs2::array::Array<T>) -> numrs2::Result<()>
pub fn numrs2::random_base::uniform<T: core::clone::Clone + core::cmp::PartialOrd + rand::distr::uniform::SampleUniform + num_traits::float::Float + num_traits::cast::NumCast + core::fmt::Display>(low: T, high: T, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::roots
pub struct numrs2::roots::RootResult<T: num_traits::float::Float>
pub numrs2::roots::RootResult::converged: bool
pub numrs2::roots::RootResult::fun_val: T
pub numrs2::roots::RootResult::nfev: usize
pub numrs2::roots::RootResult::nit: usize
pub numrs2::roots::RootResult::root: T
pub fn numrs2::roots::bisect<T, F>(f: F, a: T, b: T, tol: T, max_iter: usize) -> numrs2::Result<numrs2::roots::RootResult<T>> where T: num_traits::float::Float, F: core::ops::function::Fn(T) -> T
pub fn numrs2::roots::brentq<T, F>(f: F, a: T, b: T, tol: T, max_iter: usize) -> numrs2::Result<numrs2::roots::RootResult<T>> where T: num_traits::float::Float, F: core::ops::function::Fn(T) -> T
pub fn numrs2::roots::fixed_point<T, G>(g: G, x: T, tol: T, max_iter: usize) -> numrs2::Result<T> where T: num_traits::float::Float, G: core::ops::function::Fn(T) -> T
pub fn numrs2::roots::halley<T, F, DF, DDF>(f: F, df: DF, ddf: DDF, x: T, tol: T, max_iter: usize) -> numrs2::Result<numrs2::roots::RootResult<T>> where T: num_traits::float::Float, F: core::ops::function::Fn(T) -> T, DF: core::ops::function::Fn(T) -> T, DDF: core::ops::function::Fn(T) -> T
pub fn numrs2::roots::illinois<T, F>(f: F, a: T, b: T, tol: T, max_iter: usize) -> numrs2::Result<numrs2::roots::RootResult<T>> where T: num_traits::float::Float, F: core::ops::function::Fn(T) -> T
pub fn numrs2::roots::newton<T, F, DF>(f: F, df: DF, x: T, tol: T, max_iter: usize) -> numrs2::Result<numrs2::roots::RootResult<T>> where T: num_traits::float::Float, F: core::ops::function::Fn(T) -> T, DF: core::ops::function::Fn(T) -> T
pub fn numrs2::roots::ridder<T, F>(f: F, a: T, b: T, tol: T, max_iter: usize) -> numrs2::Result<numrs2::roots::RootResult<T>> where T: num_traits::float::Float, F: core::ops::function::Fn(T) -> T
pub fn numrs2::roots::secant<T, F>(f: F, x0: T, x1: T, tol: T, max_iter: usize) -> numrs2::Result<numrs2::roots::RootResult<T>> where T: num_traits::float::Float, F: core::ops::function::Fn(T) -> T
pub mod numrs2::set_ops
pub fn numrs2::set_ops::ediff1d<T>(ary: &numrs2::array::Array<T>, to_end: core::option::Option<&numrs2::array::Array<T>>, to_begin: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::ops::arith::Sub<Output = T>
pub fn numrs2::set_ops::in1d<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash>(ar1: &numrs2::array::Array<T>, ar2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::set_ops::intersect1d<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::cmp::Ord>(ar1: &numrs2::array::Array<T>, ar2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::set_ops::isin<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash>(element: &numrs2::array::Array<T>, test_elements: &numrs2::array::Array<T>, assume_unique: bool, invert: bool) -> numrs2::Result<numrs2::array::Array<bool>>
pub fn numrs2::set_ops::setdiff1d<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::cmp::Ord>(ar1: &numrs2::array::Array<T>, ar2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::set_ops::setxor1d<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::cmp::Ord>(ar1: &numrs2::array::Array<T>, ar2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::set_ops::union1d<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::cmp::Ord>(ar1: &numrs2::array::Array<T>, ar2: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::set_ops::unique_axis<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::cmp::Ord + core::fmt::Debug + num_traits::identities::Zero>(ar: &numrs2::array::Array<T>, axis: core::option::Option<usize>, return_index: bool, return_inverse: bool, return_counts: bool) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::set_ops::unique_with_options<T: core::clone::Clone + core::cmp::Eq + core::hash::Hash + core::cmp::Ord + core::fmt::Debug>(ar: &numrs2::array::Array<T>, return_index: bool, return_inverse: bool, return_counts: bool) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub mod numrs2::shared_array
pub struct numrs2::shared_array::SharedArray<T>
impl<T: core::clone::Clone> numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::add(&self, other: &Self) -> numrs2::Result<Self> where T: core::ops::arith::Add<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::as_arc_array(&self) -> &ndarray::ArcArray<T, ndarray::aliases::IxDyn>
pub fn numrs2::shared_array::SharedArray<T>::div(&self, other: &Self) -> numrs2::Result<Self> where T: core::ops::arith::Div<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::flatten(&self) -> Self
pub fn numrs2::shared_array::SharedArray<T>::from_arc_array(data: ndarray::ArcArray<T, ndarray::aliases::IxDyn>) -> Self
pub fn numrs2::shared_array::SharedArray<T>::from_array(arr: numrs2::array::Array<T>) -> Self
pub fn numrs2::shared_array::SharedArray<T>::from_vec(data: alloc::vec::Vec<T>) -> Self
pub fn numrs2::shared_array::SharedArray<T>::from_vec_with_shape(data: alloc::vec::Vec<T>, shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::shared_array::SharedArray<T>::full(shape: &[usize], value: T) -> Self
pub fn numrs2::shared_array::SharedArray<T>::get(&self, indices: &[usize]) -> core::option::Option<&T>
pub fn numrs2::shared_array::SharedArray<T>::get_mut(&mut self, indices: &[usize]) -> core::option::Option<&mut T>
pub fn numrs2::shared_array::SharedArray<T>::is_empty(&self) -> bool
pub fn numrs2::shared_array::SharedArray<T>::is_unique(&self) -> bool
pub fn numrs2::shared_array::SharedArray<T>::max(&self) -> core::option::Option<T> where T: core::cmp::PartialOrd + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::mean(&self) -> core::option::Option<T> where T: num_traits::float::Float + num_traits::cast::NumCast
pub fn numrs2::shared_array::SharedArray<T>::min(&self) -> core::option::Option<T> where T: core::cmp::PartialOrd + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::mul(&self, other: &Self) -> numrs2::Result<Self> where T: core::ops::arith::Mul<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::ndim(&self) -> usize
pub fn numrs2::shared_array::SharedArray<T>::ones(shape: &[usize]) -> Self where T: num_traits::identities::One
pub fn numrs2::shared_array::SharedArray<T>::ref_count(&self) -> usize
pub fn numrs2::shared_array::SharedArray<T>::reshape(&self, new_shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::shared_array::SharedArray<T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::shared_array::SharedArray<T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::shared_array::SharedArray<T>::size(&self) -> usize
pub fn numrs2::shared_array::SharedArray<T>::strides(&self) -> alloc::vec::Vec<isize>
pub fn numrs2::shared_array::SharedArray<T>::sub(&self, other: &Self) -> numrs2::Result<Self> where T: core::ops::arith::Sub<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::sum(&self) -> T where T: num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::to_owned_array(&self) -> numrs2::array::Array<T>
pub fn numrs2::shared_array::SharedArray<T>::to_vec(&self) -> alloc::vec::Vec<T>
pub fn numrs2::shared_array::SharedArray<T>::transpose(&self) -> Self
pub fn numrs2::shared_array::SharedArray<T>::view(&self) -> ndarray::ArrayView<'_, T, ndarray::aliases::IxDyn>
pub fn numrs2::shared_array::SharedArray<T>::zeros(shape: &[usize]) -> Self where T: num_traits::identities::Zero
impl<T: core::clone::Clone> numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::add_scalar(&self, scalar: T) -> Self where T: core::ops::arith::Add<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::div_scalar(&self, scalar: T) -> Self where T: core::ops::arith::Div<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::mul_scalar(&self, scalar: T) -> Self where T: core::ops::arith::Mul<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::neg(&self) -> Self where T: core::ops::arith::Neg<Output = T> + core::marker::Copy
pub fn numrs2::shared_array::SharedArray<T>::sub_scalar(&self, scalar: T) -> Self where T: core::ops::arith::Sub<Output = T> + core::marker::Copy
impl<T: core::clone::Clone> numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::shared_view(&self) -> numrs2::shared_array::SharedArrayView<T>
impl<T: core::clone::Clone + core::cmp::PartialEq> core::cmp::PartialEq for numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::eq(&self, other: &Self) -> bool
impl<T: core::clone::Clone> core::convert::From<alloc::vec::Vec<T>> for numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::from(vec: alloc::vec::Vec<T>) -> Self
impl<T: core::clone::Clone> core::convert::From<numrs2::array::Array<T>> for numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::from(arr: numrs2::array::Array<T>) -> Self
impl<T: core::clone::Clone> core::convert::From<numrs2::shared_array::SharedArray<T>> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::from(shared: numrs2::shared_array::SharedArray<T>) -> Self
impl<T: core::clone::Clone> core::ops::index::Index<&[usize]> for numrs2::shared_array::SharedArray<T>
pub type numrs2::shared_array::SharedArray<T>::Output = T
pub fn numrs2::shared_array::SharedArray<T>::index(&self, indices: &[usize]) -> &Self::Output
impl<T: core::fmt::Debug + core::clone::Clone> core::fmt::Debug for numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::fmt::Display + core::clone::Clone> core::fmt::Display for numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T> core::ops::arith::Add for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::add(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Add for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::add(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Add<&numrs2::shared_array::SharedArray<T>> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::add(self, rhs: &numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Add<T> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::add(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Add<T> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::add(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Add<numrs2::shared_array::SharedArray<T>> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Add<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::add(self, rhs: numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Div for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::div(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Div for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::div(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Div<&numrs2::shared_array::SharedArray<T>> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::div(self, rhs: &numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Div<T> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::div(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Div<T> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::div(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Div<numrs2::shared_array::SharedArray<T>> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Div<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::div(self, rhs: numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Mul for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::mul(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Mul for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::mul(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Mul<&numrs2::shared_array::SharedArray<T>> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::mul(self, rhs: &numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Mul<T> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::mul(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Mul<T> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::mul(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Mul<numrs2::shared_array::SharedArray<T>> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Mul<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::mul(self, rhs: numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Neg for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Neg<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::neg(self) -> Self::Output
impl<T> core::ops::arith::Neg for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Neg<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::neg(self) -> Self::Output
impl<T> core::ops::arith::Sub for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::sub(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Sub for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::sub(self, rhs: Self) -> Self::Output
impl<T> core::ops::arith::Sub<&numrs2::shared_array::SharedArray<T>> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::sub(self, rhs: &numrs2::shared_array::SharedArray<T>) -> Self::Output
impl<T> core::ops::arith::Sub<T> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::sub(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Sub<T> for numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + core::marker::Copy
pub type numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn numrs2::shared_array::SharedArray<T>::sub(self, scalar: T) -> Self::Output
impl<T> core::ops::arith::Sub<numrs2::shared_array::SharedArray<T>> for &numrs2::shared_array::SharedArray<T> where T: core::clone::Clone + core::ops::arith::Sub<Output = T> + core::marker::Copy
pub type &numrs2::shared_array::SharedArray<T>::Output = numrs2::shared_array::SharedArray<T>
pub fn &numrs2::shared_array::SharedArray<T>::sub(self, rhs: numrs2::shared_array::SharedArray<T>) -> Self::Output
pub struct numrs2::shared_array::SharedArrayView<T>
impl<T: core::clone::Clone> numrs2::shared_array::SharedArrayView<T>
pub fn numrs2::shared_array::SharedArrayView<T>::get(&self, indices: &[usize]) -> core::option::Option<&T>
pub fn numrs2::shared_array::SharedArrayView<T>::new(source: numrs2::shared_array::SharedArray<T>) -> Self
pub fn numrs2::shared_array::SharedArrayView<T>::shape(&self) -> &[usize]
pub fn numrs2::shared_array::SharedArrayView<T>::slice(source: numrs2::shared_array::SharedArray<T>, offset: alloc::vec::Vec<usize>, shape: alloc::vec::Vec<usize>) -> Self
pub fn numrs2::shared_array::SharedArrayView<T>::to_shared_array(&self) -> numrs2::shared_array::SharedArray<T>
pub mod numrs2::signal
pub mod numrs2::signal::enhanced
pub struct numrs2::signal::enhanced::FFTEnhanced
impl numrs2::signal::enhanced::FFTEnhanced
pub fn numrs2::signal::enhanced::FFTEnhanced::apply_window<T>(x: &numrs2::array::Array<T>, window_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub fn numrs2::signal::enhanced::FFTEnhanced::fft_any_size<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::enhanced::FFTEnhanced::ifft_any_size<T>(x: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::enhanced::FFTEnhanced::real_fft_optimized<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::enhanced::FFTEnhanced::stockwell_transform<T>(x: &numrs2::array::Array<T>, min_freq: core::option::Option<usize>, max_freq: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::enhanced::FFTEnhanced::window<T>(window_type: &str, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub fn numrs2::signal::enhanced::FFTEnhanced::window_energy_concentration<T>(window_types: &[&str], n: usize) -> numrs2::Result<alloc::vec::Vec<(alloc::string::String, T)>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64> + core::convert::Into<f64>
pub struct numrs2::signal::FFT
impl numrs2::signal::FFT
pub fn numrs2::signal::FFT::apply_window<T>(x: &numrs2::array::Array<T>, window_type: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub fn numrs2::signal::FFT::fft<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::fft2<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::fftfreq<T>(n: usize, d: T) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub fn numrs2::signal::FFT::fftshift<T: core::clone::Clone>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::signal::FFT::ifft<T>(x: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::ifft2<T>(x: &numrs2::array::Array<num_complex::Complex<T>>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::ifftshift<T: core::clone::Clone>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::signal::FFT::irfft<T>(x: &numrs2::array::Array<num_complex::Complex<T>>, n: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::irfft2<T>(x: &numrs2::array::Array<num_complex::Complex<T>>, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::power_spectrum<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::rfft<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::rfft2<T>(x: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<T>>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::Into<f64> + core::convert::From<f64>
pub fn numrs2::signal::FFT::rfftfreq<T>(n: usize, d: T) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + core::convert::From<f64>
pub fn numrs2::signal::bartlett<T>(m: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::cast::FromPrimitive
pub fn numrs2::signal::blackman<T>(m: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::cast::FromPrimitive
pub fn numrs2::signal::convolve<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, mode: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + core::marker::Send + core::marker::Sync
pub fn numrs2::signal::convolve2d<T>(input: &numrs2::array::Array<T>, kernel: &numrs2::array::Array<T>, mode: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::marker::Send + core::marker::Sync
pub fn numrs2::signal::correlate<T>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>, mode: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + core::marker::Send + core::marker::Sync
pub fn numrs2::signal::correlate2d<T>(input: &numrs2::array::Array<T>, template: &numrs2::array::Array<T>, mode: &str) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::marker::Send + core::marker::Sync
pub fn numrs2::signal::hamming<T>(m: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::cast::FromPrimitive
pub fn numrs2::signal::hanning<T>(m: usize) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::cast::FromPrimitive
pub fn numrs2::signal::kaiser<T>(m: usize, beta: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::cast::FromPrimitive
pub fn numrs2::signal::unwrap<T>(phase: &numrs2::array::Array<T>, discont: core::option::Option<T>, axis: core::option::Option<usize>, period: core::option::Option<T>) -> numrs2::Result<numrs2::array::Array<T>> where T: num_traits::float::Float + core::fmt::Debug
pub mod numrs2::simd
pub trait numrs2::simd::SimdOps<T>
pub fn numrs2::simd::SimdOps::simd_add(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::simd::SimdOps::simd_add_scalar(&self, scalar: T) -> numrs2::array::Array<T>
pub fn numrs2::simd::SimdOps::simd_div(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::simd::SimdOps::simd_div_scalar(&self, scalar: T) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::simd::SimdOps::simd_dot(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<T>
pub fn numrs2::simd::SimdOps::simd_fma(&self, mul: &numrs2::array::Array<T>, add: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::simd::SimdOps::simd_mean(&self) -> T
pub fn numrs2::simd::SimdOps::simd_mul(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::simd::SimdOps::simd_mul_scalar(&self, scalar: T) -> numrs2::array::Array<T>
pub fn numrs2::simd::SimdOps::simd_sub(&self, other: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::simd::SimdOps::simd_sub_scalar(&self, scalar: T) -> numrs2::array::Array<T>
pub fn numrs2::simd::SimdOps::simd_sum(&self) -> T
impl numrs2::simd::SimdOps<f32> for numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_add(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_add_scalar(&self, scalar: f32) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_div(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_div_scalar(&self, scalar: f32) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_dot(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<f32>
pub fn numrs2::array::Array<f32>::simd_fma(&self, mul: &numrs2::array::Array<f32>, add: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_mean(&self) -> f32
pub fn numrs2::array::Array<f32>::simd_mul(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_mul_scalar(&self, scalar: f32) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_sub(&self, other: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_sub_scalar(&self, scalar: f32) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_sum(&self) -> f32
impl numrs2::simd::SimdOps<f64> for numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::simd_add(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_add_scalar(&self, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::simd_div(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_div_scalar(&self, scalar: f64) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_dot(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<f64>
pub fn numrs2::array::Array<f64>::simd_fma(&self, mul: &numrs2::array::Array<f64>, add: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_mean(&self) -> f64
pub fn numrs2::array::Array<f64>::simd_mul(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_mul_scalar(&self, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::simd_sub(&self, other: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::array::Array<f64>::simd_sub_scalar(&self, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::array::Array<f64>::simd_sum(&self) -> f64
pub fn numrs2::simd::get_simd_implementation_name() -> alloc::string::String
pub fn numrs2::simd::simd_add<T: num_traits::float::Float + 'static>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where numrs2::array::Array<T>: numrs2::simd::SimdOps<T>
pub fn numrs2::simd::simd_div<T: num_traits::float::Float + 'static>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where numrs2::array::Array<T>: numrs2::simd::SimdOps<T>
pub fn numrs2::simd::simd_exp<T: num_traits::float::Float + 'static>(a: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::simd::simd_log<T: num_traits::float::Float + 'static>(a: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::simd::simd_mean<T: num_traits::float::Float + 'static>(a: &numrs2::array::Array<T>) -> T where numrs2::array::Array<T>: numrs2::simd::SimdOps<T>
pub fn numrs2::simd::simd_mul<T: num_traits::float::Float + 'static>(a: &numrs2::array::Array<T>, b: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::array::Array<T>> where numrs2::array::Array<T>: numrs2::simd::SimdOps<T>
pub fn numrs2::simd::simd_prod<T: num_traits::float::Float + 'static>(a: &numrs2::array::Array<T>) -> T
pub fn numrs2::simd::simd_sqrt<T: num_traits::float::Float + 'static>(a: &numrs2::array::Array<T>) -> numrs2::array::Array<T>
pub fn numrs2::simd::simd_sum<T: num_traits::float::Float + 'static>(a: &numrs2::array::Array<T>) -> T where numrs2::array::Array<T>: numrs2::simd::SimdOps<T>
pub mod numrs2::simd_optimize
pub mod numrs2::simd_optimize::avx2_enhanced
pub struct numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps
impl numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::cache_aware_matmul_f32(a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>, c: &mut numrs2::array::Array<f32>, block_size: usize) -> numrs2::Result<()>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::complex_multiply_f32(a_real: &numrs2::array::Array<f32>, a_imag: &numrs2::array::Array<f32>, b_real: &numrs2::array::Array<f32>, b_imag: &numrs2::array::Array<f32>) -> numrs2::Result<(numrs2::array::Array<f32>, numrs2::array::Array<f32>)>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::kahan_sum_f32(input: &numrs2::array::Array<f32>) -> f32
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::optimized_copy_f32(src: &numrs2::array::Array<f32>, dst: &mut numrs2::array::Array<f32>) -> numrs2::Result<()>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_abs_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_abs_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_acos_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_acosh_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_add_arrays_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_add_scalar_f64(a: &numrs2::array::Array<f64>, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_arange_f64(start: f64, stop: f64, step: f64) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_asin_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_asinh_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_atan_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_atanh_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_cbrt_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_ceil_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_clip_f32(input: &numrs2::array::Array<f32>, min_val: f32, max_val: f32) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_clip_f64(input: &numrs2::array::Array<f64>, min_val: f64, max_val: f64) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_copysign_f64(x: &numrs2::array::Array<f64>, y: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_cos_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_cos_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_cosh_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_cosh_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_cumsum_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_degrees_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_diff_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_diff_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_div_arrays_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_dot_f32(x: &numrs2::array::Array<f32>, y: &numrs2::array::Array<f32>) -> numrs2::Result<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_dot_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_exp_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_exp_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_expm1_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_floor_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_fma_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>, c: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_gradient_f64(input: &numrs2::array::Array<f64>, spacing: f64) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_hypot_f64(x: &numrs2::array::Array<f64>, y: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_linspace_f64(start: f64, stop: f64, n: usize) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_log10_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_log10_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_log1p_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_log2_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_log2_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_log_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_log_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_max_f32(input: &numrs2::array::Array<f32>) -> f32
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_max_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_maximum_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_mean_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_min_f32(input: &numrs2::array::Array<f32>) -> f32
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_min_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_minimum_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_mul_arrays_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_mul_scalar_f64(a: &numrs2::array::Array<f64>, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_negative_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_norm_l1_f32(x: &numrs2::array::Array<f32>) -> f32
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_norm_l1_f64(a: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_norm_l2_f32(x: &numrs2::array::Array<f32>) -> f32
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_norm_l2_f64(a: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_norm_linf_f32(x: &numrs2::array::Array<f32>) -> f32
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_norm_linf_f64(x: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_pow_f32(input: &numrs2::array::Array<f32>, n: f32) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_pow_f64(input: &numrs2::array::Array<f64>, n: f64) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_prod_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_radians_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_reciprocal_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_round_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_sign_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_sin_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_sin_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_sinh_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_sinh_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_sqrt_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_sqrt_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_square_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_std_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_sub_arrays_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_sum_f32(input: &numrs2::array::Array<f32>) -> f32
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_sum_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_tan_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_tan_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_tanh_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_tanh_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_trunc_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_enhanced::EnhancedSimdOps::vectorized_variance_f64(input: &numrs2::array::Array<f64>) -> f64
pub struct numrs2::simd_optimize::avx2_enhanced::SimdBenchmark
impl numrs2::simd_optimize::avx2_enhanced::SimdBenchmark
pub fn numrs2::simd_optimize::avx2_enhanced::SimdBenchmark::compare_implementations(size: usize, iterations: usize) -> numrs2::simd_optimize::avx2_enhanced::SimdBenchmarkResults
pub struct numrs2::simd_optimize::avx2_enhanced::SimdBenchmarkResults
pub numrs2::simd_optimize::avx2_enhanced::SimdBenchmarkResults::elements: usize
pub numrs2::simd_optimize::avx2_enhanced::SimdBenchmarkResults::scalar_time_ns: f64
pub numrs2::simd_optimize::avx2_enhanced::SimdBenchmarkResults::simd_time_ns: f64
pub numrs2::simd_optimize::avx2_enhanced::SimdBenchmarkResults::speedup: f64
pub numrs2::simd_optimize::avx2_enhanced::SimdBenchmarkResults::throughput_elements_per_ns: f64
impl numrs2::simd_optimize::avx2_enhanced::SimdBenchmarkResults
pub fn numrs2::simd_optimize::avx2_enhanced::SimdBenchmarkResults::print_summary(&self)
pub struct numrs2::simd_optimize::avx2_enhanced::SimdPerformanceMonitor
pub numrs2::simd_optimize::avx2_enhanced::SimdPerformanceMonitor::cache_misses: u64
pub numrs2::simd_optimize::avx2_enhanced::SimdPerformanceMonitor::operations_count: u64
pub numrs2::simd_optimize::avx2_enhanced::SimdPerformanceMonitor::total_elements: u64
pub numrs2::simd_optimize::avx2_enhanced::SimdPerformanceMonitor::vectorization_ratio: f64
impl numrs2::simd_optimize::avx2_enhanced::SimdPerformanceMonitor
pub fn numrs2::simd_optimize::avx2_enhanced::SimdPerformanceMonitor::elements_per_second(&self, duration_secs: f64) -> f64
pub fn numrs2::simd_optimize::avx2_enhanced::SimdPerformanceMonitor::new() -> Self
pub fn numrs2::simd_optimize::avx2_enhanced::SimdPerformanceMonitor::record_operation(&mut self, elements: usize, vectorized_elements: usize)
pub fn numrs2::simd_optimize::avx2_enhanced::SimdPerformanceMonitor::reset(&mut self)
impl core::default::Default for numrs2::simd_optimize::avx2_enhanced::SimdPerformanceMonitor
pub fn numrs2::simd_optimize::avx2_enhanced::SimdPerformanceMonitor::default() -> Self
pub fn numrs2::simd_optimize::avx2_enhanced::kahan_sum_f32(input: &numrs2::array::Array<f32>) -> f32
pub fn numrs2::simd_optimize::avx2_enhanced::vectorized_sin_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub mod numrs2::simd_optimize::avx2_ops
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_add_f32(a: &[f32], b: &[f32], result: &mut [f32])
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_add_f64(a: &[f64], b: &[f64], result: &mut [f64])
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_div_f32(a: &[f32], b: &[f32], result: &mut [f32])
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_div_f64(a: &[f64], b: &[f64], result: &mut [f64])
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_dot_f32(a: &[f32], b: &[f32]) -> f32
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_dot_f64(a: &[f64], b: &[f64]) -> f64
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_fma_f32(a: &[f32], b: &[f32], c: &[f32], result: &mut [f32])
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_fma_f64(a: &[f64], b: &[f64], c: &[f64], result: &mut [f64])
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_mul_f32(a: &[f32], b: &[f32], result: &mut [f32])
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_mul_f64(a: &[f64], b: &[f64], result: &mut [f64])
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_sqrt_f32(a: &[f32], result: &mut [f32])
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_sqrt_f64(a: &[f64], result: &mut [f64])
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_sum_f32(a: &[f32]) -> f32
pub unsafe fn numrs2::simd_optimize::avx2_ops::avx2_sum_f64(a: &[f64]) -> f64
pub mod numrs2::simd_optimize::feature_detect
pub struct numrs2::simd_optimize::feature_detect::CpuFeatures
pub numrs2::simd_optimize::feature_detect::CpuFeatures::avx: bool
pub numrs2::simd_optimize::feature_detect::CpuFeatures::avx2: bool
pub numrs2::simd_optimize::feature_detect::CpuFeatures::avx512f: bool
pub numrs2::simd_optimize::feature_detect::CpuFeatures::fma: bool
pub numrs2::simd_optimize::feature_detect::CpuFeatures::neon: bool
pub numrs2::simd_optimize::feature_detect::CpuFeatures::sse2: bool
pub numrs2::simd_optimize::feature_detect::CpuFeatures::sse3: bool
pub numrs2::simd_optimize::feature_detect::CpuFeatures::sse4_1: bool
pub numrs2::simd_optimize::feature_detect::CpuFeatures::sse4_2: bool
pub numrs2::simd_optimize::feature_detect::CpuFeatures::ssse3: bool
pub numrs2::simd_optimize::feature_detect::CpuFeatures::sve: bool
impl numrs2::simd_optimize::feature_detect::CpuFeatures
pub fn numrs2::simd_optimize::feature_detect::CpuFeatures::all_enabled() -> Self
pub fn numrs2::simd_optimize::feature_detect::detect_cpu_features() -> numrs2::simd_optimize::feature_detect::CpuFeatures
pub mod numrs2::simd_optimize::neon_enhanced
pub struct numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps
impl numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::neon_copy_f32(src: &numrs2::array::Array<f32>, dst: &mut numrs2::array::Array<f32>) -> numrs2::Result<()>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::neon_dot_f32(a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>) -> numrs2::Result<f32>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::neon_exp_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::neon_log_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::neon_matmul_f32(a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>, c: &mut numrs2::array::Array<f32>, _block_size: usize) -> numrs2::Result<()>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::neon_sin_cos_f32(input: &numrs2::array::Array<f32>) -> (numrs2::array::Array<f32>, numrs2::array::Array<f32>)
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::neon_sum_f32(input: &numrs2::array::Array<f32>) -> f32
impl numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_abs_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_acos_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_acosh_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_add_arrays_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_add_scalar_f64(a: &numrs2::array::Array<f64>, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_asin_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_asinh_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_atan2_f64(y: &numrs2::array::Array<f64>, x: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_atan_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_atanh_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_cbrt_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_ceil_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_clamp_f64(input: &numrs2::array::Array<f64>, min_val: f64, max_val: f64) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_copysign_f64(magnitude: &numrs2::array::Array<f64>, sign: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_cos_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_cosh_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_div_arrays_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_div_scalar_f64(a: &numrs2::array::Array<f64>, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_dot_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_exp2_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_exp_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_expm1_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_floor_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_fma_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>, c: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_hypot_f64(x: &numrs2::array::Array<f64>, y: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_log10_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_log1p_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_log2_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_log_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_max_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_maximum_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_mean_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_min_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_minimum_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_mul_arrays_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_mul_scalar_f64(a: &numrs2::array::Array<f64>, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_negative_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_norm_l1_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_norm_l2_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_pow_f64(base: &numrs2::array::Array<f64>, exp: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_pow_scalar_f64(base: &numrs2::array::Array<f64>, exp: f64) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_prod_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_reciprocal_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_round_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_sign_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_sin_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_sinh_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_sqrt_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_square_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_std_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_sub_arrays_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_sub_scalar_f64(a: &numrs2::array::Array<f64>, scalar: f64) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_sum_f64(input: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_tan_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_tanh_f64(input: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::neon_enhanced::NeonEnhancedOps::vectorized_variance_f64(input: &numrs2::array::Array<f64>) -> f64
pub struct numrs2::simd_optimize::neon_enhanced::NeonFeatureDetector
impl numrs2::simd_optimize::neon_enhanced::NeonFeatureDetector
pub fn numrs2::simd_optimize::neon_enhanced::NeonFeatureDetector::detect_neon_features() -> numrs2::simd_optimize::neon_enhanced::NeonFeatures
pub fn numrs2::simd_optimize::neon_enhanced::NeonFeatureDetector::optimal_block_size() -> usize
pub struct numrs2::simd_optimize::neon_enhanced::NeonFeatures
pub numrs2::simd_optimize::neon_enhanced::NeonFeatures::asimd: bool
pub numrs2::simd_optimize::neon_enhanced::NeonFeatures::fp: bool
pub numrs2::simd_optimize::neon_enhanced::NeonFeatures::neon: bool
impl numrs2::simd_optimize::neon_enhanced::NeonFeatures
pub fn numrs2::simd_optimize::neon_enhanced::NeonFeatures::has_full_support(&self) -> bool
pub fn numrs2::simd_optimize::neon_enhanced::NeonFeatures::recommended_operations(&self) -> alloc::vec::Vec<&'static str>
pub mod numrs2::simd_optimize::optimized
pub fn numrs2::simd_optimize::optimized::complex_multiply_f32(a_real: &numrs2::array::Array<f32>, a_imag: &numrs2::array::Array<f32>, b_real: &numrs2::array::Array<f32>, b_imag: &numrs2::array::Array<f32>) -> numrs2::Result<(numrs2::array::Array<f32>, numrs2::array::Array<f32>)>
pub fn numrs2::simd_optimize::optimized::copy_f32(src: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::optimized::dot_f32(a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>) -> numrs2::Result<f32>
pub fn numrs2::simd_optimize::optimized::exp_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::optimized::log_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::optimized::matmul_f32(a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::optimized::sin_cos_f32(input: &numrs2::array::Array<f32>) -> (numrs2::array::Array<f32>, numrs2::array::Array<f32>)
pub fn numrs2::simd_optimize::optimized::sum_f32(input: &numrs2::array::Array<f32>) -> f32
pub mod numrs2::simd_optimize::simd_select
pub enum numrs2::simd_optimize::simd_select::SimdImplementation
pub numrs2::simd_optimize::simd_select::SimdImplementation::AVX
pub numrs2::simd_optimize::simd_select::SimdImplementation::AVX2
pub numrs2::simd_optimize::simd_select::SimdImplementation::AVX512
pub numrs2::simd_optimize::simd_select::SimdImplementation::NEON
pub numrs2::simd_optimize::simd_select::SimdImplementation::SSE
pub numrs2::simd_optimize::simd_select::SimdImplementation::SVE
pub numrs2::simd_optimize::simd_select::SimdImplementation::Scalar
impl numrs2::simd_optimize::simd_select::SimdImplementation
pub fn numrs2::simd_optimize::simd_select::SimdImplementation::is_avx2_or_better(&self) -> bool
pub fn numrs2::simd_optimize::simd_select::SimdImplementation::is_neon_or_better(&self) -> bool
pub fn numrs2::simd_optimize::simd_select::SimdImplementation::name(&self) -> &'static str
pub fn numrs2::simd_optimize::simd_select::SimdImplementation::supports_fma(&self, features: &numrs2::simd_optimize::feature_detect::CpuFeatures) -> bool
pub fn numrs2::simd_optimize::simd_select::SimdImplementation::vector_width(&self) -> usize
pub fn numrs2::simd_optimize::simd_select::apply_simd_strategy<T, S, SSE, AVX, AVX2, AVX512, NEON, SVE>(features: &numrs2::simd_optimize::feature_detect::CpuFeatures, scalar: S, sse: SSE, avx: AVX, avx2: AVX2, avx512: AVX512, neon: NEON, sve: SVE) -> T where S: core::ops::function::FnOnce() -> T, SSE: core::ops::function::FnOnce() -> T, AVX: core::ops::function::FnOnce() -> T, AVX2: core::ops::function::FnOnce() -> T, AVX512: core::ops::function::FnOnce() -> T, NEON: core::ops::function::FnOnce() -> T, SVE: core::ops::function::FnOnce() -> T
pub fn numrs2::simd_optimize::simd_select::select_simd_implementation(features: &numrs2::simd_optimize::feature_detect::CpuFeatures) -> numrs2::simd_optimize::simd_select::SimdImplementation
pub mod numrs2::simd_optimize::simd_traits
pub struct numrs2::simd_optimize::simd_traits::SimdPerformanceHints
impl numrs2::simd_optimize::simd_traits::SimdPerformanceHints
pub fn numrs2::simd_optimize::simd_traits::SimdPerformanceHints::alignment_requirement() -> usize
pub fn numrs2::simd_optimize::simd_traits::SimdPerformanceHints::is_simd_friendly(size: usize) -> bool
pub fn numrs2::simd_optimize::simd_traits::SimdPerformanceHints::optimal_array_size() -> usize
pub trait numrs2::simd_optimize::simd_traits::SimdArrayOps
pub fn numrs2::simd_optimize::simd_traits::SimdArrayOps::simd_add(&self, other: &Self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::simd_traits::SimdArrayOps::simd_copy(&self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::simd_traits::SimdArrayOps::simd_dot(&self, other: &Self) -> numrs2::Result<f32>
pub fn numrs2::simd_optimize::simd_traits::SimdArrayOps::simd_exp(&self) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::simd_traits::SimdArrayOps::simd_log(&self) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::simd_traits::SimdArrayOps::simd_matmul(&self, other: &Self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::simd_traits::SimdArrayOps::simd_mul(&self, other: &Self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::simd_traits::SimdArrayOps::simd_sin_cos(&self) -> (numrs2::array::Array<f32>, numrs2::array::Array<f32>)
pub fn numrs2::simd_optimize::simd_traits::SimdArrayOps::simd_sum(&self) -> f32
impl numrs2::simd_optimize::simd_traits::SimdArrayOps for numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_add(&self, other: &Self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_copy(&self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_dot(&self, other: &Self) -> numrs2::Result<f32>
pub fn numrs2::array::Array<f32>::simd_exp(&self) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_log(&self) -> numrs2::array::Array<f32>
pub fn numrs2::array::Array<f32>::simd_matmul(&self, other: &Self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_mul(&self, other: &Self) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::array::Array<f32>::simd_sin_cos(&self) -> (numrs2::array::Array<f32>, numrs2::array::Array<f32>)
pub fn numrs2::array::Array<f32>::simd_sum(&self) -> f32
pub mod numrs2::simd_optimize::unified_dispatcher
pub mod numrs2::simd_optimize::unified_dispatcher::optimized
pub fn numrs2::simd_optimize::unified_dispatcher::optimized::complex_multiply_f32(a_real: &numrs2::array::Array<f32>, a_imag: &numrs2::array::Array<f32>, b_real: &numrs2::array::Array<f32>, b_imag: &numrs2::array::Array<f32>) -> numrs2::Result<(numrs2::array::Array<f32>, numrs2::array::Array<f32>)>
pub fn numrs2::simd_optimize::unified_dispatcher::optimized::copy_f32(src: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::unified_dispatcher::optimized::dot_f32(a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>) -> numrs2::Result<f32>
pub fn numrs2::simd_optimize::unified_dispatcher::optimized::exp_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::unified_dispatcher::optimized::log_f32(input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::unified_dispatcher::optimized::matmul_f32(a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::unified_dispatcher::optimized::sin_cos_f32(input: &numrs2::array::Array<f32>) -> (numrs2::array::Array<f32>, numrs2::array::Array<f32>)
pub fn numrs2::simd_optimize::unified_dispatcher::optimized::sum_f32(input: &numrs2::array::Array<f32>) -> f32
pub struct numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults
pub numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults::copy_throughput: f64
pub numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults::copy_time_ns: f64
pub numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults::elements: usize
pub numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults::exp_throughput: f64
pub numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults::exp_time_ns: f64
pub numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults::implementation: &'static str
pub numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults::sum_throughput: f64
pub numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults::sum_time_ns: f64
impl numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults
pub fn numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults::print_summary(&self)
pub struct numrs2::simd_optimize::unified_dispatcher::SimdImplementationInfo
pub numrs2::simd_optimize::unified_dispatcher::SimdImplementationInfo::architecture: &'static str
pub numrs2::simd_optimize::unified_dispatcher::SimdImplementationInfo::name: &'static str
pub numrs2::simd_optimize::unified_dispatcher::SimdImplementationInfo::supports_avx512: bool
pub numrs2::simd_optimize::unified_dispatcher::SimdImplementationInfo::supports_fma: bool
pub numrs2::simd_optimize::unified_dispatcher::SimdImplementationInfo::vector_width: usize
impl numrs2::simd_optimize::unified_dispatcher::SimdImplementationInfo
pub fn numrs2::simd_optimize::unified_dispatcher::SimdImplementationInfo::print_info(&self)
pub struct numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher
impl numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::benchmark_operations(&self, size: usize, iterations: usize) -> numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::implementation_info(&self) -> numrs2::simd_optimize::unified_dispatcher::SimdImplementationInfo
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::new() -> Self
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_complex_multiply_f32(&self, a_real: &numrs2::array::Array<f32>, a_imag: &numrs2::array::Array<f32>, b_real: &numrs2::array::Array<f32>, b_imag: &numrs2::array::Array<f32>) -> numrs2::Result<(numrs2::array::Array<f32>, numrs2::array::Array<f32>)>
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_copy_f32(&self, src: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_dot_f32(&self, a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>) -> numrs2::Result<f32>
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_exp_f32(&self, input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_log_f32(&self, input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_matmul_f32(&self, a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_sin_cos_f32(&self, input: &numrs2::array::Array<f32>) -> (numrs2::array::Array<f32>, numrs2::array::Array<f32>)
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_sum_f32(&self, input: &numrs2::array::Array<f32>) -> f32
impl core::default::Default for numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::default() -> Self
pub fn numrs2::simd_optimize::unified_dispatcher::global_dispatcher() -> &'static numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher
pub enum numrs2::simd_optimize::SimdImplementation
pub numrs2::simd_optimize::SimdImplementation::AVX
pub numrs2::simd_optimize::SimdImplementation::AVX2
pub numrs2::simd_optimize::SimdImplementation::AVX512
pub numrs2::simd_optimize::SimdImplementation::NEON
pub numrs2::simd_optimize::SimdImplementation::SSE
pub numrs2::simd_optimize::SimdImplementation::SVE
pub numrs2::simd_optimize::SimdImplementation::Scalar
impl numrs2::simd_optimize::simd_select::SimdImplementation
pub fn numrs2::simd_optimize::simd_select::SimdImplementation::is_avx2_or_better(&self) -> bool
pub fn numrs2::simd_optimize::simd_select::SimdImplementation::is_neon_or_better(&self) -> bool
pub fn numrs2::simd_optimize::simd_select::SimdImplementation::name(&self) -> &'static str
pub fn numrs2::simd_optimize::simd_select::SimdImplementation::supports_fma(&self, features: &numrs2::simd_optimize::feature_detect::CpuFeatures) -> bool
pub fn numrs2::simd_optimize::simd_select::SimdImplementation::vector_width(&self) -> usize
pub struct numrs2::simd_optimize::CpuFeatures
pub numrs2::simd_optimize::CpuFeatures::avx: bool
pub numrs2::simd_optimize::CpuFeatures::avx2: bool
pub numrs2::simd_optimize::CpuFeatures::avx512f: bool
pub numrs2::simd_optimize::CpuFeatures::fma: bool
pub numrs2::simd_optimize::CpuFeatures::neon: bool
pub numrs2::simd_optimize::CpuFeatures::sse2: bool
pub numrs2::simd_optimize::CpuFeatures::sse3: bool
pub numrs2::simd_optimize::CpuFeatures::sse4_1: bool
pub numrs2::simd_optimize::CpuFeatures::sse4_2: bool
pub numrs2::simd_optimize::CpuFeatures::ssse3: bool
pub numrs2::simd_optimize::CpuFeatures::sve: bool
impl numrs2::simd_optimize::feature_detect::CpuFeatures
pub fn numrs2::simd_optimize::feature_detect::CpuFeatures::all_enabled() -> Self
pub struct numrs2::simd_optimize::SimdPerformanceHints
impl numrs2::simd_optimize::simd_traits::SimdPerformanceHints
pub fn numrs2::simd_optimize::simd_traits::SimdPerformanceHints::alignment_requirement() -> usize
pub fn numrs2::simd_optimize::simd_traits::SimdPerformanceHints::is_simd_friendly(size: usize) -> bool
pub fn numrs2::simd_optimize::simd_traits::SimdPerformanceHints::optimal_array_size() -> usize
pub struct numrs2::simd_optimize::UnifiedSimdDispatcher
impl numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::benchmark_operations(&self, size: usize, iterations: usize) -> numrs2::simd_optimize::unified_dispatcher::SimdBenchmarkResults
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::implementation_info(&self) -> numrs2::simd_optimize::unified_dispatcher::SimdImplementationInfo
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::new() -> Self
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_complex_multiply_f32(&self, a_real: &numrs2::array::Array<f32>, a_imag: &numrs2::array::Array<f32>, b_real: &numrs2::array::Array<f32>, b_imag: &numrs2::array::Array<f32>) -> numrs2::Result<(numrs2::array::Array<f32>, numrs2::array::Array<f32>)>
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_copy_f32(&self, src: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_dot_f32(&self, a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>) -> numrs2::Result<f32>
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_exp_f32(&self, input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_log_f32(&self, input: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_matmul_f32(&self, a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_sin_cos_f32(&self, input: &numrs2::array::Array<f32>) -> (numrs2::array::Array<f32>, numrs2::array::Array<f32>)
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::optimized_sum_f32(&self, input: &numrs2::array::Array<f32>) -> f32
impl core::default::Default for numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher
pub fn numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher::default() -> Self
pub fn numrs2::simd_optimize::avx2_optimized_add_f32(a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::avx2_optimized_add_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::simd_optimize::avx2_optimized_mul_f32(a: &numrs2::array::Array<f32>, b: &numrs2::array::Array<f32>) -> numrs2::Result<numrs2::array::Array<f32>>
pub fn numrs2::simd_optimize::avx2_optimized_mul_f64(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::simd_optimize::avx2_optimized_sqrt_f32(a: &numrs2::array::Array<f32>) -> numrs2::array::Array<f32>
pub fn numrs2::simd_optimize::avx2_optimized_sqrt_f64(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::simd_optimize::avx2_optimized_sum_f32(a: &numrs2::array::Array<f32>) -> f32
pub fn numrs2::simd_optimize::avx2_optimized_sum_f64(a: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::simd_optimize::detect_and_select() -> numrs2::simd_optimize::simd_select::SimdImplementation
pub fn numrs2::simd_optimize::detect_cpu_features() -> numrs2::simd_optimize::feature_detect::CpuFeatures
pub fn numrs2::simd_optimize::global_dispatcher() -> &'static numrs2::simd_optimize::unified_dispatcher::UnifiedSimdDispatcher
pub fn numrs2::simd_optimize::select_simd_implementation(features: &numrs2::simd_optimize::feature_detect::CpuFeatures) -> numrs2::simd_optimize::simd_select::SimdImplementation
pub mod numrs2::sparse
pub enum numrs2::sparse::SparseMatrixFormat
pub numrs2::sparse::SparseMatrixFormat::COO
pub numrs2::sparse::SparseMatrixFormat::CSC
pub numrs2::sparse::SparseMatrixFormat::CSR
pub numrs2::sparse::SparseMatrixFormat::DIA
pub struct numrs2::sparse::SparseArray<T>
pub numrs2::sparse::SparseArray::data: std::collections::hash::map::HashMap<alloc::vec::Vec<usize>, T>
pub numrs2::sparse::SparseArray::shape: alloc::vec::Vec<usize>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Add<Output = T>
pub fn numrs2::sparse::SparseArray<T>::add(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Div<Output = T>
pub fn numrs2::sparse::SparseArray<T>::divide(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
pub fn numrs2::sparse::SparseArray<T>::divide_scalar(&self, scalar: T) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Mul<Output = T>
pub fn numrs2::sparse::SparseArray<T>::multiply(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
pub fn numrs2::sparse::SparseArray<T>::multiply_scalar(&self, scalar: T) -> numrs2::sparse::SparseArray<T>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Sub<Output = T>
pub fn numrs2::sparse::SparseArray<T>::subtract(&self, other: &numrs2::sparse::SparseArray<T>) -> numrs2::Result<numrs2::sparse::SparseArray<T>>
impl<T> numrs2::sparse::SparseArray<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero
pub fn numrs2::sparse::SparseArray<T>::density(&self) -> f64
pub fn numrs2::sparse::SparseArray<T>::from_array(array: &numrs2::array::Array<T>) -> Self
pub fn numrs2::sparse::SparseArray<T>::get(&self, indices: &[usize]) -> numrs2::Result<T>
pub fn numrs2::sparse::SparseArray<T>::ndim(&self) -> usize
pub fn numrs2::sparse::SparseArray<T>::new(shape: &[usize]) -> Self
pub fn numrs2::sparse::SparseArray<T>::nnz(&self) -> usize
pub fn numrs2::sparse::SparseArray<T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseArray<T>::shape(&self) -> &[usize]
pub fn numrs2::sparse::SparseArray<T>::to_array(&self) -> numrs2::array::Array<T>
pub struct numrs2::sparse::SparseMatrix<T>
pub numrs2::sparse::SparseMatrix::array: numrs2::sparse::SparseArray<T>
pub numrs2::sparse::SparseMatrix::diag_offsets: core::option::Option<alloc::vec::Vec<isize>>
pub numrs2::sparse::SparseMatrix::format: numrs2::sparse::SparseMatrixFormat
pub numrs2::sparse::SparseMatrix::indices: core::option::Option<alloc::vec::Vec<usize>>
pub numrs2::sparse::SparseMatrix::indptr: core::option::Option<alloc::vec::Vec<usize>>
impl<T> numrs2::sparse::SparseMatrix<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::fmt::Debug
pub fn numrs2::sparse::SparseMatrix<T>::density(&self) -> f64
pub fn numrs2::sparse::SparseMatrix<T>::diag(diagonal: &[T]) -> numrs2::Result<Self>
pub fn numrs2::sparse::SparseMatrix<T>::eye(n: usize) -> numrs2::Result<Self> where T: num_traits::identities::One
pub fn numrs2::sparse::SparseMatrix<T>::from_array(array: &numrs2::array::Array<T>) -> numrs2::Result<Self>
pub fn numrs2::sparse::SparseMatrix<T>::get(&self, row: usize, col: usize) -> numrs2::Result<T>
pub fn numrs2::sparse::SparseMatrix<T>::new(shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::sparse::SparseMatrix<T>::nnz(&self) -> usize
pub fn numrs2::sparse::SparseMatrix<T>::set(&mut self, row: usize, col: usize, value: T) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseMatrix<T>::shape(&self) -> &[usize]
pub fn numrs2::sparse::SparseMatrix<T>::to_array(&self) -> numrs2::array::Array<T>
pub fn numrs2::sparse::SparseMatrix<T>::to_csc(&mut self) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseMatrix<T>::to_csr(&mut self) -> numrs2::Result<()>
pub fn numrs2::sparse::SparseMatrix<T>::to_dia(&mut self) -> numrs2::Result<()>
impl<T> numrs2::sparse::SparseMatrix<T> where T: core::clone::Clone + core::cmp::PartialEq + num_traits::identities::Zero + core::ops::arith::Add<Output = T> + core::ops::arith::Mul<Output = T> + core::fmt::Debug
pub fn numrs2::sparse::SparseMatrix<T>::matmul(&self, other: &numrs2::sparse::SparseMatrix<T>) -> numrs2::Result<numrs2::sparse::SparseMatrix<T>>
pub fn numrs2::sparse::SparseMatrix<T>::transpose(&self) -> numrs2::Result<numrs2::sparse::SparseMatrix<T>>
pub struct numrs2::sparse::SparseOpsAdvanced
impl numrs2::sparse_enhanced::SparseOpsAdvanced
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::condition_number_estimate<T>(a: &numrs2::sparse::SparseMatrix<T>, max_iter: usize, tol: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::incomplete_lu<T>(a: &numrs2::sparse::SparseMatrix<T>, _fill_factor: f64) -> numrs2::Result<(numrs2::sparse::SparseMatrix<T>, numrs2::sparse::SparseMatrix<T>)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::solve_bicgstab<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: T, max_iter: usize) -> numrs2::Result<(numrs2::array::Array<T>, usize, T)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::solve_cg<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: T, max_iter: usize) -> numrs2::Result<(numrs2::array::Array<T>, usize, T)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::solve_gmres<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: T, max_iter: usize, restart: usize) -> numrs2::Result<(numrs2::array::Array<T>, usize, T)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::spgemm<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::sparse::SparseMatrix<T>) -> numrs2::Result<numrs2::sparse::SparseMatrix<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::spmv_dense<T>(a: &numrs2::sparse::SparseMatrix<T>, x: &numrs2::array::Array<T>, y: &mut numrs2::array::Array<T>, alpha: T, beta: T) -> numrs2::Result<()> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub mod numrs2::sparse_enhanced
pub struct numrs2::sparse_enhanced::SparseOpsAdvanced
impl numrs2::sparse_enhanced::SparseOpsAdvanced
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::condition_number_estimate<T>(a: &numrs2::sparse::SparseMatrix<T>, max_iter: usize, tol: T) -> numrs2::Result<T> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::incomplete_lu<T>(a: &numrs2::sparse::SparseMatrix<T>, _fill_factor: f64) -> numrs2::Result<(numrs2::sparse::SparseMatrix<T>, numrs2::sparse::SparseMatrix<T>)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::solve_bicgstab<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: T, max_iter: usize) -> numrs2::Result<(numrs2::array::Array<T>, usize, T)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::solve_cg<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: T, max_iter: usize) -> numrs2::Result<(numrs2::array::Array<T>, usize, T)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::solve_gmres<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::array::Array<T>, x0: core::option::Option<&numrs2::array::Array<T>>, tol: T, max_iter: usize, restart: usize) -> numrs2::Result<(numrs2::array::Array<T>, usize, T)> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::spgemm<T>(a: &numrs2::sparse::SparseMatrix<T>, b: &numrs2::sparse::SparseMatrix<T>) -> numrs2::Result<numrs2::sparse::SparseMatrix<T>> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug + num_traits::identities::Zero + num_traits::identities::One
pub fn numrs2::sparse_enhanced::SparseOpsAdvanced::spmv_dense<T>(a: &numrs2::sparse::SparseMatrix<T>, x: &numrs2::array::Array<T>, y: &mut numrs2::array::Array<T>, alpha: T, beta: T) -> numrs2::Result<()> where T: num_traits::float::Float + core::clone::Clone + core::fmt::Debug
pub mod numrs2::spatial
pub use numrs2::spatial::<<scirs2_spatial::*>>
pub mod numrs2::special
pub use numrs2::special::<<scirs2_special::*>>
pub mod numrs2::stats
pub enum numrs2::stats::BinSpec
pub numrs2::stats::BinSpec::Auto
pub numrs2::stats::BinSpec::Count(usize)
pub numrs2::stats::BinSpec::Doane
pub numrs2::stats::BinSpec::Fd
pub numrs2::stats::BinSpec::Rice
pub numrs2::stats::BinSpec::Scott
pub numrs2::stats::BinSpec::Sqrt
pub numrs2::stats::BinSpec::Sturges
impl core::convert::From<&str> for numrs2::stats::BinSpec
pub fn numrs2::stats::BinSpec::from(s: &str) -> Self
impl core::convert::From<usize> for numrs2::stats::BinSpec
pub fn numrs2::stats::BinSpec::from(n: usize) -> Self
pub enum numrs2::stats::HistBins
pub numrs2::stats::HistBins::Single(usize)
pub numrs2::stats::HistBins::Tuple(usize, usize)
impl core::convert::From<(usize, usize)> for numrs2::stats::HistBins
pub fn numrs2::stats::HistBins::from(val: (usize, usize)) -> Self
impl core::convert::From<usize> for numrs2::stats::HistBins
pub fn numrs2::stats::HistBins::from(val: usize) -> Self
pub trait numrs2::stats::Statistics<T>
pub fn numrs2::stats::Statistics::max(&self) -> T
pub fn numrs2::stats::Statistics::mean(&self) -> T
pub fn numrs2::stats::Statistics::min(&self) -> T
pub fn numrs2::stats::Statistics::percentile(&self, q: T) -> T
pub fn numrs2::stats::Statistics::std(&self) -> T
pub fn numrs2::stats::Statistics::var(&self) -> T
impl<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync + 'static> numrs2::stats::Statistics<T> for numrs2::array::Array<T>
pub fn numrs2::array::Array<T>::max(&self) -> T
pub fn numrs2::array::Array<T>::mean(&self) -> T
pub fn numrs2::array::Array<T>::min(&self) -> T
pub fn numrs2::array::Array<T>::percentile(&self, q: T) -> T
pub fn numrs2::array::Array<T>::std(&self) -> T
pub fn numrs2::array::Array<T>::var(&self) -> T
pub fn numrs2::stats::average<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, weights: core::option::Option<&numrs2::array::Array<T>>, axis: core::option::Option<usize>, returned: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::bincount<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, weights: core::option::Option<&numrs2::array::Array<T>>, minlength: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::corrcoef<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(x: &numrs2::array::Array<T>, y: core::option::Option<&numrs2::array::Array<T>>, rowvar: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::cov<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(x: &numrs2::array::Array<T>, y: core::option::Option<&numrs2::array::Array<T>>, rowvar: core::option::Option<bool>, bias: core::option::Option<bool>, ddof: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::digitize<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::marker::Send + core::marker::Sync>(x: &numrs2::array::Array<T>, bins: &numrs2::array::Array<T>, right: core::option::Option<bool>) -> numrs2::Result<numrs2::array::Array<usize>>
pub fn numrs2::stats::histogram<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync + 'static>(a: &numrs2::array::Array<T>, bins: usize, range: core::option::Option<(T, T)>, weights: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>)>
pub fn numrs2::stats::histogram2d<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(x: &numrs2::array::Array<T>, y: &numrs2::array::Array<T>, bins: impl core::convert::Into<numrs2::stats::HistBins>, range: core::option::Option<((T, T), (T, T))>, weights: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>, numrs2::array::Array<T>)>
pub fn numrs2::stats::histogram_bin_edges<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, bins: impl core::convert::Into<numrs2::stats::BinSpec>, range: core::option::Option<(T, T)>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::histogram_dd<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Display>(sample: &numrs2::array::Array<T>, bins: &[usize], range: core::option::Option<alloc::vec::Vec<(T, T)>>, weights: core::option::Option<&numrs2::array::Array<T>>) -> numrs2::Result<(numrs2::array::Array<T>, alloc::vec::Vec<numrs2::array::Array<T>>)>
pub fn numrs2::stats::max_along_axis<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::default::Default + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::min_along_axis<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::default::Default + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, axis: usize) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::mode<T>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, nan_policy: core::option::Option<&str>) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<T>)> where T: num_traits::float::Float + core::clone::Clone + core::cmp::PartialOrd + core::fmt::Display + num_traits::cast::NumCast
pub fn numrs2::stats::nanmax<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::nanmean<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::nanmin<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::nanprod<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::nanstd<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, ddof: core::option::Option<usize>, _keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::nansum<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::nanvar<T: num_traits::float::Float + core::clone::Clone + num_traits::identities::Zero + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(array: &numrs2::array::Array<T>, axis: core::option::Option<usize>, ddof: core::option::Option<usize>, keepdims: bool) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::percentile<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, q: &numrs2::array::Array<T>, method: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::ptp<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::default::Default + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, axis: core::option::Option<usize>) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::stats::quantile<T: num_traits::float::Float + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Display + core::marker::Send + core::marker::Sync>(a: &numrs2::array::Array<T>, q: &numrs2::array::Array<T>, method: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<T>>
pub mod numrs2::stride_tricks
pub fn numrs2::stride_tricks::as_strided<T>(array: &numrs2::array::Array<T>, shape: &[usize], strides: &[isize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug
pub fn numrs2::stride_tricks::broadcast_arrays<T>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>> where T: core::clone::Clone + core::fmt::Debug
pub fn numrs2::stride_tricks::broadcast_to<T>(array: &numrs2::array::Array<T>, shape: &[usize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug
pub fn numrs2::stride_tricks::byte_strides<T>(array: &numrs2::array::Array<T>) -> alloc::vec::Vec<usize> where T: core::clone::Clone + core::fmt::Debug
pub fn numrs2::stride_tricks::set_strides<T>(array: &numrs2::array::Array<T>, strides: &[isize]) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug
pub fn numrs2::stride_tricks::sliding_window_view<T>(array: &numrs2::array::Array<T>, window_shape: &[usize], step: core::option::Option<&[usize]>) -> numrs2::Result<numrs2::array::Array<T>> where T: core::clone::Clone + core::fmt::Debug
pub mod numrs2::testing
pub mod numrs2::testing::tolerances
pub fn numrs2::testing::tolerances::default() -> numrs2::testing::ToleranceConfig
pub fn numrs2::testing::tolerances::loose() -> numrs2::testing::ToleranceConfig
pub fn numrs2::testing::tolerances::relaxed() -> numrs2::testing::ToleranceConfig
pub fn numrs2::testing::tolerances::strict() -> numrs2::testing::ToleranceConfig
pub fn numrs2::testing::tolerances::with_nan() -> numrs2::testing::ToleranceConfig
pub struct numrs2::testing::TestResult
pub numrs2::testing::TestResult::max_abs_diff: core::option::Option<f64>
pub numrs2::testing::TestResult::max_rel_diff: core::option::Option<f64>
pub numrs2::testing::TestResult::message: alloc::string::String
pub numrs2::testing::TestResult::mismatch_count: usize
pub numrs2::testing::TestResult::passed: bool
impl numrs2::testing::TestResult
pub fn numrs2::testing::TestResult::comparison_result(passed: bool, message: &str, max_abs_diff: f64, max_rel_diff: f64, mismatch_count: usize) -> Self
pub fn numrs2::testing::TestResult::failure(message: &str) -> Self
pub fn numrs2::testing::TestResult::success(message: &str) -> Self
pub struct numrs2::testing::ToleranceConfig
pub numrs2::testing::ToleranceConfig::atol: f64
pub numrs2::testing::ToleranceConfig::equal_nan: bool
pub numrs2::testing::ToleranceConfig::rtol: f64
impl core::default::Default for numrs2::testing::ToleranceConfig
pub fn numrs2::testing::ToleranceConfig::default() -> Self
pub fn numrs2::testing::arrays_close<T>(actual: &numrs2::array::Array<T>, desired: &numrs2::array::Array<T>, rtol: f64, atol: f64) -> bool where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::testing::assert_array_all_finite<T>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::testing::TestResult> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::testing::assert_array_almost_equal<T>(actual: &numrs2::array::Array<T>, desired: &numrs2::array::Array<T>, config: &numrs2::testing::ToleranceConfig) -> numrs2::Result<numrs2::testing::TestResult> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::testing::assert_array_equal<T>(actual: &numrs2::array::Array<T>, desired: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::testing::TestResult> where T: core::cmp::PartialEq + core::fmt::Debug + core::clone::Clone
pub fn numrs2::testing::assert_array_no_nan<T>(array: &numrs2::array::Array<T>) -> numrs2::Result<numrs2::testing::TestResult> where T: num_traits::float::Float + core::fmt::Debug + core::clone::Clone
pub fn numrs2::testing::assert_array_same_shape<T, U>(actual: &numrs2::array::Array<T>, desired: &numrs2::array::Array<U>) -> numrs2::Result<numrs2::testing::TestResult> where T: core::clone::Clone, U: core::clone::Clone
pub fn numrs2::testing::assert_scalar_almost_equal<T>(actual: T, desired: T, config: &numrs2::testing::ToleranceConfig) -> numrs2::Result<numrs2::testing::TestResult> where T: num_traits::float::Float + core::fmt::Debug
pub fn numrs2::testing::count_nonzero<T>(array: &numrs2::array::Array<T>) -> usize where T: num_traits::identities::Zero + core::cmp::PartialEq + core::clone::Clone
pub fn numrs2::testing::is_finite_array<T>(array: &numrs2::array::Array<T>) -> bool where T: num_traits::float::Float
pub fn numrs2::testing::test_summary(results: &[numrs2::testing::TestResult]) -> alloc::string::String
pub mod numrs2::traits
pub enum numrs2::traits::AllocationFrequency
pub numrs2::traits::AllocationFrequency::High
pub numrs2::traits::AllocationFrequency::Low
pub numrs2::traits::AllocationFrequency::Medium
pub numrs2::traits::AllocationFrequency::VeryHigh
pub enum numrs2::traits::AllocationLifetime
pub numrs2::traits::AllocationLifetime::LongTerm
pub numrs2::traits::AllocationLifetime::MediumTerm
pub numrs2::traits::AllocationLifetime::Permanent
pub numrs2::traits::AllocationLifetime::ShortTerm
pub numrs2::traits::AllocationLifetime::Temporary
pub enum numrs2::traits::OptimizationType
pub numrs2::traits::OptimizationType::AlignmentOptimization
pub numrs2::traits::OptimizationType::AllocationCoalescing
pub numrs2::traits::OptimizationType::AllocatorSwitch
pub numrs2::traits::OptimizationType::ArenaOptimization
pub numrs2::traits::OptimizationType::DefragmentationCompaction
pub numrs2::traits::OptimizationType::PoolingOptimization
pub enum numrs2::traits::ThreadingRequirements
pub numrs2::traits::ThreadingRequirements::LockFree
pub numrs2::traits::ThreadingRequirements::MultiThreadedRead
pub numrs2::traits::ThreadingRequirements::MultiThreadedReadWrite
pub numrs2::traits::ThreadingRequirements::SingleThreaded
pub struct numrs2::traits::AllocationRequirements
pub numrs2::traits::AllocationRequirements::alignment: usize
pub numrs2::traits::AllocationRequirements::frequency: numrs2::traits::AllocationFrequency
pub numrs2::traits::AllocationRequirements::lifetime: numrs2::traits::AllocationLifetime
pub numrs2::traits::AllocationRequirements::simd_usage: bool
pub numrs2::traits::AllocationRequirements::size: usize
pub numrs2::traits::AllocationRequirements::threading: numrs2::traits::ThreadingRequirements
impl numrs2::traits::AllocationRequirements
pub fn numrs2::traits::AllocationRequirements::for_array<T>(len: usize) -> Self
pub fn numrs2::traits::AllocationRequirements::for_simd_operation<T>(len: usize, alignment: usize) -> Self
pub fn numrs2::traits::AllocationRequirements::for_temporary_buffer(size: usize) -> Self
pub struct numrs2::traits::AllocationStats
pub numrs2::traits::AllocationStats::active_allocations: usize
pub numrs2::traits::AllocationStats::allocation_count: usize
pub numrs2::traits::AllocationStats::bytes_allocated: usize
pub numrs2::traits::AllocationStats::bytes_deallocated: usize
pub numrs2::traits::AllocationStats::deallocation_count: usize
pub numrs2::traits::AllocationStats::peak_usage: usize
pub struct numrs2::traits::MemoryOptimization
pub numrs2::traits::MemoryOptimization::complexity: u8
pub numrs2::traits::MemoryOptimization::description: alloc::string::String
pub numrs2::traits::MemoryOptimization::estimated_savings: usize
pub numrs2::traits::MemoryOptimization::optimization_type: numrs2::traits::OptimizationType
pub struct numrs2::traits::MemoryUsage
pub numrs2::traits::MemoryUsage::allocation_count: usize
pub numrs2::traits::MemoryUsage::efficiency: f64
pub numrs2::traits::MemoryUsage::fragmentation: f64
pub numrs2::traits::MemoryUsage::total_bytes: usize
pub struct numrs2::traits::StrategyStats
pub numrs2::traits::StrategyStats::allocator_selections: std::collections::hash::map::HashMap<alloc::string::String, usize>
pub numrs2::traits::StrategyStats::strategy_switches: usize
pub numrs2::traits::StrategyStats::total_requests: usize
pub trait numrs2::traits::AllocationStrategy: core::marker::Send + core::marker::Sync + core::fmt::Debug
pub fn numrs2::traits::AllocationStrategy::select_allocator(&self, requirements: &numrs2::traits::AllocationRequirements) -> alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>
pub fn numrs2::traits::AllocationStrategy::strategy_stats(&self) -> numrs2::traits::StrategyStats
impl numrs2::traits::AllocationStrategy for numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::select_allocator(&self, requirements: &numrs2::traits::AllocationRequirements) -> alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>
pub fn numrs2::memory_alloc::enhanced_traits::IntelligentAllocationStrategy::strategy_stats(&self) -> numrs2::traits::StrategyStats
impl<A> numrs2::traits::AllocationStrategy for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error> + numrs2::traits::AllocationStrategy
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::select_allocator(&self, _requirements: &numrs2::traits::AllocationRequirements) -> alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::strategy_stats(&self) -> numrs2::traits::StrategyStats
pub trait numrs2::traits::ArrayAllocator
pub type numrs2::traits::ArrayAllocator::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::traits::ArrayAllocator::allocate_array<T>(&self, len: usize) -> core::result::Result<core::ptr::non_null::NonNull<T>, Self::Error>
pub fn numrs2::traits::ArrayAllocator::allocate_cache_aligned<T>(&self, len: usize) -> core::result::Result<core::ptr::non_null::NonNull<T>, Self::Error>
pub fn numrs2::traits::ArrayAllocator::allocate_simd_aligned<T>(&self, len: usize, alignment: usize) -> core::result::Result<core::ptr::non_null::NonNull<T>, Self::Error>
impl numrs2::traits::ArrayAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub type numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate_array<T>(&self, len: usize) -> core::result::Result<core::ptr::non_null::NonNull<T>, Self::Error>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate_simd_aligned<T>(&self, len: usize, alignment: usize) -> core::result::Result<core::ptr::non_null::NonNull<T>, Self::Error>
pub trait numrs2::traits::ArrayIndexing<T: numrs2::traits::NumericElement>
pub type numrs2::traits::ArrayIndexing::Error: core::error::Error
pub type numrs2::traits::ArrayIndexing::IndexResult
pub fn numrs2::traits::ArrayIndexing::bool_index(&self, mask: &[bool]) -> numrs2::Result<Self::IndexResult>
pub fn numrs2::traits::ArrayIndexing::fancy_index(&self, indices: &[&[usize]]) -> numrs2::Result<Self::IndexResult>
pub fn numrs2::traits::ArrayIndexing::get(&self, indices: &[usize]) -> numrs2::Result<T>
pub fn numrs2::traits::ArrayIndexing::index(&self, specs: &[numrs2::indexing::IndexSpec]) -> numrs2::Result<Self::IndexResult>
pub fn numrs2::traits::ArrayIndexing::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()>
pub fn numrs2::traits::ArrayIndexing::slice(&self, axis: usize, start: usize, end: core::option::Option<usize>) -> numrs2::Result<Self::IndexResult>
pub trait numrs2::traits::ArrayMath<T: numrs2::traits::NumericElement>: numrs2::traits::ArrayOps<T>
pub fn numrs2::traits::ArrayMath::abs(&self) -> Self::Output where T: num_traits::sign::Signed
pub fn numrs2::traits::ArrayMath::cos(&self) -> Self::Output where T: numrs2::traits::FloatingPoint
pub fn numrs2::traits::ArrayMath::exp(&self) -> Self::Output where T: numrs2::traits::FloatingPoint
pub fn numrs2::traits::ArrayMath::ln(&self) -> Self::Output where T: numrs2::traits::FloatingPoint
pub fn numrs2::traits::ArrayMath::pow(&self, exponent: T) -> Self::Output where T: numrs2::traits::FloatingPoint
pub fn numrs2::traits::ArrayMath::pow_array(&self, exponents: &Self) -> numrs2::Result<Self::Output> where T: numrs2::traits::FloatingPoint
pub fn numrs2::traits::ArrayMath::sin(&self) -> Self::Output where T: numrs2::traits::FloatingPoint
pub fn numrs2::traits::ArrayMath::sqrt(&self) -> Self::Output where T: numrs2::traits::FloatingPoint
pub fn numrs2::traits::ArrayMath::tan(&self) -> Self::Output where T: numrs2::traits::FloatingPoint
pub trait numrs2::traits::ArrayOps<T: numrs2::traits::NumericElement>
pub type numrs2::traits::ArrayOps::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub type numrs2::traits::ArrayOps::Output: numrs2::traits::ArrayOps<T>
pub fn numrs2::traits::ArrayOps::add(&self, other: &Self) -> numrs2::Result<Self::Output>
pub fn numrs2::traits::ArrayOps::add_broadcast(&self, other: &Self) -> numrs2::Result<Self::Output>
pub fn numrs2::traits::ArrayOps::add_scalar(&self, scalar: T) -> Self::Output
pub fn numrs2::traits::ArrayOps::div(&self, other: &Self) -> numrs2::Result<Self::Output>
pub fn numrs2::traits::ArrayOps::div_scalar(&self, scalar: T) -> numrs2::Result<Self::Output>
pub fn numrs2::traits::ArrayOps::mul(&self, other: &Self) -> numrs2::Result<Self::Output>
pub fn numrs2::traits::ArrayOps::mul_broadcast(&self, other: &Self) -> numrs2::Result<Self::Output>
pub fn numrs2::traits::ArrayOps::mul_scalar(&self, scalar: T) -> Self::Output
pub fn numrs2::traits::ArrayOps::sub(&self, other: &Self) -> numrs2::Result<Self::Output>
pub trait numrs2::traits::ArrayReduction<T: numrs2::traits::NumericElement>: core::marker::Sized
pub type numrs2::traits::ArrayReduction::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::traits::ArrayReduction::argmax(&self) -> usize where T: core::cmp::PartialOrd
pub fn numrs2::traits::ArrayReduction::argmin(&self) -> usize where T: core::cmp::PartialOrd
pub fn numrs2::traits::ArrayReduction::max(&self) -> T where T: core::cmp::PartialOrd
pub fn numrs2::traits::ArrayReduction::mean(&self) -> T where T: core::ops::arith::Div<Output = T> + core::convert::From<usize>
pub fn numrs2::traits::ArrayReduction::mean_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<Self>
pub fn numrs2::traits::ArrayReduction::min(&self) -> T where T: core::cmp::PartialOrd
pub fn numrs2::traits::ArrayReduction::std(&self) -> T where T: numrs2::traits::FloatingPoint
pub fn numrs2::traits::ArrayReduction::std_axis(&self, axis: core::option::Option<usize>) -> numrs2::Result<Self>
pub fn numrs2::traits::ArrayReduction::sum(&self) -> T
pub fn numrs2::traits::ArrayReduction::sum_axis(&self, axis: usize) -> numrs2::Result<Self>
pub trait numrs2::traits::ComplexElement: numrs2::traits::NumericElement
pub type numrs2::traits::ComplexElement::Real: numrs2::traits::FloatingPoint
pub fn numrs2::traits::ComplexElement::conj(&self) -> Self
pub fn numrs2::traits::ComplexElement::imag(&self) -> Self::Real
pub fn numrs2::traits::ComplexElement::magnitude(&self) -> Self::Real
pub fn numrs2::traits::ComplexElement::new(real: Self::Real, imag: Self::Real) -> Self
pub fn numrs2::traits::ComplexElement::phase(&self) -> Self::Real
pub fn numrs2::traits::ComplexElement::real(&self) -> Self::Real
impl<T: numrs2::traits::FloatingPoint> numrs2::traits::ComplexElement for num_complex::Complex<T>
pub type num_complex::Complex<T>::Real = T
pub fn num_complex::Complex<T>::conj(&self) -> Self
pub fn num_complex::Complex<T>::imag(&self) -> Self::Real
pub fn num_complex::Complex<T>::magnitude(&self) -> Self::Real
pub fn num_complex::Complex<T>::new(real: Self::Real, imag: Self::Real) -> Self
pub fn num_complex::Complex<T>::phase(&self) -> Self::Real
pub fn num_complex::Complex<T>::real(&self) -> Self::Real
pub trait numrs2::traits::FloatingPoint: numrs2::traits::NumericElement + num_traits::float::Float
pub fn numrs2::traits::FloatingPoint::epsilon() -> Self
pub fn numrs2::traits::FloatingPoint::infinity() -> Self
pub fn numrs2::traits::FloatingPoint::is_finite(&self) -> bool
pub fn numrs2::traits::FloatingPoint::is_nan(&self) -> bool
pub fn numrs2::traits::FloatingPoint::nan() -> Self
pub fn numrs2::traits::FloatingPoint::neg_infinity() -> Self
impl numrs2::traits::FloatingPoint for f32
pub fn f32::epsilon() -> Self
pub fn f32::infinity() -> Self
pub fn f32::is_finite(&self) -> bool
pub fn f32::is_nan(&self) -> bool
pub fn f32::nan() -> Self
pub fn f32::neg_infinity() -> Self
impl numrs2::traits::FloatingPoint for f64
pub fn f64::epsilon() -> Self
pub fn f64::infinity() -> Self
pub fn f64::is_finite(&self) -> bool
pub fn f64::is_nan(&self) -> bool
pub fn f64::nan() -> Self
pub fn f64::neg_infinity() -> Self
pub trait numrs2::traits::IntegerElement: numrs2::traits::NumericElement + num_traits::int::PrimInt
pub fn numrs2::traits::IntegerElement::max_value() -> Self
pub fn numrs2::traits::IntegerElement::min_value() -> Self
pub fn numrs2::traits::IntegerElement::saturating_add(&self, other: &Self) -> Self
pub fn numrs2::traits::IntegerElement::saturating_mul(&self, other: &Self) -> Self
impl numrs2::traits::IntegerElement for i32
pub fn i32::max_value() -> Self
pub fn i32::min_value() -> Self
pub fn i32::saturating_add(&self, other: &Self) -> Self
pub fn i32::saturating_mul(&self, other: &Self) -> Self
impl numrs2::traits::IntegerElement for i64
pub fn i64::max_value() -> Self
pub fn i64::min_value() -> Self
pub fn i64::saturating_add(&self, other: &Self) -> Self
pub fn i64::saturating_mul(&self, other: &Self) -> Self
pub trait numrs2::traits::LinearAlgebra<T: numrs2::traits::FloatingPoint>: core::marker::Sized
pub type numrs2::traits::LinearAlgebra::Error: core::error::Error
pub fn numrs2::traits::LinearAlgebra::cond(&self) -> numrs2::Result<T>
pub fn numrs2::traits::LinearAlgebra::det(&self) -> numrs2::Result<T>
pub fn numrs2::traits::LinearAlgebra::inv(&self) -> numrs2::Result<Self>
pub fn numrs2::traits::LinearAlgebra::matmul(&self, other: &Self) -> numrs2::Result<Self>
pub fn numrs2::traits::LinearAlgebra::norm(&self, ord: core::option::Option<T>) -> numrs2::Result<T>
pub fn numrs2::traits::LinearAlgebra::rank(&self) -> numrs2::Result<usize>
pub fn numrs2::traits::LinearAlgebra::solve(&self, b: &Self) -> numrs2::Result<Self>
pub fn numrs2::traits::LinearAlgebra::transpose(&self) -> Self
pub trait numrs2::traits::MatrixDecomposition<T: numrs2::traits::FloatingPoint>: core::marker::Sized
pub type numrs2::traits::MatrixDecomposition::DecompositionResult
pub type numrs2::traits::MatrixDecomposition::Error: core::error::Error
pub fn numrs2::traits::MatrixDecomposition::cholesky(&self) -> numrs2::Result<Self>
pub fn numrs2::traits::MatrixDecomposition::eig(&self) -> numrs2::Result<Self::DecompositionResult>
pub fn numrs2::traits::MatrixDecomposition::lu(&self) -> numrs2::Result<Self::DecompositionResult>
pub fn numrs2::traits::MatrixDecomposition::qr(&self) -> numrs2::Result<Self::DecompositionResult>
pub fn numrs2::traits::MatrixDecomposition::schur(&self) -> numrs2::Result<Self::DecompositionResult>
pub fn numrs2::traits::MatrixDecomposition::svd(&self) -> numrs2::Result<Self::DecompositionResult>
pub trait numrs2::traits::MemoryAllocator: core::marker::Send + core::marker::Sync + core::fmt::Debug
pub type numrs2::traits::MemoryAllocator::Error: core::error::Error + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::traits::MemoryAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::traits::MemoryAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::traits::MemoryAllocator::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::traits::MemoryAllocator::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::traits::MemoryAllocator::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::traits::MemoryAllocator::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl numrs2::traits::MemoryAllocator for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub type numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl numrs2::traits::MemoryAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub type numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl<A> numrs2::traits::MemoryAllocator for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
pub type numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl<A> numrs2::traits::MemoryAllocator for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub type numrs2::parallel::parallel_allocator::ParallelAllocator<A>::Error = numrs2::NumRs2Error
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::supports_layout(&self, layout: core::alloc::layout::Layout) -> bool
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::traits::MemoryAllocator for numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub type numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::Error = numrs2::NumRs2Error
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::allocate(&self, layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub unsafe fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::deallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, layout: core::alloc::layout::Layout) -> numrs2::Result<()>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::preferred_alignment(&self) -> usize
pub unsafe fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::reallocate(&self, ptr: core::ptr::non_null::NonNull<u8>, old_layout: core::alloc::layout::Layout, new_layout: core::alloc::layout::Layout) -> numrs2::Result<core::ptr::non_null::NonNull<u8>>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::statistics(&self) -> core::option::Option<numrs2::traits::AllocationStats>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::supports_layout(&self, _layout: core::alloc::layout::Layout) -> bool
pub trait numrs2::traits::MemoryAware
pub fn numrs2::traits::MemoryAware::memory_usage(&self) -> numrs2::traits::MemoryUsage
pub fn numrs2::traits::MemoryAware::optimize_memory_layout(&mut self) -> numrs2::Result<()>
pub fn numrs2::traits::MemoryAware::set_allocator(&mut self, allocator: alloc::boxed::Box<dyn numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>>)
pub fn numrs2::traits::MemoryAware::suggest_optimizations(&self) -> alloc::vec::Vec<numrs2::traits::MemoryOptimization>
pub trait numrs2::traits::NumericElement: core::clone::Clone + core::marker::Send + core::marker::Sync + core::fmt::Debug + 'static
pub fn numrs2::traits::NumericElement::from_f64(val: f64) -> core::option::Option<Self>
pub fn numrs2::traits::NumericElement::is_zero(&self) -> bool
pub fn numrs2::traits::NumericElement::one() -> Self
pub fn numrs2::traits::NumericElement::to_f64(&self) -> core::option::Option<f64>
pub fn numrs2::traits::NumericElement::zero() -> Self
impl numrs2::traits::NumericElement for f32
pub fn f32::from_f64(val: f64) -> core::option::Option<Self>
pub fn f32::is_zero(&self) -> bool
pub fn f32::one() -> Self
pub fn f32::to_f64(&self) -> core::option::Option<f64>
pub fn f32::zero() -> Self
impl numrs2::traits::NumericElement for f64
pub fn f64::from_f64(val: f64) -> core::option::Option<Self>
pub fn f64::is_zero(&self) -> bool
pub fn f64::one() -> Self
pub fn f64::to_f64(&self) -> core::option::Option<f64>
pub fn f64::zero() -> Self
impl numrs2::traits::NumericElement for i32
pub fn i32::from_f64(val: f64) -> core::option::Option<Self>
pub fn i32::is_zero(&self) -> bool
pub fn i32::one() -> Self
pub fn i32::to_f64(&self) -> core::option::Option<f64>
pub fn i32::zero() -> Self
impl numrs2::traits::NumericElement for i64
pub fn i64::from_f64(val: f64) -> core::option::Option<Self>
pub fn i64::is_zero(&self) -> bool
pub fn i64::one() -> Self
pub fn i64::to_f64(&self) -> core::option::Option<f64>
pub fn i64::zero() -> Self
impl<T: numrs2::traits::FloatingPoint> numrs2::traits::NumericElement for num_complex::Complex<T>
pub fn num_complex::Complex<T>::from_f64(val: f64) -> core::option::Option<Self>
pub fn num_complex::Complex<T>::is_zero(&self) -> bool
pub fn num_complex::Complex<T>::one() -> Self
pub fn num_complex::Complex<T>::to_f64(&self) -> core::option::Option<f64>
pub fn num_complex::Complex<T>::zero() -> Self
pub trait numrs2::traits::SpecializedAllocator: numrs2::traits::MemoryAllocator
pub fn numrs2::traits::SpecializedAllocator::allocation_error(&self, msg: &str) -> Self::Error
impl numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator
pub fn numrs2::memory_alloc::cache_optimization::CacheOptimizedAllocator::allocation_error(&self, msg: &str) -> Self::Error
impl numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator
pub fn numrs2::memory_alloc::enhanced_traits::NumericalArrayAllocator::allocation_error(&self, msg: &str) -> Self::Error
impl<A> numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A> where A: numrs2::traits::SpecializedAllocator<Error = numrs2::NumRs2Error>
pub fn numrs2::memory_alloc::monitored_allocator::MonitoredAllocator<A>::allocation_error(&self, msg: &str) -> Self::Error
impl<A> numrs2::traits::SpecializedAllocator for numrs2::parallel::parallel_allocator::ParallelAllocator<A> where A: numrs2::traits::MemoryAllocator<Error = numrs2::NumRs2Error> + core::marker::Send + core::marker::Sync + core::clone::Clone + 'static
pub fn numrs2::parallel::parallel_allocator::ParallelAllocator<A>::allocation_error(&self, msg: &str) -> Self::Error
impl<T: numrs2::memory_alloc::strategy::MemoryAllocator + core::fmt::Debug> numrs2::traits::SpecializedAllocator for numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>
pub fn numrs2::memory_alloc::enhanced_traits::EnhancedAllocatorBridge<T>::allocation_error(&self, msg: &str) -> Self::Error
pub mod numrs2::types
pub mod numrs2::types::business_days
pub enum numrs2::types::business_days::Weekday
pub numrs2::types::business_days::Weekday::Friday = 4
pub numrs2::types::business_days::Weekday::Monday = 0
pub numrs2::types::business_days::Weekday::Saturday = 5
pub numrs2::types::business_days::Weekday::Sunday = 6
pub numrs2::types::business_days::Weekday::Thursday = 3
pub numrs2::types::business_days::Weekday::Tuesday = 1
pub numrs2::types::business_days::Weekday::Wednesday = 2
impl numrs2::types::datetime::business_days::Weekday
pub fn numrs2::types::datetime::business_days::Weekday::is_business_day(&self) -> bool
pub struct numrs2::types::business_days::HolidayCalendar
impl numrs2::types::datetime::business_days::HolidayCalendar
pub fn numrs2::types::datetime::business_days::HolidayCalendar::add_holiday(&mut self, date: numrs2::types::datetime::DateTime64)
pub fn numrs2::types::datetime::business_days::HolidayCalendar::business_day_count(&self, start: &numrs2::types::datetime::DateTime64, end: &numrs2::types::datetime::DateTime64) -> numrs2::Result<i64>
pub fn numrs2::types::datetime::business_days::HolidayCalendar::is_business_day(&self, dt: &numrs2::types::datetime::DateTime64) -> numrs2::Result<bool>
pub fn numrs2::types::datetime::business_days::HolidayCalendar::is_holiday(&self, dt: &numrs2::types::datetime::DateTime64) -> bool
pub fn numrs2::types::datetime::business_days::HolidayCalendar::new() -> Self
pub fn numrs2::types::datetime::business_days::HolidayCalendar::us_federal(year: i32) -> numrs2::Result<Self>
impl core::default::Default for numrs2::types::datetime::business_days::HolidayCalendar
pub fn numrs2::types::datetime::business_days::HolidayCalendar::default() -> Self
pub fn numrs2::types::business_days::busday_count(start: &numrs2::types::datetime::DateTime64, end: &numrs2::types::datetime::DateTime64) -> numrs2::Result<i64>
pub fn numrs2::types::business_days::busday_offset(dt: &numrs2::types::datetime::DateTime64, offset: i64) -> numrs2::Result<numrs2::types::datetime::DateTime64>
pub fn numrs2::types::business_days::is_busday(dt: &numrs2::types::datetime::DateTime64) -> numrs2::Result<bool>
pub fn numrs2::types::business_days::weekday(dt: &numrs2::types::datetime::DateTime64) -> numrs2::Result<numrs2::types::datetime::business_days::Weekday>
pub mod numrs2::types::custom
pub struct numrs2::types::custom::CustomDType<T: 'static>
impl<T: core::clone::Clone + core::default::Default + core::marker::Send + core::marker::Sync + 'static> numrs2::types::custom::CustomDType<T>
pub fn numrs2::types::custom::CustomDType<T>::new<S: core::convert::Into<alloc::string::String>>(name: S, size: usize, numeric: bool) -> Self
impl<T: core::fmt::Debug + core::clone::Clone + core::default::Default + core::marker::Send + core::marker::Sync + 'static> core::fmt::Debug for numrs2::types::custom::CustomDType<T>
pub fn numrs2::types::custom::CustomDType<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::fmt::Debug + core::clone::Clone + core::default::Default + core::marker::Send + core::marker::Sync + 'static> numrs2::types::custom::TypeDescriptor for numrs2::types::custom::CustomDType<T>
pub fn numrs2::types::custom::CustomDType<T>::default_value(&self) -> alloc::boxed::Box<dyn core::any::Any>
pub fn numrs2::types::custom::CustomDType<T>::is_numeric(&self) -> bool
pub fn numrs2::types::custom::CustomDType<T>::name(&self) -> &str
pub fn numrs2::types::custom::CustomDType<T>::parse_bytes(&self, _bytes: &[u8]) -> alloc::boxed::Box<dyn core::any::Any>
pub fn numrs2::types::custom::CustomDType<T>::size_in_bytes(&self) -> usize
pub fn numrs2::types::custom::CustomDType<T>::to_bytes(&self, value: &dyn core::any::Any) -> alloc::vec::Vec<u8>
pub trait numrs2::types::custom::TypeDescriptor: core::fmt::Debug + core::clone::Clone + core::marker::Send + core::marker::Sync + 'static
pub fn numrs2::types::custom::TypeDescriptor::default_value(&self) -> alloc::boxed::Box<dyn core::any::Any>
pub fn numrs2::types::custom::TypeDescriptor::is_numeric(&self) -> bool
pub fn numrs2::types::custom::TypeDescriptor::name(&self) -> &str
pub fn numrs2::types::custom::TypeDescriptor::parse_bytes(&self, bytes: &[u8]) -> alloc::boxed::Box<dyn core::any::Any>
pub fn numrs2::types::custom::TypeDescriptor::size_in_bytes(&self) -> usize
pub fn numrs2::types::custom::TypeDescriptor::to_bytes(&self, value: &dyn core::any::Any) -> alloc::vec::Vec<u8>
impl<T: core::fmt::Debug + core::clone::Clone + core::default::Default + core::marker::Send + core::marker::Sync + 'static> numrs2::types::custom::TypeDescriptor for numrs2::types::custom::CustomDType<T>
pub fn numrs2::types::custom::CustomDType<T>::default_value(&self) -> alloc::boxed::Box<dyn core::any::Any>
pub fn numrs2::types::custom::CustomDType<T>::is_numeric(&self) -> bool
pub fn numrs2::types::custom::CustomDType<T>::name(&self) -> &str
pub fn numrs2::types::custom::CustomDType<T>::parse_bytes(&self, _bytes: &[u8]) -> alloc::boxed::Box<dyn core::any::Any>
pub fn numrs2::types::custom::CustomDType<T>::size_in_bytes(&self) -> usize
pub fn numrs2::types::custom::CustomDType<T>::to_bytes(&self, value: &dyn core::any::Any) -> alloc::vec::Vec<u8>
pub mod numrs2::types::datetime
pub mod numrs2::types::datetime::array_ops
pub fn numrs2::types::datetime::array_ops::busday_offset_array(dts: &numrs2::array::Array<numrs2::types::datetime::DateTime64>, offsets: &numrs2::array::Array<i32>, _roll: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<numrs2::types::datetime::DateTime64>>
pub fn numrs2::types::datetime::array_ops::datetime_as_string_array(dts: &numrs2::array::Array<numrs2::types::datetime::DateTime64>, unit: core::option::Option<&str>, timezone: core::option::Option<&str>) -> numrs2::Result<numrs2::array::Array<alloc::string::String>>
pub fn numrs2::types::datetime::array_ops::is_busday_array(dts: &numrs2::array::Array<numrs2::types::datetime::DateTime64>) -> numrs2::Result<numrs2::array::Array<bool>>
pub mod numrs2::types::datetime::business_days
pub enum numrs2::types::datetime::business_days::Weekday
pub numrs2::types::datetime::business_days::Weekday::Friday = 4
pub numrs2::types::datetime::business_days::Weekday::Monday = 0
pub numrs2::types::datetime::business_days::Weekday::Saturday = 5
pub numrs2::types::datetime::business_days::Weekday::Sunday = 6
pub numrs2::types::datetime::business_days::Weekday::Thursday = 3
pub numrs2::types::datetime::business_days::Weekday::Tuesday = 1
pub numrs2::types::datetime::business_days::Weekday::Wednesday = 2
impl numrs2::types::datetime::business_days::Weekday
pub fn numrs2::types::datetime::business_days::Weekday::is_business_day(&self) -> bool
pub struct numrs2::types::datetime::business_days::HolidayCalendar
impl numrs2::types::datetime::business_days::HolidayCalendar
pub fn numrs2::types::datetime::business_days::HolidayCalendar::add_holiday(&mut self, date: numrs2::types::datetime::DateTime64)
pub fn numrs2::types::datetime::business_days::HolidayCalendar::business_day_count(&self, start: &numrs2::types::datetime::DateTime64, end: &numrs2::types::datetime::DateTime64) -> numrs2::Result<i64>
pub fn numrs2::types::datetime::business_days::HolidayCalendar::is_business_day(&self, dt: &numrs2::types::datetime::DateTime64) -> numrs2::Result<bool>
pub fn numrs2::types::datetime::business_days::HolidayCalendar::is_holiday(&self, dt: &numrs2::types::datetime::DateTime64) -> bool
pub fn numrs2::types::datetime::business_days::HolidayCalendar::new() -> Self
pub fn numrs2::types::datetime::business_days::HolidayCalendar::us_federal(year: i32) -> numrs2::Result<Self>
impl core::default::Default for numrs2::types::datetime::business_days::HolidayCalendar
pub fn numrs2::types::datetime::business_days::HolidayCalendar::default() -> Self
pub fn numrs2::types::datetime::business_days::busday_count(start: &numrs2::types::datetime::DateTime64, end: &numrs2::types::datetime::DateTime64) -> numrs2::Result<i64>
pub fn numrs2::types::datetime::business_days::busday_offset(dt: &numrs2::types::datetime::DateTime64, offset: i64) -> numrs2::Result<numrs2::types::datetime::DateTime64>
pub fn numrs2::types::datetime::business_days::is_busday(dt: &numrs2::types::datetime::DateTime64) -> numrs2::Result<bool>
pub fn numrs2::types::datetime::business_days::weekday(dt: &numrs2::types::datetime::DateTime64) -> numrs2::Result<numrs2::types::datetime::business_days::Weekday>
pub mod numrs2::types::datetime::datetime_array
pub fn numrs2::types::datetime::datetime_array::date_range(start: &str, end: core::option::Option<&str>, periods: core::option::Option<usize>, freq: numrs2::types::datetime::DateTimeUnit, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::array::Array<numrs2::types::datetime::DateTime64>>
pub fn numrs2::types::datetime::datetime_array::datetime_from_strings(strings: &[&str], unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::array::Array<numrs2::types::datetime::DateTime64>>
pub fn numrs2::types::datetime::datetime_array::now(unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::types::datetime::DateTime64>
pub fn numrs2::types::datetime::datetime_array::timedelta_range(start: i64, end: core::option::Option<i64>, periods: core::option::Option<usize>, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::array::Array<numrs2::types::datetime::TimeDelta64>>
pub fn numrs2::types::datetime::datetime_array::today(unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::types::datetime::DateTime64>
pub enum numrs2::types::datetime::DateTimeUnit
pub numrs2::types::datetime::DateTimeUnit::Day
pub numrs2::types::datetime::DateTimeUnit::Hour
pub numrs2::types::datetime::DateTimeUnit::Microsecond
pub numrs2::types::datetime::DateTimeUnit::Millisecond
pub numrs2::types::datetime::DateTimeUnit::Minute
pub numrs2::types::datetime::DateTimeUnit::Month
pub numrs2::types::datetime::DateTimeUnit::Nanosecond
pub numrs2::types::datetime::DateTimeUnit::Second
pub numrs2::types::datetime::DateTimeUnit::Week
pub numrs2::types::datetime::DateTimeUnit::Year
impl core::fmt::Display for numrs2::types::datetime::DateTimeUnit
pub fn numrs2::types::datetime::DateTimeUnit::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub enum numrs2::types::datetime::DateUnit
pub numrs2::types::datetime::DateUnit::Day
pub numrs2::types::datetime::DateUnit::Month
pub numrs2::types::datetime::DateUnit::Week
pub numrs2::types::datetime::DateUnit::Year
pub struct numrs2::types::datetime::DateTime64
impl numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::from_iso_string(s: &str, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<Self>
pub fn numrs2::types::datetime::DateTime64::from_system_time(time: std::time::SystemTime, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<Self>
pub fn numrs2::types::datetime::DateTime64::new(value: i64, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::DateTime64::to_iso_string(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::types::datetime::DateTime64::to_system_time(&self) -> std::time::SystemTime
pub fn numrs2::types::datetime::DateTime64::to_unit(&self, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::DateTime64::unit(&self) -> numrs2::types::datetime::DateTimeUnit
pub fn numrs2::types::datetime::DateTime64::value(&self) -> i64
impl core::fmt::Display for numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Sub for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::DateTime64::sub(self, rhs: numrs2::types::datetime::DateTime64) -> Self::Output
impl core::ops::arith::Sub<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::str::traits::FromStr for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Err = numrs2::NumRs2Error
pub fn numrs2::types::datetime::DateTime64::from_str(s: &str) -> numrs2::Result<Self>
pub struct numrs2::types::datetime::TimeDelta64
impl numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::abs(&self) -> Self
pub fn numrs2::types::datetime::TimeDelta64::from_duration(duration: core::time::Duration, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::TimeDelta64::neg(&self) -> Self
pub fn numrs2::types::datetime::TimeDelta64::new(value: i64, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::TimeDelta64::to_duration(&self) -> core::time::Duration
pub fn numrs2::types::datetime::TimeDelta64::to_unit(&self, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::TimeDelta64::unit(&self) -> numrs2::types::datetime::DateTimeUnit
pub fn numrs2::types::datetime::TimeDelta64::value(&self) -> i64
impl core::fmt::Display for numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Add<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Add<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Div for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = f64
pub fn numrs2::types::datetime::TimeDelta64::div(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Div<i64> for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::div(self, rhs: i64) -> Self::Output
impl core::ops::arith::Mul<i64> for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::mul(self, rhs: i64) -> Self::Output
impl core::ops::arith::Mul<numrs2::types::datetime::TimeDelta64> for i64
pub type i64::Output = numrs2::types::datetime::TimeDelta64
pub fn i64::mul(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Neg for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::neg(self) -> Self::Output
impl core::ops::arith::Sub for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Sub<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Sub<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
pub struct numrs2::types::datetime::Timezone
pub numrs2::types::datetime::Timezone::name: alloc::string::String
pub numrs2::types::datetime::Timezone::offset_minutes: i32
impl numrs2::types::datetime::Timezone
pub fn numrs2::types::datetime::Timezone::cet() -> Self
pub fn numrs2::types::datetime::Timezone::est() -> Self
pub fn numrs2::types::datetime::Timezone::fixed_offset(name: &str, hours: i32, minutes: i32) -> Self
pub fn numrs2::types::datetime::Timezone::jst() -> Self
pub fn numrs2::types::datetime::Timezone::pst() -> Self
pub fn numrs2::types::datetime::Timezone::utc() -> Self
impl core::fmt::Display for numrs2::types::datetime::Timezone
pub fn numrs2::types::datetime::Timezone::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::types::datetime::TimezoneDateTime
pub numrs2::types::datetime::TimezoneDateTime::timezone: numrs2::types::datetime::Timezone
pub numrs2::types::datetime::TimezoneDateTime::utc_datetime: numrs2::types::datetime::DateTime64
impl numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::from_iso_string_with_tz(s: &str, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<Self>
pub fn numrs2::types::datetime::TimezoneDateTime::from_local(local_datetime: numrs2::types::datetime::DateTime64, timezone: numrs2::types::datetime::Timezone) -> Self
pub fn numrs2::types::datetime::TimezoneDateTime::new(utc_datetime: numrs2::types::datetime::DateTime64, timezone: numrs2::types::datetime::Timezone) -> Self
pub fn numrs2::types::datetime::TimezoneDateTime::to_iso_string_with_tz(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::types::datetime::TimezoneDateTime::to_local(&self) -> numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::TimezoneDateTime::to_timezone(&self, new_timezone: numrs2::types::datetime::Timezone) -> Self
impl core::fmt::Display for numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Sub for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimezoneDateTime::sub(self, rhs: numrs2::types::datetime::TimezoneDateTime) -> Self::Output
impl core::ops::arith::Sub<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
pub fn numrs2::types::datetime::datetime64(value: &str, unit: core::option::Option<&str>) -> numrs2::Result<numrs2::types::datetime::DateTime64>
pub fn numrs2::types::datetime::datetime_as_string(dt: &numrs2::types::datetime::DateTime64, unit: core::option::Option<&str>, _timezone: core::option::Option<&str>) -> numrs2::Result<alloc::string::String>
pub fn numrs2::types::datetime::datetime_data(dt: &numrs2::types::datetime::DateTime64) -> (alloc::string::String, i64)
pub fn numrs2::types::datetime::timedelta64(value: i64, unit: &str) -> numrs2::Result<numrs2::types::datetime::TimeDelta64>
pub mod numrs2::types::datetime_array
pub fn numrs2::types::datetime_array::date_range(start: &str, end: core::option::Option<&str>, periods: core::option::Option<usize>, freq: numrs2::types::datetime::DateTimeUnit, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::array::Array<numrs2::types::datetime::DateTime64>>
pub fn numrs2::types::datetime_array::datetime_from_strings(strings: &[&str], unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::array::Array<numrs2::types::datetime::DateTime64>>
pub fn numrs2::types::datetime_array::now(unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::types::datetime::DateTime64>
pub fn numrs2::types::datetime_array::timedelta_range(start: i64, end: core::option::Option<i64>, periods: core::option::Option<usize>, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::array::Array<numrs2::types::datetime::TimeDelta64>>
pub fn numrs2::types::datetime_array::today(unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<numrs2::types::datetime::DateTime64>
pub mod numrs2::types::structured
pub enum numrs2::types::structured::DType
pub numrs2::types::structured::DType::Bool
pub numrs2::types::structured::DType::Complex32
pub numrs2::types::structured::DType::Complex64
pub numrs2::types::structured::DType::Float32
pub numrs2::types::structured::DType::Float64
pub numrs2::types::structured::DType::Int16
pub numrs2::types::structured::DType::Int32
pub numrs2::types::structured::DType::Int64
pub numrs2::types::structured::DType::Int8
pub numrs2::types::structured::DType::String(usize)
pub numrs2::types::structured::DType::Struct(alloc::vec::Vec<numrs2::types::structured::Field>)
pub numrs2::types::structured::DType::UInt16
pub numrs2::types::structured::DType::UInt32
pub numrs2::types::structured::DType::UInt64
pub numrs2::types::structured::DType::UInt8
impl numrs2::types::structured::DType
pub fn numrs2::types::structured::DType::is_complex(&self) -> bool
pub fn numrs2::types::structured::DType::is_floating_point(&self) -> bool
pub fn numrs2::types::structured::DType::is_numeric(&self) -> bool
pub fn numrs2::types::structured::DType::is_string(&self) -> bool
pub fn numrs2::types::structured::DType::is_struct(&self) -> bool
pub fn numrs2::types::structured::DType::size_in_bytes(&self) -> usize
impl core::fmt::Display for numrs2::types::structured::DType
pub fn numrs2::types::structured::DType::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::types::structured::Field
pub numrs2::types::structured::Field::dtype: numrs2::types::structured::DType
pub numrs2::types::structured::Field::name: alloc::string::String
impl numrs2::types::structured::Field
pub fn numrs2::types::structured::Field::new<S: core::convert::Into<alloc::string::String>>(name: S, dtype: numrs2::types::structured::DType) -> Self
impl core::fmt::Display for numrs2::types::structured::Field
pub fn numrs2::types::structured::Field::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::types::structured::RecordArray
impl numrs2::types::structured::RecordArray
pub fn numrs2::types::structured::RecordArray::add_field(&mut self, field_name: &str, data: numrs2::array::Array<f64>) -> numrs2::Result<()>
pub fn numrs2::types::structured::RecordArray::dtype(&self) -> &numrs2::types::structured::DType
pub fn numrs2::types::structured::RecordArray::field(&self, field_name: &str) -> numrs2::Result<&numrs2::array::Array<f64>>
pub fn numrs2::types::structured::RecordArray::field_mut(&mut self, field_name: &str) -> numrs2::Result<&mut numrs2::array::Array<f64>>
pub fn numrs2::types::structured::RecordArray::field_names(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::types::structured::RecordArray::from_arrays(arrays: &std::collections::hash::map::HashMap<alloc::string::String, numrs2::array::Array<f64>>, shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::types::structured::RecordArray::ndim(&self) -> usize
pub fn numrs2::types::structured::RecordArray::new(shape: &[usize], fields: alloc::vec::Vec<numrs2::types::structured::Field>) -> Self
pub fn numrs2::types::structured::RecordArray::remove_field(&mut self, field_name: &str) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::types::structured::RecordArray::set_field(&mut self, index: &[usize], field_name: &str, value: f64) -> numrs2::Result<()>
pub fn numrs2::types::structured::RecordArray::shape(&self) -> &[usize]
pub fn numrs2::types::structured::RecordArray::size(&self) -> usize
impl core::fmt::Display for numrs2::types::structured::RecordArray
pub fn numrs2::types::structured::RecordArray::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::types::structured::StructuredArray
impl numrs2::types::structured::StructuredArray
pub fn numrs2::types::structured::StructuredArray::data(&self) -> &[u8]
pub fn numrs2::types::structured::StructuredArray::dtype(&self) -> &numrs2::types::structured::DType
pub fn numrs2::types::structured::StructuredArray::field<T: core::clone::Clone + core::default::Default + 'static>(&self, field_name: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::types::structured::StructuredArray::from_arrays<T: core::clone::Clone + core::default::Default + 'static>(arrays: &std::collections::hash::map::HashMap<alloc::string::String, numrs2::array::Array<T>>, shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::types::structured::StructuredArray::ndim(&self) -> usize
pub fn numrs2::types::structured::StructuredArray::new(shape: &[usize], dtype: numrs2::types::structured::DType) -> Self
pub fn numrs2::types::structured::StructuredArray::set_field<T: core::clone::Clone + 'static>(&mut self, index: &[usize], field_name: &str, value: T) -> numrs2::Result<()>
pub fn numrs2::types::structured::StructuredArray::shape(&self) -> &[usize]
pub fn numrs2::types::structured::StructuredArray::size(&self) -> usize
impl core::fmt::Display for numrs2::types::structured::StructuredArray
pub fn numrs2::types::structured::StructuredArray::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub enum numrs2::types::DType
pub numrs2::types::DType::Bool
pub numrs2::types::DType::Complex32
pub numrs2::types::DType::Complex64
pub numrs2::types::DType::Float32
pub numrs2::types::DType::Float64
pub numrs2::types::DType::Int16
pub numrs2::types::DType::Int32
pub numrs2::types::DType::Int64
pub numrs2::types::DType::Int8
pub numrs2::types::DType::String(usize)
pub numrs2::types::DType::Struct(alloc::vec::Vec<numrs2::types::structured::Field>)
pub numrs2::types::DType::UInt16
pub numrs2::types::DType::UInt32
pub numrs2::types::DType::UInt64
pub numrs2::types::DType::UInt8
impl numrs2::types::structured::DType
pub fn numrs2::types::structured::DType::is_complex(&self) -> bool
pub fn numrs2::types::structured::DType::is_floating_point(&self) -> bool
pub fn numrs2::types::structured::DType::is_numeric(&self) -> bool
pub fn numrs2::types::structured::DType::is_string(&self) -> bool
pub fn numrs2::types::structured::DType::is_struct(&self) -> bool
pub fn numrs2::types::structured::DType::size_in_bytes(&self) -> usize
impl core::fmt::Display for numrs2::types::structured::DType
pub fn numrs2::types::structured::DType::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub enum numrs2::types::DateTimeUnit
pub numrs2::types::DateTimeUnit::Day
pub numrs2::types::DateTimeUnit::Hour
pub numrs2::types::DateTimeUnit::Microsecond
pub numrs2::types::DateTimeUnit::Millisecond
pub numrs2::types::DateTimeUnit::Minute
pub numrs2::types::DateTimeUnit::Month
pub numrs2::types::DateTimeUnit::Nanosecond
pub numrs2::types::DateTimeUnit::Second
pub numrs2::types::DateTimeUnit::Week
pub numrs2::types::DateTimeUnit::Year
impl core::fmt::Display for numrs2::types::datetime::DateTimeUnit
pub fn numrs2::types::datetime::DateTimeUnit::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub enum numrs2::types::DateUnit
pub numrs2::types::DateUnit::Day
pub numrs2::types::DateUnit::Month
pub numrs2::types::DateUnit::Week
pub numrs2::types::DateUnit::Year
pub struct numrs2::types::CustomDType<T: 'static>
impl<T: core::clone::Clone + core::default::Default + core::marker::Send + core::marker::Sync + 'static> numrs2::types::custom::CustomDType<T>
pub fn numrs2::types::custom::CustomDType<T>::new<S: core::convert::Into<alloc::string::String>>(name: S, size: usize, numeric: bool) -> Self
impl<T: core::fmt::Debug + core::clone::Clone + core::default::Default + core::marker::Send + core::marker::Sync + 'static> core::fmt::Debug for numrs2::types::custom::CustomDType<T>
pub fn numrs2::types::custom::CustomDType<T>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl<T: core::fmt::Debug + core::clone::Clone + core::default::Default + core::marker::Send + core::marker::Sync + 'static> numrs2::types::custom::TypeDescriptor for numrs2::types::custom::CustomDType<T>
pub fn numrs2::types::custom::CustomDType<T>::default_value(&self) -> alloc::boxed::Box<dyn core::any::Any>
pub fn numrs2::types::custom::CustomDType<T>::is_numeric(&self) -> bool
pub fn numrs2::types::custom::CustomDType<T>::name(&self) -> &str
pub fn numrs2::types::custom::CustomDType<T>::parse_bytes(&self, _bytes: &[u8]) -> alloc::boxed::Box<dyn core::any::Any>
pub fn numrs2::types::custom::CustomDType<T>::size_in_bytes(&self) -> usize
pub fn numrs2::types::custom::CustomDType<T>::to_bytes(&self, value: &dyn core::any::Any) -> alloc::vec::Vec<u8>
pub struct numrs2::types::DateTime64
impl numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::from_iso_string(s: &str, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<Self>
pub fn numrs2::types::datetime::DateTime64::from_system_time(time: std::time::SystemTime, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<Self>
pub fn numrs2::types::datetime::DateTime64::new(value: i64, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::DateTime64::to_iso_string(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::types::datetime::DateTime64::to_system_time(&self) -> std::time::SystemTime
pub fn numrs2::types::datetime::DateTime64::to_unit(&self, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::DateTime64::unit(&self) -> numrs2::types::datetime::DateTimeUnit
pub fn numrs2::types::datetime::DateTime64::value(&self) -> i64
impl core::fmt::Display for numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Sub for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::DateTime64::sub(self, rhs: numrs2::types::datetime::DateTime64) -> Self::Output
impl core::ops::arith::Sub<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::str::traits::FromStr for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Err = numrs2::NumRs2Error
pub fn numrs2::types::datetime::DateTime64::from_str(s: &str) -> numrs2::Result<Self>
pub struct numrs2::types::Field
pub numrs2::types::Field::dtype: numrs2::types::structured::DType
pub numrs2::types::Field::name: alloc::string::String
impl numrs2::types::structured::Field
pub fn numrs2::types::structured::Field::new<S: core::convert::Into<alloc::string::String>>(name: S, dtype: numrs2::types::structured::DType) -> Self
impl core::fmt::Display for numrs2::types::structured::Field
pub fn numrs2::types::structured::Field::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::types::RecordArray
impl numrs2::types::structured::RecordArray
pub fn numrs2::types::structured::RecordArray::add_field(&mut self, field_name: &str, data: numrs2::array::Array<f64>) -> numrs2::Result<()>
pub fn numrs2::types::structured::RecordArray::dtype(&self) -> &numrs2::types::structured::DType
pub fn numrs2::types::structured::RecordArray::field(&self, field_name: &str) -> numrs2::Result<&numrs2::array::Array<f64>>
pub fn numrs2::types::structured::RecordArray::field_mut(&mut self, field_name: &str) -> numrs2::Result<&mut numrs2::array::Array<f64>>
pub fn numrs2::types::structured::RecordArray::field_names(&self) -> alloc::vec::Vec<alloc::string::String>
pub fn numrs2::types::structured::RecordArray::from_arrays(arrays: &std::collections::hash::map::HashMap<alloc::string::String, numrs2::array::Array<f64>>, shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::types::structured::RecordArray::ndim(&self) -> usize
pub fn numrs2::types::structured::RecordArray::new(shape: &[usize], fields: alloc::vec::Vec<numrs2::types::structured::Field>) -> Self
pub fn numrs2::types::structured::RecordArray::remove_field(&mut self, field_name: &str) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::types::structured::RecordArray::set_field(&mut self, index: &[usize], field_name: &str, value: f64) -> numrs2::Result<()>
pub fn numrs2::types::structured::RecordArray::shape(&self) -> &[usize]
pub fn numrs2::types::structured::RecordArray::size(&self) -> usize
impl core::fmt::Display for numrs2::types::structured::RecordArray
pub fn numrs2::types::structured::RecordArray::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::types::StructuredArray
impl numrs2::types::structured::StructuredArray
pub fn numrs2::types::structured::StructuredArray::data(&self) -> &[u8]
pub fn numrs2::types::structured::StructuredArray::dtype(&self) -> &numrs2::types::structured::DType
pub fn numrs2::types::structured::StructuredArray::field<T: core::clone::Clone + core::default::Default + 'static>(&self, field_name: &str) -> numrs2::Result<numrs2::array::Array<T>>
pub fn numrs2::types::structured::StructuredArray::from_arrays<T: core::clone::Clone + core::default::Default + 'static>(arrays: &std::collections::hash::map::HashMap<alloc::string::String, numrs2::array::Array<T>>, shape: &[usize]) -> numrs2::Result<Self>
pub fn numrs2::types::structured::StructuredArray::ndim(&self) -> usize
pub fn numrs2::types::structured::StructuredArray::new(shape: &[usize], dtype: numrs2::types::structured::DType) -> Self
pub fn numrs2::types::structured::StructuredArray::set_field<T: core::clone::Clone + 'static>(&mut self, index: &[usize], field_name: &str, value: T) -> numrs2::Result<()>
pub fn numrs2::types::structured::StructuredArray::shape(&self) -> &[usize]
pub fn numrs2::types::structured::StructuredArray::size(&self) -> usize
impl core::fmt::Display for numrs2::types::structured::StructuredArray
pub fn numrs2::types::structured::StructuredArray::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::types::TimeDelta64
impl numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::abs(&self) -> Self
pub fn numrs2::types::datetime::TimeDelta64::from_duration(duration: core::time::Duration, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::TimeDelta64::neg(&self) -> Self
pub fn numrs2::types::datetime::TimeDelta64::new(value: i64, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::TimeDelta64::to_duration(&self) -> core::time::Duration
pub fn numrs2::types::datetime::TimeDelta64::to_unit(&self, unit: numrs2::types::datetime::DateTimeUnit) -> Self
pub fn numrs2::types::datetime::TimeDelta64::unit(&self) -> numrs2::types::datetime::DateTimeUnit
pub fn numrs2::types::datetime::TimeDelta64::value(&self) -> i64
impl core::fmt::Display for numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Add<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Add<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Div for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = f64
pub fn numrs2::types::datetime::TimeDelta64::div(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Div<i64> for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::div(self, rhs: i64) -> Self::Output
impl core::ops::arith::Mul<i64> for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::mul(self, rhs: i64) -> Self::Output
impl core::ops::arith::Mul<numrs2::types::datetime::TimeDelta64> for i64
pub type i64::Output = numrs2::types::datetime::TimeDelta64
pub fn i64::mul(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Neg for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::neg(self) -> Self::Output
impl core::ops::arith::Sub for numrs2::types::datetime::TimeDelta64
pub type numrs2::types::datetime::TimeDelta64::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimeDelta64::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Sub<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::DateTime64
pub type numrs2::types::datetime::DateTime64::Output = numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::DateTime64::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Sub<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
pub struct numrs2::types::Timezone
pub numrs2::types::Timezone::name: alloc::string::String
pub numrs2::types::Timezone::offset_minutes: i32
impl numrs2::types::datetime::Timezone
pub fn numrs2::types::datetime::Timezone::cet() -> Self
pub fn numrs2::types::datetime::Timezone::est() -> Self
pub fn numrs2::types::datetime::Timezone::fixed_offset(name: &str, hours: i32, minutes: i32) -> Self
pub fn numrs2::types::datetime::Timezone::jst() -> Self
pub fn numrs2::types::datetime::Timezone::pst() -> Self
pub fn numrs2::types::datetime::Timezone::utc() -> Self
impl core::fmt::Display for numrs2::types::datetime::Timezone
pub fn numrs2::types::datetime::Timezone::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::types::TimezoneDateTime
pub numrs2::types::TimezoneDateTime::timezone: numrs2::types::datetime::Timezone
pub numrs2::types::TimezoneDateTime::utc_datetime: numrs2::types::datetime::DateTime64
impl numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::from_iso_string_with_tz(s: &str, unit: numrs2::types::datetime::DateTimeUnit) -> numrs2::Result<Self>
pub fn numrs2::types::datetime::TimezoneDateTime::from_local(local_datetime: numrs2::types::datetime::DateTime64, timezone: numrs2::types::datetime::Timezone) -> Self
pub fn numrs2::types::datetime::TimezoneDateTime::new(utc_datetime: numrs2::types::datetime::DateTime64, timezone: numrs2::types::datetime::Timezone) -> Self
pub fn numrs2::types::datetime::TimezoneDateTime::to_iso_string_with_tz(&self) -> numrs2::Result<alloc::string::String>
pub fn numrs2::types::datetime::TimezoneDateTime::to_local(&self) -> numrs2::types::datetime::DateTime64
pub fn numrs2::types::datetime::TimezoneDateTime::to_timezone(&self, new_timezone: numrs2::types::datetime::Timezone) -> Self
impl core::fmt::Display for numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
impl core::ops::arith::Add<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::add(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
impl core::ops::arith::Sub for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimeDelta64
pub fn numrs2::types::datetime::TimezoneDateTime::sub(self, rhs: numrs2::types::datetime::TimezoneDateTime) -> Self::Output
impl core::ops::arith::Sub<numrs2::types::datetime::TimeDelta64> for numrs2::types::datetime::TimezoneDateTime
pub type numrs2::types::datetime::TimezoneDateTime::Output = numrs2::types::datetime::TimezoneDateTime
pub fn numrs2::types::datetime::TimezoneDateTime::sub(self, rhs: numrs2::types::datetime::TimeDelta64) -> Self::Output
pub fn numrs2::types::datetime64(value: &str, unit: core::option::Option<&str>) -> numrs2::Result<numrs2::types::datetime::DateTime64>
pub fn numrs2::types::datetime_as_string(dt: &numrs2::types::datetime::DateTime64, unit: core::option::Option<&str>, _timezone: core::option::Option<&str>) -> numrs2::Result<alloc::string::String>
pub fn numrs2::types::datetime_data(dt: &numrs2::types::datetime::DateTime64) -> (alloc::string::String, i64)
pub fn numrs2::types::timedelta64(value: i64, unit: &str) -> numrs2::Result<numrs2::types::datetime::TimeDelta64>
pub mod numrs2::ufuncs
pub struct numrs2::ufuncs::BinaryUfunc<F> where F: core::ops::function::Fn(f64, f64) -> f64
impl<F> numrs2::ufuncs::BinaryUfunc<F> where F: core::ops::function::Fn(f64, f64) -> f64
pub fn numrs2::ufuncs::BinaryUfunc<F>::call(&self, a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::BinaryUfunc<F>::call_scalar_left(&self, a: f64, b: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::BinaryUfunc<F>::call_scalar_right(&self, a: &numrs2::array::Array<f64>, b: f64) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::BinaryUfunc<F>::new(func: F, name: &'static str) -> Self
impl<F> core::fmt::Debug for numrs2::ufuncs::BinaryUfunc<F> where F: core::ops::function::Fn(f64, f64) -> f64
pub fn numrs2::ufuncs::BinaryUfunc<F>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub struct numrs2::ufuncs::UnaryUfunc<F> where F: core::ops::function::Fn(f64) -> f64
impl<F> numrs2::ufuncs::UnaryUfunc<F> where F: core::ops::function::Fn(f64) -> f64
pub fn numrs2::ufuncs::UnaryUfunc<F>::call(&self, a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::UnaryUfunc<F>::new(func: F, name: &'static str) -> Self
impl<F> core::fmt::Debug for numrs2::ufuncs::UnaryUfunc<F> where F: core::ops::function::Fn(f64) -> f64
pub fn numrs2::ufuncs::UnaryUfunc<F>::fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result
pub fn numrs2::ufuncs::abs(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::absolute(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::acos(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::acosh(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::add(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::add_scalar(a: &numrs2::array::Array<f64>, b: f64) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::arccos(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::arccosh(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::arcsin(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::arcsinh(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::arctan(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::arctan2(y: &numrs2::array::Array<f64>, x: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::arctanh(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::asin(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::asinh(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::atan(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::atan2(y: &numrs2::array::Array<f64>, x: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::atanh(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::cbrt(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::ceil(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::clip(a: &numrs2::array::Array<f64>, min: f64, max: f64) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::copysign(mag: &numrs2::array::Array<f64>, sign: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::cos(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::cosh(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::deg2rad(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::degrees(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::digamma(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::divide(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::divide_scalar(a: &numrs2::array::Array<f64>, b: f64) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::dot(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<f64>
pub fn numrs2::ufuncs::elu(a: &numrs2::array::Array<f64>, alpha: f64) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::erf(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::erfc(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::exp(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::exp2(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::expm1(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::floor(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::fma(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>, c: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::fract(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::gamma(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::gammaln(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::gelu(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::hardsigmoid(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::hardswish(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::hypot(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::leaky_relu(a: &numrs2::array::Array<f64>, alpha: f64) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::lerp(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>, t: f64) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::lgamma(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::ln(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::log(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::log10(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::log1p(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::log2(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::log_softmax(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::logaddexp(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::logit(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::maximum(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::mean(a: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::ufuncs::minimum(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::mish(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::multiply(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::multiply_scalar(a: &numrs2::array::Array<f64>, b: f64) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::negative(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::norm_l1(a: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::ufuncs::norm_l2(a: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::ufuncs::power(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::power_scalar(a: &numrs2::array::Array<f64>, b: f64) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::prelu(a: &numrs2::array::Array<f64>, alpha: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::rad2deg(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::radians(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::reciprocal(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::relu(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::round(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::rsqrt(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::selu(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::sigmoid(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::sign(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::silu(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::sin(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::sinc(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::sincos(a: &numrs2::array::Array<f64>) -> (numrs2::array::Array<f64>, numrs2::array::Array<f64>)
pub fn numrs2::ufuncs::sinh(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::smootherstep(edge0: f64, edge1: f64, x: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::smoothstep(edge0: f64, edge1: f64, x: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::softmax(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::softplus(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::sqrt(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::square(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::std(a: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::ufuncs::subtract(a: &numrs2::array::Array<f64>, b: &numrs2::array::Array<f64>) -> numrs2::Result<numrs2::array::Array<f64>>
pub fn numrs2::ufuncs::subtract_scalar(a: &numrs2::array::Array<f64>, b: f64) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::sum(a: &numrs2::array::Array<f64>) -> f64
pub fn numrs2::ufuncs::swish(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::tan(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::tanh(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::trunc(a: &numrs2::array::Array<f64>) -> numrs2::array::Array<f64>
pub fn numrs2::ufuncs::var(a: &numrs2::array::Array<f64>) -> f64
pub mod numrs2::unique
pub struct numrs2::unique::UniqueResult<T>
pub numrs2::unique::UniqueResult::counts: core::option::Option<numrs2::array::Array<usize>>
pub numrs2::unique::UniqueResult::indices: core::option::Option<numrs2::array::Array<usize>>
pub numrs2::unique::UniqueResult::inverse: core::option::Option<numrs2::array::Array<usize>>
pub numrs2::unique::UniqueResult::values: numrs2::array::Array<T>
impl<T: core::clone::Clone> numrs2::unique::UniqueResult<T>
pub fn numrs2::unique::UniqueResult<T>::values(self) -> numrs2::array::Array<T>
pub fn numrs2::unique::UniqueResult<T>::values_counts(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>)>
pub fn numrs2::unique::UniqueResult<T>::values_indices(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>)>
pub fn numrs2::unique::UniqueResult<T>::values_indices_counts(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::unique::UniqueResult<T>::values_indices_inverse(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::unique::UniqueResult<T>::values_indices_inverse_counts(self) -> numrs2::Result<numrs2::unique::UniqueTuple<T>>
pub fn numrs2::unique::UniqueResult<T>::values_inverse(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>)>
pub fn numrs2::unique::UniqueResult<T>::values_inverse_counts(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::unique::unique<T>(a: &numrs2::array::Array<T>, axis: core::option::Option<usize>, return_index: core::option::Option<bool>, return_inverse: core::option::Option<bool>, return_counts: core::option::Option<bool>) -> numrs2::Result<numrs2::unique::UniqueResult<T>> where T: core::clone::Clone + core::hash::Hash + core::cmp::Eq + core::fmt::Debug + num_traits::identities::Zero
pub type numrs2::unique::UniqueTuple<T> = (numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)
pub mod numrs2::unique_optimized
pub struct numrs2::unique_optimized::UniqueResult<T>
pub numrs2::unique_optimized::UniqueResult::counts: core::option::Option<numrs2::array::Array<usize>>
pub numrs2::unique_optimized::UniqueResult::indices: core::option::Option<numrs2::array::Array<usize>>
pub numrs2::unique_optimized::UniqueResult::inverse: core::option::Option<numrs2::array::Array<usize>>
pub numrs2::unique_optimized::UniqueResult::values: numrs2::array::Array<T>
impl<T: core::clone::Clone> numrs2::unique_optimized::UniqueResult<T>
pub fn numrs2::unique_optimized::UniqueResult<T>::values(self) -> numrs2::array::Array<T>
pub fn numrs2::unique_optimized::UniqueResult<T>::values_counts(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>)>
pub fn numrs2::unique_optimized::UniqueResult<T>::values_indices(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>)>
pub fn numrs2::unique_optimized::UniqueResult<T>::values_indices_counts(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::unique_optimized::UniqueResult<T>::values_indices_inverse(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::unique_optimized::UniqueResult<T>::values_indices_inverse_counts(self) -> numrs2::Result<numrs2::unique::UniqueTuple<T>>
pub fn numrs2::unique_optimized::UniqueResult<T>::values_inverse(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>)>
pub fn numrs2::unique_optimized::UniqueResult<T>::values_inverse_counts(self) -> numrs2::Result<(numrs2::array::Array<T>, numrs2::array::Array<usize>, numrs2::array::Array<usize>)>
pub fn numrs2::unique_optimized::unique_optimized<T>(a: &numrs2::array::Array<T>, axis: core::option::Option<usize>, return_index: core::option::Option<bool>, return_inverse: core::option::Option<bool>, return_counts: core::option::Option<bool>) -> numrs2::Result<numrs2::unique_optimized::UniqueResult<T>> where T: core::clone::Clone + core::hash::Hash + core::cmp::Eq + core::fmt::Debug + num_traits::identities::Zero + core::marker::Send + core::marker::Sync
pub mod numrs2::util
pub enum numrs2::util::MemoryLayout
pub numrs2::util::MemoryLayout::ColumnMajor
pub numrs2::util::MemoryLayout::RowMajor
pub fn numrs2::util::astype<T: core::clone::Clone, U: core::clone::Clone + core::convert::From<T>>(array: &numrs2::array::Array<T>) -> numrs2::array::Array<U>
pub fn numrs2::util::broadcast_arrays<T: core::clone::Clone>(arrays: &[&numrs2::array::Array<T>]) -> numrs2::Result<alloc::vec::Vec<numrs2::array::Array<T>>>
pub fn numrs2::util::can_cast(from_type: &str, to_type: &str, casting: &str) -> bool
pub fn numrs2::util::can_operate_inplace<T>(_array: &numrs2::array::Array<T>) -> bool
pub fn numrs2::util::common_type(types: &[&str]) -> &'static str
pub fn numrs2::util::fast_sum<T: num_traits::float::Float + core::marker::Send + core::marker::Sync>(array: &numrs2::array::Array<T>) -> T
pub fn numrs2::util::isscalar<T>(_value: &T) -> bool
pub fn numrs2::util::isscalar_array<T: core::clone::Clone>(array: &numrs2::array::Array<T>) -> bool
pub fn numrs2::util::optimize_layout<T: core::clone::Clone>(array: &numrs2::array::Array<T>, layout: numrs2::util::MemoryLayout) -> numrs2::array::Array<T>
pub fn numrs2::util::parallel_map<T, U, F>(array: &numrs2::array::Array<T>, f: F) -> numrs2::array::Array<U> where T: core::marker::Send + core::marker::Sync + core::clone::Clone, U: core::marker::Send + core::clone::Clone, F: core::ops::function::Fn(T) -> U + core::marker::Send + core::marker::Sync
pub fn numrs2::util::result_type(types: &[&str]) -> &'static str
pub mod numrs2::views
pub enum numrs2::views::SliceOrIndex
pub numrs2::views::SliceOrIndex::Index(usize)
pub numrs2::views::SliceOrIndex::Slice(usize, core::option::Option<usize>, core::option::Option<usize>)
impl numrs2::views::SliceOrIndex
pub fn numrs2::views::SliceOrIndex::to_ndarray_slice(&self) -> ndarray::slice::Slice
pub struct numrs2::views::ArrayView<'a, T>
impl<'a, T: 'a> numrs2::views::ArrayView<'a, T>
pub fn numrs2::views::ArrayView<'a, T>::from_ndarray_view(view: ndarray::ArrayView<'a, T, ndarray::aliases::IxDyn>) -> Self
pub fn numrs2::views::ArrayView<'a, T>::get(&self, indices: &[usize]) -> numrs2::Result<T> where T: core::clone::Clone
pub fn numrs2::views::ArrayView<'a, T>::map<F, U>(&self, f: F) -> numrs2::array::Array<U> where F: core::ops::function::Fn(&T) -> U, U: core::clone::Clone
pub fn numrs2::views::ArrayView<'a, T>::ndim(&self) -> usize
pub fn numrs2::views::ArrayView<'a, T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::views::ArrayView<'a, T>::size(&self) -> usize
pub fn numrs2::views::ArrayView<'a, T>::slice_axis(&'a self, axis: ndarray::dimension::axis::Axis, indices: ndarray::slice::Slice) -> numrs2::views::ArrayView<'a, T>
pub fn numrs2::views::ArrayView<'a, T>::t(&'a self) -> numrs2::views::ArrayView<'a, T>
pub fn numrs2::views::ArrayView<'a, T>::to_owned(&self) -> numrs2::array::Array<T> where T: core::clone::Clone
pub fn numrs2::views::ArrayView<'a, T>::to_vec(&self) -> alloc::vec::Vec<T> where T: core::clone::Clone
pub fn numrs2::views::ArrayView<'a, T>::view(&self) -> &ndarray::ArrayView<'a, T, ndarray::aliases::IxDyn>
impl<'a, T> numrs2::views::ArrayView<'a, T> where T: 'a + core::clone::Clone + num_traits::cast::NumCast + core::fmt::Debug
pub fn numrs2::views::ArrayView<'a, T>::astype<U>(&self) -> numrs2::Result<numrs2::array::Array<U>> where U: core::clone::Clone + num_traits::cast::NumCast
pub fn numrs2::views::ArrayView<'a, T>::to_complex<U>(&self) -> numrs2::Result<numrs2::array::Array<num_complex::Complex<U>>> where U: core::clone::Clone + num_traits::cast::NumCast + num_traits::identities::Zero
impl<'a, T> core::ops::arith::Add for &numrs2::views::ArrayView<'a, T> where T: 'a + core::clone::Clone + core::ops::arith::Add<Output = T>
pub type &numrs2::views::ArrayView<'a, T>::Output = numrs2::array::Array<T>
pub fn &numrs2::views::ArrayView<'a, T>::add(self, rhs: &numrs2::views::ArrayView<'a, T>) -> Self::Output
impl<'a, T> core::ops::arith::Div for &numrs2::views::ArrayView<'a, T> where T: 'a + core::clone::Clone + core::ops::arith::Div<Output = T>
pub type &numrs2::views::ArrayView<'a, T>::Output = numrs2::array::Array<T>
pub fn &numrs2::views::ArrayView<'a, T>::div(self, rhs: &numrs2::views::ArrayView<'a, T>) -> Self::Output
impl<'a, T> core::ops::arith::Mul for &numrs2::views::ArrayView<'a, T> where T: 'a + core::clone::Clone + core::ops::arith::Mul<Output = T>
pub type &numrs2::views::ArrayView<'a, T>::Output = numrs2::array::Array<T>
pub fn &numrs2::views::ArrayView<'a, T>::mul(self, rhs: &numrs2::views::ArrayView<'a, T>) -> Self::Output
impl<'a, T> core::ops::arith::Sub for &numrs2::views::ArrayView<'a, T> where T: 'a + core::clone::Clone + core::ops::arith::Sub<Output = T>
pub type &numrs2::views::ArrayView<'a, T>::Output = numrs2::array::Array<T>
pub fn &numrs2::views::ArrayView<'a, T>::sub(self, rhs: &numrs2::views::ArrayView<'a, T>) -> Self::Output
pub struct numrs2::views::ArrayViewMut<'a, T>
impl<'a, T: 'a> numrs2::views::ArrayViewMut<'a, T>
pub fn numrs2::views::ArrayViewMut<'a, T>::from_ndarray_view_mut(view: ndarray::ArrayViewMut<'a, T, ndarray::aliases::IxDyn>) -> Self
pub fn numrs2::views::ArrayViewMut<'a, T>::get_mut(&mut self, indices: &[usize]) -> numrs2::Result<&mut T>
pub fn numrs2::views::ArrayViewMut<'a, T>::ndim(&self) -> usize
pub fn numrs2::views::ArrayViewMut<'a, T>::set(&mut self, indices: &[usize], value: T) -> numrs2::Result<()> where T: core::clone::Clone
pub fn numrs2::views::ArrayViewMut<'a, T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::views::ArrayViewMut<'a, T>::size(&self) -> usize
pub fn numrs2::views::ArrayViewMut<'a, T>::slice_axis_mut(&mut self, axis: ndarray::dimension::axis::Axis, indices: ndarray::slice::Slice) -> numrs2::views::ArrayViewMut<'_, T>
pub fn numrs2::views::ArrayViewMut<'a, T>::to_owned(&self) -> numrs2::array::Array<T> where T: core::clone::Clone
pub fn numrs2::views::ArrayViewMut<'a, T>::view_mut(&self) -> &ndarray::ArrayViewMut<'a, T, ndarray::aliases::IxDyn>
pub struct numrs2::views::DiagonalView<'a, T>
impl<'a, T: core::clone::Clone> numrs2::views::DiagonalView<'a, T>
pub fn numrs2::views::DiagonalView<'a, T>::get(&self, index: usize) -> core::option::Option<&T>
pub fn numrs2::views::DiagonalView<'a, T>::is_empty(&self) -> bool
pub fn numrs2::views::DiagonalView<'a, T>::iter(&self) -> impl core::iter::traits::iterator::Iterator<Item = &T>
pub fn numrs2::views::DiagonalView<'a, T>::len(&self) -> usize
pub fn numrs2::views::DiagonalView<'a, T>::new(data: &'a [T], rows: usize, cols: usize, offset: isize) -> numrs2::Result<Self>
pub fn numrs2::views::DiagonalView<'a, T>::to_vec(&self) -> alloc::vec::Vec<T>
pub struct numrs2::views::StridedArrayView<'a, T>
impl<'a, T: core::clone::Clone> numrs2::views::StridedArrayView<'a, T>
pub fn numrs2::views::StridedArrayView<'a, T>::get(&self, indices: &[usize]) -> core::option::Option<&T>
pub fn numrs2::views::StridedArrayView<'a, T>::iter(&self) -> impl core::iter::traits::iterator::Iterator<Item = T> + '_
pub fn numrs2::views::StridedArrayView<'a, T>::ndim(&self) -> usize
pub fn numrs2::views::StridedArrayView<'a, T>::new(data: &'a [T], shape: alloc::vec::Vec<usize>, strides: alloc::vec::Vec<isize>, offset: usize) -> Self
pub fn numrs2::views::StridedArrayView<'a, T>::shape(&self) -> &[usize]
pub fn numrs2::views::StridedArrayView<'a, T>::size(&self) -> usize
pub fn numrs2::views::StridedArrayView<'a, T>::strides(&self) -> &[isize]
pub fn numrs2::views::StridedArrayView<'a, T>::subview(&self, axis: usize, index: usize) -> core::option::Option<numrs2::views::StridedArrayView<'a, T>>
pub fn numrs2::views::StridedArrayView<'a, T>::to_owned(&self) -> numrs2::array::Array<T>
pub fn numrs2::views::StridedArrayView<'a, T>::to_vec(&self) -> alloc::vec::Vec<T>
pub struct numrs2::views::WindowView<'a, T>
impl<'a, T: core::clone::Clone> numrs2::views::WindowView<'a, T>
pub fn numrs2::views::WindowView<'a, T>::get_window(&self, position: &[usize]) -> core::option::Option<alloc::vec::Vec<T>>
pub fn numrs2::views::WindowView<'a, T>::n_windows(&self) -> &[usize]
pub fn numrs2::views::WindowView<'a, T>::new(data: &'a [T], source_shape: alloc::vec::Vec<usize>, window_shape: alloc::vec::Vec<usize>, step: alloc::vec::Vec<usize>) -> numrs2::Result<Self>
pub fn numrs2::views::WindowView<'a, T>::shape(&self) -> alloc::vec::Vec<usize>
pub fn numrs2::views::WindowView<'a, T>::to_owned(&self) -> numrs2::array::Array<T>
pub macro numrs2::error_location!
pub macro numrs2::operation_context!
pub macro numrs2::run_tests!
pub macro numrs2::simd_array!
pub enum numrs2::NumRs2Error
pub numrs2::NumRs2Error::AllocationFailed(alloc::string::String)
pub numrs2::NumRs2Error::BlasError(i32)
pub numrs2::NumRs2Error::Computation(numrs2::error::ComputationError)
pub numrs2::NumRs2Error::ComputationError(alloc::string::String)
pub numrs2::NumRs2Error::ConversionError(alloc::string::String)
pub numrs2::NumRs2Error::Core(numrs2::error::CoreError)
pub numrs2::NumRs2Error::DeserializationError(alloc::string::String)
pub numrs2::NumRs2Error::DimensionMismatch(alloc::string::String)
pub numrs2::NumRs2Error::FeatureNotEnabled(alloc::string::String)
pub numrs2::NumRs2Error::IO(numrs2::error::IOError)
pub numrs2::NumRs2Error::IOError(alloc::string::String)
pub numrs2::NumRs2Error::IndexError(alloc::string::String)
pub numrs2::NumRs2Error::IndexOutOfBounds(alloc::string::String)
pub numrs2::NumRs2Error::InvalidOperation(alloc::string::String)
pub numrs2::NumRs2Error::LapackError(alloc::string::String)
pub numrs2::NumRs2Error::Memory(numrs2::error::MemoryError)
pub numrs2::NumRs2Error::NotImplemented(alloc::string::String)
pub numrs2::NumRs2Error::RuntimeError(alloc::string::String)
pub numrs2::NumRs2Error::SerializationError(alloc::string::String)
pub numrs2::NumRs2Error::ShapeMismatch
pub numrs2::NumRs2Error::ShapeMismatch::actual: alloc::vec::Vec<usize>
pub numrs2::NumRs2Error::ShapeMismatch::expected: alloc::vec::Vec<usize>
pub numrs2::NumRs2Error::TypeCastError(alloc::string::String)
pub numrs2::NumRs2Error::ValueError(alloc::string::String)
impl numrs2::NumRs2Error
pub fn numrs2::NumRs2Error::at_location(self, location: numrs2::error::ErrorLocation) -> numrs2::error::ErrorContext<Self>
pub fn numrs2::NumRs2Error::category(&self) -> numrs2::error::ErrorCategory
pub fn numrs2::NumRs2Error::is_recoverable(&self) -> bool
pub fn numrs2::NumRs2Error::severity(&self) -> numrs2::error::ErrorSeverity
pub fn numrs2::NumRs2Error::with_context<C: core::convert::Into<numrs2::error::OperationContext>>(self, context: C) -> numrs2::error::ErrorContext<Self>
impl core::convert::From<std::io::error::Error> for numrs2::NumRs2Error
pub fn numrs2::NumRs2Error::from(err: std::io::error::Error) -> Self
pub type numrs2::Result<T> = core::result::Result<T, numrs2::NumRs2Error>
